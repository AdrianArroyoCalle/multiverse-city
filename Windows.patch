=== added directory 'DivCity'
=== added directory 'DivCity/Debug'
=== added directory 'DivCity/DivCity'
=== added file 'DivCity/DivCity.sdf'
Binary files DivCity/DivCity.sdf	1970-01-01 00:00:00 +0000 and DivCity/DivCity.sdf	2012-12-04 20:10:15 +0000 differ
=== added file 'DivCity/DivCity.sln'
--- DivCity/DivCity.sln	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity.sln	2012-12-04 18:44:51 +0000
@@ -0,0 +1,29 @@
+ï»¿
+Microsoft Visual Studio Solution File, Format Version 11.00
+# Visual Studio 2010
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "DivCity", "DivCity\DivCity.vcxproj", "{E85EBA9D-9A8B-4550-AA58-40F353AB8CA5}"
+	ProjectSection(ProjectDependencies) = postProject
+		{B5227EA9-EED1-4781-9541-E3E06B376563} = {B5227EA9-EED1-4781-9541-E3E06B376563}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "mctcube", "mctcube\mctcube.vcxproj", "{B5227EA9-EED1-4781-9541-E3E06B376563}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Win32 = Debug|Win32
+		Release|Win32 = Release|Win32
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{E85EBA9D-9A8B-4550-AA58-40F353AB8CA5}.Debug|Win32.ActiveCfg = Debug|Win32
+		{E85EBA9D-9A8B-4550-AA58-40F353AB8CA5}.Debug|Win32.Build.0 = Debug|Win32
+		{E85EBA9D-9A8B-4550-AA58-40F353AB8CA5}.Release|Win32.ActiveCfg = Release|Win32
+		{E85EBA9D-9A8B-4550-AA58-40F353AB8CA5}.Release|Win32.Build.0 = Release|Win32
+		{B5227EA9-EED1-4781-9541-E3E06B376563}.Debug|Win32.ActiveCfg = Debug|Win32
+		{B5227EA9-EED1-4781-9541-E3E06B376563}.Debug|Win32.Build.0 = Debug|Win32
+		{B5227EA9-EED1-4781-9541-E3E06B376563}.Release|Win32.ActiveCfg = Release|Win32
+		{B5227EA9-EED1-4781-9541-E3E06B376563}.Release|Win32.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal

=== added file 'DivCity/DivCity.suo'
Binary files DivCity/DivCity.suo	1970-01-01 00:00:00 +0000 and DivCity/DivCity.suo	2012-12-04 20:10:13 +0000 differ
=== added file 'DivCity/DivCity/ClassDiagram1.cd'
--- DivCity/DivCity/ClassDiagram1.cd	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/ClassDiagram1.cd	2012-12-04 19:14:27 +0000
@@ -0,0 +1,43 @@
+ï»¿<?xml version="1.0" encoding="utf-8"?>
+<ClassDiagram MajorVersion="1" MinorVersion="1">
+  <Class Name="Panel">
+    <Position X="5.5" Y="2" Width="1.5" />
+    <Compartments>
+      <Compartment Name="Fields" Collapsed="true" />
+      <Compartment Name="Methods" Collapsed="true" />
+    </Compartments>
+    <TypeIdentifier>
+      <HashCode>AAAAAAAAQAAAAAAEAAAAAAQEAABIAAABAAAABAAIEEA=</HashCode>
+      <FileName>C:\Divel\multiverse-city\MCT\MCTFrame.h</FileName>
+    </TypeIdentifier>
+  </Class>
+  <Class Name="Casilla">
+    <Position X="4.75" Y="0.5" Width="1.5" />
+    <TypeIdentifier>
+      <HashCode>AAAAAAAAQAAAAAAAAAgAAAAAQIAEGAAAAABgAAAAAAA=</HashCode>
+      <FileName>c:\divel\multiverse-city\libmctcube\libmctcube.h</FileName>
+    </TypeIdentifier>
+  </Class>
+  <Class Name="AlertBox">
+    <Position X="2.75" Y="0.5" Width="1.5" />
+    <TypeIdentifier>
+      <HashCode>AEAAAAAAEAAAAAAAABAAAAAAAAAEAAAAAAAAAAAAAAA=</HashCode>
+      <FileName>c:\divel\multiverse-city\libmctcube\libmctcube.h</FileName>
+    </TypeIdentifier>
+  </Class>
+  <Typedef Name="MCTCasilla" Collapsed="true">
+    <Position X="2.5" Y="3.25" Width="1.5" />
+    <TypeIdentifier>
+      <HashCode>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=</HashCode>
+      <FileName>c:\divel\multiverse-city\libmctcube\libmctcube.h</FileName>
+    </TypeIdentifier>
+  </Typedef>
+  <Enum Name="__unnamed_enum_008e_1" Collapsed="true">
+    <Position X="0.75" Y="1" Width="1.5" />
+    <TypeIdentifier>
+      <HashCode>AQAAAAAAAABgAAAAAAAAAAAAAAAAAAABAAAAACAEAAA=</HashCode>
+      <FileName>c:\divel\multiverse-city\libmctcube\libmctcube.h</FileName>
+    </TypeIdentifier>
+  </Enum>
+  <Font Name="Segoe UI" Size="9" />
+</ClassDiagram>
\ No newline at end of file

=== added directory 'DivCity/DivCity/Debug'
=== added file 'DivCity/DivCity/Debug/ResolveAssemblyReference.cache'
Binary files DivCity/DivCity/Debug/ResolveAssemblyReference.cache	1970-01-01 00:00:00 +0000 and DivCity/DivCity/Debug/ResolveAssemblyReference.cache	2012-12-04 19:12:49 +0000 differ
=== added file 'DivCity/DivCity/DivCity.ico'
Binary files DivCity/DivCity/DivCity.ico	1970-01-01 00:00:00 +0000 and DivCity/DivCity/DivCity.ico	2009-08-31 01:31:54 +0000 differ
=== added file 'DivCity/DivCity/DivCity.rc'
Binary files DivCity/DivCity/DivCity.rc	1970-01-01 00:00:00 +0000 and DivCity/DivCity/DivCity.rc	2012-12-04 18:22:48 +0000 differ
=== added file 'DivCity/DivCity/DivCity.vcxproj'
--- DivCity/DivCity/DivCity.vcxproj	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/DivCity.vcxproj	2012-12-04 19:55:12 +0000
@@ -0,0 +1,115 @@
+ï»¿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{E85EBA9D-9A8B-4550-AA58-40F353AB8CA5}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>DivCity</RootNamespace>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <WholeProgramOptimization>false</WholeProgramOptimization>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <LinkIncremental>true</LinkIncremental>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <LinkIncremental>false</LinkIncremental>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <PrecompiledHeader>Use</PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <AdditionalIncludeDirectories>C:\wxWidgets-2.9.3\include;C:\wxWidgets-2.9.3\include\msvc;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <CompileAsManaged>false</CompileAsManaged>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalLibraryDirectories>C:\Divel\multiverse-city\DivCity\DivCity;C:\wxWidgets-2.9.3\lib\vc_lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>libvlc.lib;libvlccore.lib;wxmsw29u_core.lib;wxbase29u.lib;comctl32.lib;rpcrt4.lib;winmm.lib;advapi32.lib;wsock32.lib;wxpng.lib;wxzlib.lib;%(AdditionalDependencies)</AdditionalDependencies>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>Disabled</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <AdditionalIncludeDirectories>C:\wxWidgets-2.9.3\include;C:\wxWidgets-2.9.3\include\msvc;C:\Divel\multiverse-city\DivCity\DivCity;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <CompileAsManaged>false</CompileAsManaged>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <WholeProgramOptimization>false</WholeProgramOptimization>
+      <FavorSizeOrSpeed>Neither</FavorSizeOrSpeed>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <GenerateDebugInformation>false</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>false</OptimizeReferences>
+      <AdditionalLibraryDirectories>C:\Divel\multiverse-city\DivCity\DivCity;C:\wxWidgets-2.9.3\lib\vc_lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>libvlc.lib;libvlccore.lib;wxmsw29u_core.lib;wxbase29u.lib;comctl32.lib;rpcrt4.lib;winmm.lib;advapi32.lib;wsock32.lib;wxpng.lib;wxzlib.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <Version>1.0</Version>
+      <ShowProgress>NotSet</ShowProgress>
+    </Link>
+    <ProjectReference>
+      <UseLibraryDependencyInputs>false</UseLibraryDependencyInputs>
+    </ProjectReference>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <None Include="ClassDiagram1.cd" />
+    <None Include="ReadMe.txt" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="..\..\MCT\Libs.h" />
+    <ClInclude Include="..\..\MCT\main.h" />
+    <ClInclude Include="..\..\MCT\MCTFrame.h" />
+    <ClInclude Include="..\..\MCT\Path.h" />
+    <ClInclude Include="..\..\MCT\VarGlobal.h" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="..\..\MCT\main.cpp" />
+    <ClCompile Include="..\..\MCT\MCTFrame.cpp" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\mctcube\mctcube.vcxproj">
+      <Project>{b5227ea9-eed1-4781-9541-e3e06b376563}</Project>
+    </ProjectReference>
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file

=== added file 'DivCity/DivCity/DivCity.vcxproj.filters'
--- DivCity/DivCity/DivCity.vcxproj.filters	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/DivCity.vcxproj.filters	2012-12-04 19:55:12 +0000
@@ -0,0 +1,46 @@
+ï»¿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Archivos de cÃ³digo fuente">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Archivos de encabezado">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Archivos de recursos">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <None Include="ReadMe.txt" />
+    <None Include="ClassDiagram1.cd" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="..\..\MCT\VarGlobal.h">
+      <Filter>Archivos de encabezado</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\MCT\MCTFrame.h">
+      <Filter>Archivos de encabezado</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\MCT\main.h">
+      <Filter>Archivos de encabezado</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\MCT\Libs.h">
+      <Filter>Archivos de encabezado</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\MCT\Path.h">
+      <Filter>Archivos de encabezado</Filter>
+    </ClInclude>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="..\..\MCT\main.cpp">
+      <Filter>Archivos de cÃ³digo fuente</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\MCT\MCTFrame.cpp">
+      <Filter>Archivos de cÃ³digo fuente</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file

=== added file 'DivCity/DivCity/DivCity.vcxproj.user'
--- DivCity/DivCity/DivCity.vcxproj.user	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/DivCity.vcxproj.user	2012-12-04 19:15:31 +0000
@@ -0,0 +1,6 @@
+ï»¿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <ShowAllFiles>false</ShowAllFiles>
+  </PropertyGroup>
+</Project>
\ No newline at end of file

=== added file 'DivCity/DivCity/RCa20180'
Binary files DivCity/DivCity/RCa20180	1970-01-01 00:00:00 +0000 and DivCity/DivCity/RCa20180	2012-12-04 18:30:05 +0000 differ
=== added file 'DivCity/DivCity/RCb20180'
Binary files DivCity/DivCity/RCb20180	1970-01-01 00:00:00 +0000 and DivCity/DivCity/RCb20180	2012-12-04 18:47:58 +0000 differ
=== added file 'DivCity/DivCity/ReadMe.txt'
--- DivCity/DivCity/ReadMe.txt	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/ReadMe.txt	2012-12-04 18:22:48 +0000
@@ -0,0 +1,71 @@
+ï»¿========================================================================
+    APLICACIÃ“N DE WIN32: DivCity 
+                         InformaciÃ³n general del proyecto
+========================================================================
+
+AppWizard ha creado esta aplicaciÃ³n DivCity.
+
+Este archivo incluye un resumen acerca del contenido de los archivos que 
+constituyen su aplicaciÃ³n DivCity.
+
+
+DivCity.vcxproj
+    Ã‰ste es el archivo de proyecto principal para los proyectos de VC++ 
+    generados mediante un Asistente para aplicaciones.
+    Contiene informaciÃ³n acerca de la versiÃ³n de Visual C++ con la que 
+    se generÃ³ el archivo, asÃ­ como informaciÃ³n acerca de las plataformas, 
+    configuraciones y caracterÃ­sticas del proyecto seleccionadas en el 
+    asistente para aplicaciones.
+
+DivCity.vcxproj.filters
+    Ã‰ste es el archivo de filtros para los proyectos de VC++ generados 
+    mediante un asistente para aplicaciones. 
+    Contiene informaciÃ³n acerca de la asociaciÃ³n entre los archivos de 
+    un proyecto y los filtros. Esta asociaciÃ³n se usa en el IDE para mostrar 
+    la agrupaciÃ³n de archivos con extensiones similares bajo un nodo 
+    especÃ­fico (por ejemplo, los archivos ".cpp" se asocian con el filtro
+    "Archivos de cÃ³digo fuente").
+
+DivCity.cpp
+    Ã‰sta es la aplicaciÃ³n principal del archivo de cÃ³digo fuente.
+
+/////////////////////////////////////////////////////////////////////////////
+AppWizard ha creado los siguientes recursos:
+
+DivCity.rc
+    Ã‰sta es una lista de todos los recursos de Microsoft Windows que utiliza 
+    el programa. Incluye los iconos, mapas de bits y cursores almacenados en el 
+    subdirectorio RES. Este archivo puede editarse directamente en 
+    Microsoft Visual C++.
+
+Resource.h
+    Ã‰ste es el archivo de encabezado estÃ¡ndar, que define nuevos 
+    identificadores de recurso.
+    Microsoft Visual C++ lee y actualiza este archivo.
+
+DivCity.ico
+    Ã‰ste es un archivo de icono, que se utiliza como el icono de la aplicaciÃ³n 
+    (32x32).
+    Este icono estÃ¡ incluido en el archivo principal de recursos 
+    DivCity.rc.
+
+small.ico
+    Este es un archivo de icono, que contiene una versiÃ³n menor (16x16) del 
+    icono de la aplicaciÃ³n. Este icono estÃ¡ incluido en el archivo principal 
+    de recursos DivCity.rc.
+
+/////////////////////////////////////////////////////////////////////////////
+Otros archivos estÃ¡ndar:
+
+StdAfx.h, StdAfx.cpp
+    Estos archivos se utilizan para crear un archivo de encabezado precompilado 
+    (PCH) denominado DivCity.pch y un archivo de tipos 
+    precompilado denominado StdAfx.obj.
+
+/////////////////////////////////////////////////////////////////////////////
+Otras notas:
+
+El asistente para aplicaciones utiliza comentarios "TODO:" para indicar las 
+partes del cÃ³digo fuente que tendrÃ¡ que agregar o personalizar.
+
+/////////////////////////////////////////////////////////////////////////////

=== added directory 'DivCity/DivCity/Release'
=== added file 'DivCity/DivCity/Release/CL.1068.read.1.tlog'
--- DivCity/DivCity/Release/CL.1068.read.1.tlog	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/Release/CL.1068.read.1.tlog	2012-12-04 20:00:48 +0000
@@ -0,0 +1,1 @@
+ÿþ
\ No newline at end of file

=== added file 'DivCity/DivCity/Release/CL.1068.write.1.tlog'
--- DivCity/DivCity/Release/CL.1068.write.1.tlog	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/Release/CL.1068.write.1.tlog	2012-12-04 20:00:48 +0000
@@ -0,0 +1,1 @@
+ÿþ
\ No newline at end of file

=== added file 'DivCity/DivCity/Release/CL.12804.read.1.tlog'
--- DivCity/DivCity/Release/CL.12804.read.1.tlog	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/Release/CL.12804.read.1.tlog	2012-12-04 20:00:48 +0000
@@ -0,0 +1,1 @@
+ÿþ
\ No newline at end of file

=== added file 'DivCity/DivCity/Release/CL.12804.write.1.tlog'
--- DivCity/DivCity/Release/CL.12804.write.1.tlog	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/Release/CL.12804.write.1.tlog	2012-12-04 20:00:48 +0000
@@ -0,0 +1,1 @@
+ÿþ
\ No newline at end of file

=== added file 'DivCity/DivCity/Release/CL.13004.read.1.tlog'
--- DivCity/DivCity/Release/CL.13004.read.1.tlog	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/Release/CL.13004.read.1.tlog	2012-12-04 20:00:48 +0000
@@ -0,0 +1,1 @@
+ÿþ
\ No newline at end of file

=== added file 'DivCity/DivCity/Release/CL.13004.write.1.tlog'
--- DivCity/DivCity/Release/CL.13004.write.1.tlog	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/Release/CL.13004.write.1.tlog	2012-12-04 20:00:48 +0000
@@ -0,0 +1,1 @@
+ÿþ
\ No newline at end of file

=== added file 'DivCity/DivCity/Release/CL.14504.read.1.tlog'
--- DivCity/DivCity/Release/CL.14504.read.1.tlog	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/Release/CL.14504.read.1.tlog	2012-12-04 20:00:48 +0000
@@ -0,0 +1,1 @@
+ÿþ
\ No newline at end of file

=== added file 'DivCity/DivCity/Release/CL.14504.write.1.tlog'
--- DivCity/DivCity/Release/CL.14504.write.1.tlog	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/Release/CL.14504.write.1.tlog	2012-12-04 20:00:48 +0000
@@ -0,0 +1,1 @@
+ÿþ
\ No newline at end of file

=== added file 'DivCity/DivCity/Release/CL.14796.read.1.tlog'
--- DivCity/DivCity/Release/CL.14796.read.1.tlog	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/Release/CL.14796.read.1.tlog	2012-12-04 20:00:48 +0000
@@ -0,0 +1,1 @@
+ÿþ
\ No newline at end of file

=== added file 'DivCity/DivCity/Release/CL.14796.write.1.tlog'
--- DivCity/DivCity/Release/CL.14796.write.1.tlog	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/Release/CL.14796.write.1.tlog	2012-12-04 20:00:48 +0000
@@ -0,0 +1,1 @@
+ÿþ
\ No newline at end of file

=== added file 'DivCity/DivCity/Release/CL.17604.read.1.tlog'
--- DivCity/DivCity/Release/CL.17604.read.1.tlog	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/Release/CL.17604.read.1.tlog	2012-12-04 20:00:48 +0000
@@ -0,0 +1,1 @@
+ÿþ
\ No newline at end of file

=== added file 'DivCity/DivCity/Release/CL.17604.write.1.tlog'
--- DivCity/DivCity/Release/CL.17604.write.1.tlog	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/Release/CL.17604.write.1.tlog	2012-12-04 20:00:48 +0000
@@ -0,0 +1,1 @@
+ÿþ
\ No newline at end of file

=== added file 'DivCity/DivCity/Release/CL.1780.read.1.tlog'
--- DivCity/DivCity/Release/CL.1780.read.1.tlog	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/Release/CL.1780.read.1.tlog	2012-12-04 20:00:48 +0000
@@ -0,0 +1,1 @@
+ÿþ
\ No newline at end of file

=== added file 'DivCity/DivCity/Release/CL.1780.write.1.tlog'
--- DivCity/DivCity/Release/CL.1780.write.1.tlog	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/Release/CL.1780.write.1.tlog	2012-12-04 20:00:48 +0000
@@ -0,0 +1,1 @@
+ÿþ
\ No newline at end of file

=== added file 'DivCity/DivCity/Release/CL.17912.read.1.tlog'
--- DivCity/DivCity/Release/CL.17912.read.1.tlog	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/Release/CL.17912.read.1.tlog	2012-12-04 20:00:48 +0000
@@ -0,0 +1,1 @@
+ÿþ
\ No newline at end of file

=== added file 'DivCity/DivCity/Release/CL.17912.write.1.tlog'
--- DivCity/DivCity/Release/CL.17912.write.1.tlog	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/Release/CL.17912.write.1.tlog	2012-12-04 20:00:48 +0000
@@ -0,0 +1,1 @@
+ÿþ
\ No newline at end of file

=== added file 'DivCity/DivCity/Release/CL.17932.read.1.tlog'
--- DivCity/DivCity/Release/CL.17932.read.1.tlog	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/Release/CL.17932.read.1.tlog	2012-12-04 20:00:48 +0000
@@ -0,0 +1,1 @@
+ÿþ
\ No newline at end of file

=== added file 'DivCity/DivCity/Release/CL.17932.write.1.tlog'
--- DivCity/DivCity/Release/CL.17932.write.1.tlog	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/Release/CL.17932.write.1.tlog	2012-12-04 20:00:48 +0000
@@ -0,0 +1,1 @@
+ÿþ
\ No newline at end of file

=== added file 'DivCity/DivCity/Release/CL.18456.read.1.tlog'
--- DivCity/DivCity/Release/CL.18456.read.1.tlog	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/Release/CL.18456.read.1.tlog	2012-12-04 20:00:48 +0000
@@ -0,0 +1,1 @@
+ÿþ
\ No newline at end of file

=== added file 'DivCity/DivCity/Release/CL.18456.write.1.tlog'
--- DivCity/DivCity/Release/CL.18456.write.1.tlog	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/Release/CL.18456.write.1.tlog	2012-12-04 20:00:48 +0000
@@ -0,0 +1,1 @@
+ÿþ
\ No newline at end of file

=== added file 'DivCity/DivCity/Release/CL.20556.read.1.tlog'
--- DivCity/DivCity/Release/CL.20556.read.1.tlog	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/Release/CL.20556.read.1.tlog	2012-12-04 20:00:48 +0000
@@ -0,0 +1,1 @@
+ÿþ
\ No newline at end of file

=== added file 'DivCity/DivCity/Release/CL.20556.write.1.tlog'
--- DivCity/DivCity/Release/CL.20556.write.1.tlog	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/Release/CL.20556.write.1.tlog	2012-12-04 20:00:48 +0000
@@ -0,0 +1,1 @@
+ÿþ
\ No newline at end of file

=== added file 'DivCity/DivCity/Release/CL.20604.read.1.tlog'
--- DivCity/DivCity/Release/CL.20604.read.1.tlog	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/Release/CL.20604.read.1.tlog	2012-12-04 20:00:48 +0000
@@ -0,0 +1,1 @@
+ÿþ
\ No newline at end of file

=== added file 'DivCity/DivCity/Release/CL.20604.write.1.tlog'
--- DivCity/DivCity/Release/CL.20604.write.1.tlog	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/Release/CL.20604.write.1.tlog	2012-12-04 20:00:48 +0000
@@ -0,0 +1,1 @@
+ÿþ
\ No newline at end of file

=== added file 'DivCity/DivCity/Release/CL.20776.read.1.tlog'
--- DivCity/DivCity/Release/CL.20776.read.1.tlog	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/Release/CL.20776.read.1.tlog	2012-12-04 20:00:48 +0000
@@ -0,0 +1,1 @@
+ÿþ
\ No newline at end of file

=== added file 'DivCity/DivCity/Release/CL.20776.write.1.tlog'
--- DivCity/DivCity/Release/CL.20776.write.1.tlog	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/Release/CL.20776.write.1.tlog	2012-12-04 20:00:48 +0000
@@ -0,0 +1,1 @@
+ÿþ
\ No newline at end of file

=== added file 'DivCity/DivCity/Release/CL.4992.read.1.tlog'
--- DivCity/DivCity/Release/CL.4992.read.1.tlog	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/Release/CL.4992.read.1.tlog	2012-12-04 20:00:48 +0000
@@ -0,0 +1,1 @@
+ÿþ
\ No newline at end of file

=== added file 'DivCity/DivCity/Release/CL.4992.write.1.tlog'
--- DivCity/DivCity/Release/CL.4992.write.1.tlog	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/Release/CL.4992.write.1.tlog	2012-12-04 20:00:48 +0000
@@ -0,0 +1,1 @@
+ÿþ
\ No newline at end of file

=== added file 'DivCity/DivCity/Release/CL.5860.read.1.tlog'
--- DivCity/DivCity/Release/CL.5860.read.1.tlog	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/Release/CL.5860.read.1.tlog	2012-12-04 20:00:48 +0000
@@ -0,0 +1,1 @@
+ÿþ
\ No newline at end of file

=== added file 'DivCity/DivCity/Release/CL.5860.write.1.tlog'
--- DivCity/DivCity/Release/CL.5860.write.1.tlog	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/Release/CL.5860.write.1.tlog	2012-12-04 20:00:48 +0000
@@ -0,0 +1,1 @@
+ÿþ
\ No newline at end of file

=== added file 'DivCity/DivCity/Release/CL.8600.read.1.tlog'
--- DivCity/DivCity/Release/CL.8600.read.1.tlog	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/Release/CL.8600.read.1.tlog	2012-12-04 20:00:48 +0000
@@ -0,0 +1,1 @@
+ÿþ
\ No newline at end of file

=== added file 'DivCity/DivCity/Release/CL.8600.write.1.tlog'
--- DivCity/DivCity/Release/CL.8600.write.1.tlog	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/Release/CL.8600.write.1.tlog	2012-12-04 20:00:48 +0000
@@ -0,0 +1,1 @@
+ÿþ
\ No newline at end of file

=== added file 'DivCity/DivCity/Release/CL.8700.read.1.tlog'
--- DivCity/DivCity/Release/CL.8700.read.1.tlog	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/Release/CL.8700.read.1.tlog	2012-12-04 20:00:48 +0000
@@ -0,0 +1,1 @@
+ÿþ
\ No newline at end of file

=== added file 'DivCity/DivCity/Release/CL.8700.write.1.tlog'
--- DivCity/DivCity/Release/CL.8700.write.1.tlog	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/Release/CL.8700.write.1.tlog	2012-12-04 20:00:48 +0000
@@ -0,0 +1,1 @@
+ÿþ
\ No newline at end of file

=== added file 'DivCity/DivCity/Release/CL.912.read.1.tlog'
--- DivCity/DivCity/Release/CL.912.read.1.tlog	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/Release/CL.912.read.1.tlog	2012-12-04 20:00:48 +0000
@@ -0,0 +1,1 @@
+ÿþ
\ No newline at end of file

=== added file 'DivCity/DivCity/Release/CL.912.write.1.tlog'
--- DivCity/DivCity/Release/CL.912.write.1.tlog	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/Release/CL.912.write.1.tlog	2012-12-04 20:00:48 +0000
@@ -0,0 +1,1 @@
+ÿþ
\ No newline at end of file

=== added file 'DivCity/DivCity/Release/CL.read.1.tlog'
Binary files DivCity/DivCity/Release/CL.read.1.tlog	1970-01-01 00:00:00 +0000 and DivCity/DivCity/Release/CL.read.1.tlog	2012-12-04 20:00:48 +0000 differ
=== added file 'DivCity/DivCity/Release/DivCity.exe.intermediate.manifest'
--- DivCity/DivCity/Release/DivCity.exe.intermediate.manifest	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/Release/DivCity.exe.intermediate.manifest	2012-12-04 20:09:08 +0000
@@ -0,0 +1,15 @@
+<?xml version='1.0' encoding='UTF-8' standalone='yes'?>
+<assembly xmlns='urn:schemas-microsoft-com:asm.v1' manifestVersion='1.0'>
+  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v3">
+    <security>
+      <requestedPrivileges>
+        <requestedExecutionLevel level='asInvoker' uiAccess='false' />
+      </requestedPrivileges>
+    </security>
+  </trustInfo>
+  <dependency>
+    <dependentAssembly>
+      <assemblyIdentity type='win32'              name='Microsoft.Windows.Common-Controls'        version='6.0.0.0'                               processorArchitecture='x86'                   publicKeyToken='6595b64144ccf1df'               language='*' />
+    </dependentAssembly>
+  </dependency>
+</assembly>

=== added file 'DivCity/DivCity/Release/DivCity.lastbuildstate'
--- DivCity/DivCity/Release/DivCity.lastbuildstate	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/Release/DivCity.lastbuildstate	2012-12-04 20:09:12 +0000
@@ -0,0 +1,2 @@
+#v4.0:v100
+Release|Win32|C:\Divel\multiverse-city\DivCity\|

=== added file 'DivCity/DivCity/Release/DivCity.log'
--- DivCity/DivCity/Release/DivCity.log	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/Release/DivCity.log	2012-12-04 20:09:12 +0000
@@ -0,0 +1,21 @@
+ï»¿CompilaciÃ³n iniciada a las 04/12/2012 21:09:05.
+     1>Proyecto "C:\Divel\multiverse-city\DivCity\DivCity\DivCity.vcxproj" en el nodo 3 (build destinos).
+     1>InitializeBuildStatus:
+         Se crearÃ¡ "Release\DivCity.unsuccessfulbuild" porque se especificÃ³ "AlwaysCreate".
+       ClCompile:
+         Todas las salidas estÃ¡n actualizadas.
+       Link:
+         c:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\bin\link.exe /ERRORREPORT:PROMPT /OUT:"C:\Divel\multiverse-city\DivCity\Release\DivCity.exe" /VERSION:"1.0" /INCREMENTAL:NO /NOLOGO /LIBPATH:"C:\Divel\multiverse-city\DivCity\DivCity" /LIBPATH:"C:\wxWidgets-2.9.3\lib\vc_lib" libvlc.lib libvlccore.lib wxmsw29u_core.lib wxbase29u.lib comctl32.lib rpcrt4.lib winmm.lib advapi32.lib wsock32.lib wxpng.lib wxzlib.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /MANIFEST /ManifestFile:"Release\DivCity.exe.intermediate.manifest" /MANIFESTUAC:"level='asInvoker' uiAccess='false'" /PDB:"C:\Divel\multiverse-city\DivCity\Release\DivCity.pdb" /SUBSYSTEM:WINDOWS /OPT:NOREF /OPT:ICF /TLBID:1 /DYNAMICBASE /NXCOMPAT /IMPLIB:"C:\Divel\multiverse-city\DivCity\Release\DivCity.lib" /MACHINE:X86 Release\main.obj
+         Release\MCTFrame.obj
+         "C:\Divel\multiverse-city\DivCity\Release\mctcube.lib"
+         DivCity.vcxproj -> C:\Divel\multiverse-city\DivCity\Release\DivCity.exe
+       Manifest:
+         c:\Program Files (x86)\Microsoft SDKs\Windows\v7.0A\bin\mt.exe /nologo /verbose /outputresource:"C:\Divel\multiverse-city\DivCity\Release\DivCity.exe;#1" /manifest Release\DivCity.exe.intermediate.manifest
+       FinalizeBuildStatus:
+         Se eliminarÃ¡ el archivo "Release\DivCity.unsuccessfulbuild".
+         Aplicando tarea Touch a "Release\DivCity.lastbuildstate".
+     1>CompilaciÃ³n del proyecto terminada "C:\Divel\multiverse-city\DivCity\DivCity\DivCity.vcxproj" (build destinos).
+
+CompilaciÃ³n correcta.
+
+Tiempo transcurrido 00:00:07.52

=== added file 'DivCity/DivCity/Release/DivCity.write.1.tlog'
=== added file 'DivCity/DivCity/Release/MCTFrame.obj'
Binary files DivCity/DivCity/Release/MCTFrame.obj	1970-01-01 00:00:00 +0000 and DivCity/DivCity/Release/MCTFrame.obj	2012-12-04 20:00:47 +0000 differ
=== added file 'DivCity/DivCity/Release/RCa13740'
Binary files DivCity/DivCity/Release/RCa13740	1970-01-01 00:00:00 +0000 and DivCity/DivCity/Release/RCa13740	2012-12-04 18:55:53 +0000 differ
=== added file 'DivCity/DivCity/Release/cl.command.1.tlog'
Binary files DivCity/DivCity/Release/cl.command.1.tlog	1970-01-01 00:00:00 +0000 and DivCity/DivCity/Release/cl.command.1.tlog	2012-12-04 20:00:48 +0000 differ
=== added file 'DivCity/DivCity/Release/cl.write.1.tlog'
Binary files DivCity/DivCity/Release/cl.write.1.tlog	1970-01-01 00:00:00 +0000 and DivCity/DivCity/Release/cl.write.1.tlog	2012-12-04 20:00:48 +0000 differ
=== added file 'DivCity/DivCity/Release/link.9160.read.1.tlog'
--- DivCity/DivCity/Release/link.9160.read.1.tlog	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/Release/link.9160.read.1.tlog	2012-12-04 20:09:09 +0000
@@ -0,0 +1,1 @@
+ÿþ
\ No newline at end of file

=== added file 'DivCity/DivCity/Release/link.9160.write.1.tlog'
--- DivCity/DivCity/Release/link.9160.write.1.tlog	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/Release/link.9160.write.1.tlog	2012-12-04 20:09:09 +0000
@@ -0,0 +1,1 @@
+ÿþ
\ No newline at end of file

=== added file 'DivCity/DivCity/Release/link.command.1.tlog'
Binary files DivCity/DivCity/Release/link.command.1.tlog	1970-01-01 00:00:00 +0000 and DivCity/DivCity/Release/link.command.1.tlog	2012-12-04 20:09:09 +0000 differ
=== added file 'DivCity/DivCity/Release/link.read.1.tlog'
Binary files DivCity/DivCity/Release/link.read.1.tlog	1970-01-01 00:00:00 +0000 and DivCity/DivCity/Release/link.read.1.tlog	2012-12-04 20:09:09 +0000 differ
=== added file 'DivCity/DivCity/Release/link.write.1.tlog'
Binary files DivCity/DivCity/Release/link.write.1.tlog	1970-01-01 00:00:00 +0000 and DivCity/DivCity/Release/link.write.1.tlog	2012-12-04 20:09:09 +0000 differ
=== added file 'DivCity/DivCity/Release/main.obj'
Binary files DivCity/DivCity/Release/main.obj	1970-01-01 00:00:00 +0000 and DivCity/DivCity/Release/main.obj	2012-12-04 20:00:47 +0000 differ
=== added file 'DivCity/DivCity/Release/mt.command.1.tlog'
Binary files DivCity/DivCity/Release/mt.command.1.tlog	1970-01-01 00:00:00 +0000 and DivCity/DivCity/Release/mt.command.1.tlog	2012-12-04 20:09:12 +0000 differ
=== added file 'DivCity/DivCity/Release/mt.read.1.tlog'
Binary files DivCity/DivCity/Release/mt.read.1.tlog	1970-01-01 00:00:00 +0000 and DivCity/DivCity/Release/mt.read.1.tlog	2012-12-04 20:09:12 +0000 differ
=== added file 'DivCity/DivCity/Release/mt.write.1.tlog'
Binary files DivCity/DivCity/Release/mt.write.1.tlog	1970-01-01 00:00:00 +0000 and DivCity/DivCity/Release/mt.write.1.tlog	2012-12-04 20:09:12 +0000 differ
=== added file 'DivCity/DivCity/Release/rc.command.1.tlog'
--- DivCity/DivCity/Release/rc.command.1.tlog	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/Release/rc.command.1.tlog	2012-12-04 18:55:54 +0000
@@ -0,0 +1,1 @@
+ÿþ
\ No newline at end of file

=== added file 'DivCity/DivCity/Release/rc.read.1.tlog'
--- DivCity/DivCity/Release/rc.read.1.tlog	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/Release/rc.read.1.tlog	2012-12-04 18:55:54 +0000
@@ -0,0 +1,1 @@
+ÿþ
\ No newline at end of file

=== added file 'DivCity/DivCity/Release/rc.write.1.tlog'
--- DivCity/DivCity/Release/rc.write.1.tlog	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/Release/rc.write.1.tlog	2012-12-04 18:55:54 +0000
@@ -0,0 +1,1 @@
+ÿþ
\ No newline at end of file

=== added file 'DivCity/DivCity/Release/vc100.pdb'
Binary files DivCity/DivCity/Release/vc100.pdb	1970-01-01 00:00:00 +0000 and DivCity/DivCity/Release/vc100.pdb	2012-12-04 20:00:47 +0000 differ
=== added file 'DivCity/DivCity/libvlc.dll'
Binary files DivCity/DivCity/libvlc.dll	1970-01-01 00:00:00 +0000 and DivCity/DivCity/libvlc.dll	2012-10-15 20:27:56 +0000 differ
=== added file 'DivCity/DivCity/libvlc.lib'
Binary files DivCity/DivCity/libvlc.lib	1970-01-01 00:00:00 +0000 and DivCity/DivCity/libvlc.lib	2012-10-15 20:27:46 +0000 differ
=== added file 'DivCity/DivCity/libvlccore.dll'
Binary files DivCity/DivCity/libvlccore.dll	1970-01-01 00:00:00 +0000 and DivCity/DivCity/libvlccore.dll	2012-10-15 20:28:38 +0000 differ
=== added file 'DivCity/DivCity/libvlccore.lib'
Binary files DivCity/DivCity/libvlccore.lib	1970-01-01 00:00:00 +0000 and DivCity/DivCity/libvlccore.lib	2012-10-15 20:27:46 +0000 differ
=== added file 'DivCity/DivCity/small.ico'
Binary files DivCity/DivCity/small.ico	1970-01-01 00:00:00 +0000 and DivCity/DivCity/small.ico	2009-08-31 01:31:54 +0000 differ
=== added directory 'DivCity/DivCity/vlc'
=== added file 'DivCity/DivCity/vlc/deprecated.h'
--- DivCity/DivCity/vlc/deprecated.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/deprecated.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,69 @@
+/*****************************************************************************
+ * deprecated.h:  libvlc deprecated API
+ *****************************************************************************
+ * Copyright (C) 1998-2008 VLC authors and VideoLAN
+ * $Id: 7f55090fcd482489ceed9145ce2253e78fa6fd2a $
+ *
+ * Authors: ClÃ©ment Stenac <zorglub@videolan.org>
+ *          Jean-Paul Saman <jpsaman@videolan.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef LIBVLC_DEPRECATED_H
+#define LIBVLC_DEPRECATED_H 1
+
+/**
+ * \file
+ * This file defines libvlc deprecated API
+ */
+
+# ifdef __cplusplus
+extern "C" {
+# endif
+
+/*****************************************************************************
+ * Playlist (Deprecated)
+ *****************************************************************************/
+/** \defgroup libvlc_playlist LibVLC playlist (legacy)
+ * \ingroup libvlc
+ * @deprecated Use @ref libvlc_media_list instead.
+ * @{
+ */
+
+/**
+ * Start playing (if there is any item in the playlist).
+ *
+ * Additionnal playlist item options can be specified for addition to the
+ * item before it is played.
+ *
+ * \param p_instance the playlist instance
+ * \param i_id the item to play. If this is a negative number, the next
+ *        item will be selected. Otherwise, the item with the given ID will be
+ *        played
+ * \param i_options the number of options to add to the item
+ * \param ppsz_options the options to add to the item
+ */
+LIBVLC_DEPRECATED LIBVLC_API
+void libvlc_playlist_play( libvlc_instance_t *p_instance, int i_id,
+                           int i_options, char **ppsz_options );
+
+/** @}*/
+
+# ifdef __cplusplus
+}
+# endif
+
+#endif /* _LIBVLC_DEPRECATED_H */

=== added file 'DivCity/DivCity/vlc/libvlc.h'
--- DivCity/DivCity/vlc/libvlc.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/libvlc.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,496 @@
+/*****************************************************************************
+ * libvlc.h:  libvlc external API
+ *****************************************************************************
+ * Copyright (C) 1998-2009 VLC authors and VideoLAN
+ * $Id: f7f4530556bbdc06d35bdceca35b87e0f6f18df3 $
+ *
+ * Authors: ClÃ©ment Stenac <zorglub@videolan.org>
+ *          Jean-Paul Saman <jpsaman@videolan.org>
+ *          Pierre d'Herbemont <pdherbemont@videolan.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+/**
+ * \file
+ * This file defines libvlc external API
+ */
+
+/**
+ * \defgroup libvlc LibVLC
+ * LibVLC is the external programming interface of the VLC media player.
+ * It is used to embed VLC into other applications or frameworks.
+ * @{
+ */
+
+#ifndef VLC_LIBVLC_H
+#define VLC_LIBVLC_H 1
+
+#if defined (WIN32) && defined (DLL_EXPORT)
+# define LIBVLC_API __declspec(dllexport)
+#elif defined (__GNUC__) && (__GNUC__ >= 4)
+# define LIBVLC_API __attribute__((visibility("default")))
+#else
+# define LIBVLC_API
+#endif
+
+#ifdef __LIBVLC__
+/* Avoid unhelpful warnings from libvlc with our deprecated APIs */
+#   define LIBVLC_DEPRECATED
+#elif defined(__GNUC__) && \
+      (__GNUC__ > 3 || __GNUC__ == 3 && __GNUC_MINOR__ > 0)
+# define LIBVLC_DEPRECATED __attribute__((deprecated))
+#else
+# define LIBVLC_DEPRECATED
+#endif
+
+# ifdef __cplusplus
+extern "C" {
+# endif
+
+#include <stdarg.h>
+#include <vlc/libvlc_structures.h>
+
+/** \defgroup libvlc_core LibVLC core
+ * \ingroup libvlc
+ * Before it can do anything useful, LibVLC must be initialized.
+ * You can create one (or more) instance(s) of LibVLC in a given process,
+ * with libvlc_new() and destroy them with libvlc_release().
+ *
+ * \version Unless otherwise stated, these functions are available
+ * from LibVLC versions numbered 1.1.0 or more.
+ * Earlier versions (0.9.x and 1.0.x) are <b>not</b> compatible.
+ * @{
+ */
+
+/** \defgroup libvlc_error LibVLC error handling
+ * @{
+ */
+
+/**
+ * A human-readable error message for the last LibVLC error in the calling
+ * thread. The resulting string is valid until another error occurs (at least
+ * until the next LibVLC call).
+ *
+ * @warning
+ * This will be NULL if there was no error.
+ */
+LIBVLC_API const char *libvlc_errmsg (void);
+
+/**
+ * Clears the LibVLC error status for the current thread. This is optional.
+ * By default, the error status is automatically overridden when a new error
+ * occurs, and destroyed when the thread exits.
+ */
+LIBVLC_API void libvlc_clearerr (void);
+
+/**
+ * Sets the LibVLC error status and message for the current thread.
+ * Any previous error is overridden.
+ * \return a nul terminated string in any case
+ */
+LIBVLC_API const char *libvlc_vprinterr (const char *fmt, va_list ap);
+
+/**
+ * Sets the LibVLC error status and message for the current thread.
+ * Any previous error is overridden.
+ * \return a nul terminated string in any case
+ */
+LIBVLC_API const char *libvlc_printerr (const char *fmt, ...);
+
+/**@} */
+
+/**
+ * Create and initialize a libvlc instance.
+ * This functions accept a list of "command line" arguments similar to the
+ * main(). These arguments affect the LibVLC instance default configuration.
+ *
+ * \version
+ * Arguments are meant to be passed from the command line to LibVLC, just like
+ * VLC media player does. The list of valid arguments depends on the LibVLC
+ * version, the operating system and platform, and set of available LibVLC
+ * plugins. Invalid or unsupported arguments will cause the function to fail
+ * (i.e. return NULL). Also, some arguments may alter the behaviour or
+ * otherwise interfere with other LibVLC functions.
+ *
+ * \warning
+ * There is absolutely no warranty or promise of forward, backward and
+ * cross-platform compatibility with regards to libvlc_new() arguments.
+ * We recommend that you do not use them, other than when debugging.
+ *
+ * \param argc the number of arguments (should be 0)
+ * \param argv list of arguments (should be NULL)
+ * \return the libvlc instance or NULL in case of error
+ */
+LIBVLC_API libvlc_instance_t *
+libvlc_new( int argc , const char *const *argv );
+
+/**
+ * Decrement the reference count of a libvlc instance, and destroy it
+ * if it reaches zero.
+ *
+ * \param p_instance the instance to destroy
+ */
+LIBVLC_API void libvlc_release( libvlc_instance_t *p_instance );
+
+/**
+ * Increments the reference count of a libvlc instance.
+ * The initial reference count is 1 after libvlc_new() returns.
+ *
+ * \param p_instance the instance to reference
+ */
+LIBVLC_API void libvlc_retain( libvlc_instance_t *p_instance );
+
+/**
+ * Try to start a user interface for the libvlc instance.
+ *
+ * \param p_instance the instance
+ * \param name interface name, or NULL for default
+ * \return 0 on success, -1 on error.
+ */
+LIBVLC_API
+int libvlc_add_intf( libvlc_instance_t *p_instance, const char *name );
+
+/**
+ * Registers a callback for the LibVLC exit event. This is mostly useful if
+ * you have started at least one interface with libvlc_add_intf().
+ * Typically, this function will wake up your application main loop (from
+ * another thread).
+ *
+ * \param p_instance LibVLC instance
+ * \param cb callback to invoke when LibVLC wants to exit
+ * \param opaque data pointer for the callback
+ * \warning This function and libvlc_wait() cannot be used at the same time.
+ * Use either or none of them but not both.
+ */
+LIBVLC_API
+void libvlc_set_exit_handler( libvlc_instance_t *p_instance,
+                              void (*cb) (void *), void *opaque );
+
+/**
+ * Waits until an interface causes the instance to exit.
+ * You should start at least one interface first, using libvlc_add_intf().
+ *
+ * \param p_instance the instance
+ */
+LIBVLC_API
+void libvlc_wait( libvlc_instance_t *p_instance );
+
+/**
+ * Sets the application name. LibVLC passes this as the user agent string
+ * when a protocol requires it.
+ *
+ * \param p_instance LibVLC instance
+ * \param name human-readable application name, e.g. "FooBar player 1.2.3"
+ * \param http HTTP User Agent, e.g. "FooBar/1.2.3 Python/2.6.0"
+ * \version LibVLC 1.1.1 or later
+ */
+LIBVLC_API
+void libvlc_set_user_agent( libvlc_instance_t *p_instance,
+                            const char *name, const char *http );
+
+/**
+ * Retrieve libvlc version.
+ *
+ * Example: "1.1.0-git The Luggage"
+ *
+ * \return a string containing the libvlc version
+ */
+LIBVLC_API const char * libvlc_get_version(void);
+
+/**
+ * Retrieve libvlc compiler version.
+ *
+ * Example: "gcc version 4.2.3 (Ubuntu 4.2.3-2ubuntu6)"
+ *
+ * \return a string containing the libvlc compiler version
+ */
+LIBVLC_API const char * libvlc_get_compiler(void);
+
+/**
+ * Retrieve libvlc changeset.
+ *
+ * Example: "aa9bce0bc4"
+ *
+ * \return a string containing the libvlc changeset
+ */
+LIBVLC_API const char * libvlc_get_changeset(void);
+
+/**
+ * Frees an heap allocation returned by a LibVLC function.
+ * If you know you're using the same underlying C run-time as the LibVLC
+ * implementation, then you can call ANSI C free() directly instead.
+ *
+ * \param ptr the pointer
+ */
+LIBVLC_API void libvlc_free( void *ptr );
+
+/** \defgroup libvlc_event LibVLC asynchronous events
+ * LibVLC emits asynchronous events.
+ *
+ * Several LibVLC objects (such @ref libvlc_instance_t as
+ * @ref libvlc_media_player_t) generate events asynchronously. Each of them
+ * provides @ref libvlc_event_manager_t event manager. You can subscribe to
+ * events with libvlc_event_attach() and unsubscribe with
+ * libvlc_event_detach().
+ * @{
+ */
+
+/**
+ * Event manager that belongs to a libvlc object, and from whom events can
+ * be received.
+ */
+typedef struct libvlc_event_manager_t libvlc_event_manager_t;
+
+struct libvlc_event_t;
+
+/**
+ * Type of a LibVLC event.
+ */
+typedef int libvlc_event_type_t;
+
+/**
+ * Callback function notification
+ * \param p_event the event triggering the callback
+ */
+typedef void ( *libvlc_callback_t )( const struct libvlc_event_t *, void * );
+
+/**
+ * Register for an event notification.
+ *
+ * \param p_event_manager the event manager to which you want to attach to.
+ *        Generally it is obtained by vlc_my_object_event_manager() where
+ *        my_object is the object you want to listen to.
+ * \param i_event_type the desired event to which we want to listen
+ * \param f_callback the function to call when i_event_type occurs
+ * \param user_data user provided data to carry with the event
+ * \return 0 on success, ENOMEM on error
+ */
+LIBVLC_API int libvlc_event_attach( libvlc_event_manager_t *p_event_manager,
+                                        libvlc_event_type_t i_event_type,
+                                        libvlc_callback_t f_callback,
+                                        void *user_data );
+
+/**
+ * Unregister an event notification.
+ *
+ * \param p_event_manager the event manager
+ * \param i_event_type the desired event to which we want to unregister
+ * \param f_callback the function to call when i_event_type occurs
+ * \param p_user_data user provided data to carry with the event
+ */
+LIBVLC_API void libvlc_event_detach( libvlc_event_manager_t *p_event_manager,
+                                         libvlc_event_type_t i_event_type,
+                                         libvlc_callback_t f_callback,
+                                         void *p_user_data );
+
+/**
+ * Get an event's type name.
+ *
+ * \param event_type the desired event
+ */
+LIBVLC_API const char * libvlc_event_type_name( libvlc_event_type_t event_type );
+
+/** @} */
+
+/** \defgroup libvlc_log LibVLC logging
+ * libvlc_log_* functions provide access to the LibVLC messages log.
+ * This is used for debugging or by advanced users.
+ * @{
+ */
+
+/**
+ * Always returns minus one.
+ * This function is only provided for backward compatibility.
+ *
+ * \param p_instance ignored
+ * \return always -1
+ */
+LIBVLC_DEPRECATED
+LIBVLC_API unsigned libvlc_get_log_verbosity( const libvlc_instance_t *p_instance );
+
+/**
+ * This function does nothing.
+ * It is only provided for backward compatibility.
+ *
+ * \param p_instance ignored
+ * \param level ignored
+ */
+LIBVLC_DEPRECATED
+LIBVLC_API void libvlc_set_log_verbosity( libvlc_instance_t *p_instance, unsigned level );
+
+/**
+ * This function does nothing useful.
+ * It is only provided for backward compatibility.
+ *
+ * \param p_instance libvlc instance
+ * \return an unique pointer or NULL on error
+ */
+LIBVLC_DEPRECATED
+LIBVLC_API libvlc_log_t *libvlc_log_open( libvlc_instance_t *p_instance );
+
+/**
+ * Frees memory allocated by libvlc_log_open().
+ *
+ * \param p_log libvlc log instance or NULL
+ */
+LIBVLC_DEPRECATED
+LIBVLC_API void libvlc_log_close( libvlc_log_t *p_log );
+
+/**
+ * Always returns zero.
+ * This function is only provided for backward compatibility.
+ *
+ * \param p_log ignored
+ * \return always zero
+ */
+LIBVLC_DEPRECATED
+LIBVLC_API unsigned libvlc_log_count( const libvlc_log_t *p_log );
+
+/**
+ * This function does nothing.
+ * It is only provided for backward compatibility.
+ *
+ * \param p_log ignored
+ */
+LIBVLC_DEPRECATED
+LIBVLC_API void libvlc_log_clear( libvlc_log_t *p_log );
+
+/**
+ * This function does nothing useful.
+ * It is only provided for backward compatibility.
+ *
+ * \param p_log ignored
+ * \return an unique pointer or NULL on error or if the parameter was NULL
+ */
+LIBVLC_DEPRECATED
+LIBVLC_API libvlc_log_iterator_t *libvlc_log_get_iterator( const libvlc_log_t *p_log );
+
+/**
+ * Frees memory allocated by libvlc_log_get_iterator().
+ *
+ * \param p_iter libvlc log iterator or NULL
+ */
+LIBVLC_DEPRECATED
+LIBVLC_API void libvlc_log_iterator_free( libvlc_log_iterator_t *p_iter );
+
+/**
+ * Always returns zero.
+ * This function is only provided for backward compatibility.
+ *
+ * \param p_iter ignored
+ * \return always zero
+ */
+LIBVLC_DEPRECATED
+LIBVLC_API int libvlc_log_iterator_has_next( const libvlc_log_iterator_t *p_iter );
+
+/**
+ * Always returns NULL.
+ * This function is only provided for backward compatibility.
+ *
+ * \param p_iter libvlc log iterator or NULL
+ * \param p_buffer ignored
+ * \return always NULL
+ */
+LIBVLC_DEPRECATED
+LIBVLC_API libvlc_log_message_t *libvlc_log_iterator_next( libvlc_log_iterator_t *p_iter,
+                                                           libvlc_log_message_t *p_buffer );
+
+/** @} */
+
+/**
+ * Description of a module.
+ */
+typedef struct libvlc_module_description_t
+{
+    char *psz_name;
+    char *psz_shortname;
+    char *psz_longname;
+    char *psz_help;
+    struct libvlc_module_description_t *p_next;
+} libvlc_module_description_t;
+
+/**
+ * Release a list of module descriptions.
+ *
+ * \param p_list the list to be released
+ */
+LIBVLC_API
+void libvlc_module_description_list_release( libvlc_module_description_t *p_list );
+
+/**
+ * Returns a list of audio filters that are available.
+ *
+ * \param p_instance libvlc instance
+ *
+ * \return a list of module descriptions. It should be freed with libvlc_module_description_list_release().
+ *         In case of an error, NULL is returned.
+ *
+ * \see libvlc_module_description_t
+ * \see libvlc_module_description_list_release
+ */
+LIBVLC_API
+libvlc_module_description_t *libvlc_audio_filter_list_get( libvlc_instance_t *p_instance );
+
+/**
+ * Returns a list of video filters that are available.
+ *
+ * \param p_instance libvlc instance
+ *
+ * \return a list of module descriptions. It should be freed with libvlc_module_description_list_release().
+ *         In case of an error, NULL is returned.
+ *
+ * \see libvlc_module_description_t
+ * \see libvlc_module_description_list_release
+ */
+LIBVLC_API
+libvlc_module_description_t *libvlc_video_filter_list_get( libvlc_instance_t *p_instance );
+
+/**Â @} */
+
+/** \defgroup libvlc_clock LibVLC time
+ * These functions provide access to the LibVLC time/clock.
+ * @{
+ */
+
+/**
+ * Return the current time as defined by LibVLC. The unit is the microsecond.
+ * Time increases monotonically (regardless of time zone changes and RTC
+ * adjustements).
+ * The origin is arbitrary but consistent across the whole system
+ * (e.g. the system uptim, the time since the system was booted).
+ * \note On systems that support it, the POSIX monotonic clock is used.
+ */
+LIBVLC_API
+int64_t libvlc_clock(void);
+
+/**
+ * Return the delay (in microseconds) until a certain timestamp.
+ * \param pts timestamp
+ * \return negative if timestamp is in the past,
+ * positive if it is in the future
+ */
+static inline int64_t libvlc_delay(int64_t pts)
+{
+    return pts - libvlc_clock();
+}
+
+/**Â @} */
+
+# ifdef __cplusplus
+}
+# endif
+
+#endif /* <vlc/libvlc.h> */

=== added file 'DivCity/DivCity/vlc/libvlc_events.h'
--- DivCity/DivCity/vlc/libvlc_events.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/libvlc_events.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,233 @@
+/*****************************************************************************
+ * libvlc_events.h:  libvlc_events external API structure
+ *****************************************************************************
+ * Copyright (C) 1998-2010 VLC authors and VideoLAN
+ * $Id $
+ *
+ * Authors: Filippo Carone <littlejohn@videolan.org>
+ *          Pierre d'Herbemont <pdherbemont@videolan.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef LIBVLC_EVENTS_H
+#define LIBVLC_EVENTS_H 1
+
+/**
+ * \file
+ * This file defines libvlc_event external API
+ */
+
+# ifdef __cplusplus
+extern "C" {
+# endif
+
+/**
+ * \ingroup libvlc_event
+ * @{
+ */
+
+/**
+ * Event types
+ */
+enum libvlc_event_e {
+    /* Append new event types at the end of a category.
+     * Do not remove, insert or re-order any entry.
+     * Keep this in sync with lib/event.c:libvlc_event_type_name(). */
+    libvlc_MediaMetaChanged=0,
+    libvlc_MediaSubItemAdded,
+    libvlc_MediaDurationChanged,
+    libvlc_MediaParsedChanged,
+    libvlc_MediaFreed,
+    libvlc_MediaStateChanged,
+
+    libvlc_MediaPlayerMediaChanged=0x100,
+    libvlc_MediaPlayerNothingSpecial,
+    libvlc_MediaPlayerOpening,
+    libvlc_MediaPlayerBuffering,
+    libvlc_MediaPlayerPlaying,
+    libvlc_MediaPlayerPaused,
+    libvlc_MediaPlayerStopped,
+    libvlc_MediaPlayerForward,
+    libvlc_MediaPlayerBackward,
+    libvlc_MediaPlayerEndReached,
+    libvlc_MediaPlayerEncounteredError,
+    libvlc_MediaPlayerTimeChanged,
+    libvlc_MediaPlayerPositionChanged,
+    libvlc_MediaPlayerSeekableChanged,
+    libvlc_MediaPlayerPausableChanged,
+    libvlc_MediaPlayerTitleChanged,
+    libvlc_MediaPlayerSnapshotTaken,
+    libvlc_MediaPlayerLengthChanged,
+    libvlc_MediaPlayerVout,
+
+    libvlc_MediaListItemAdded=0x200,
+    libvlc_MediaListWillAddItem,
+    libvlc_MediaListItemDeleted,
+    libvlc_MediaListWillDeleteItem,
+
+    libvlc_MediaListViewItemAdded=0x300,
+    libvlc_MediaListViewWillAddItem,
+    libvlc_MediaListViewItemDeleted,
+    libvlc_MediaListViewWillDeleteItem,
+
+    libvlc_MediaListPlayerPlayed=0x400,
+    libvlc_MediaListPlayerNextItemSet,
+    libvlc_MediaListPlayerStopped,
+
+    libvlc_MediaDiscovererStarted=0x500,
+    libvlc_MediaDiscovererEnded,
+
+    libvlc_VlmMediaAdded=0x600,
+    libvlc_VlmMediaRemoved,
+    libvlc_VlmMediaChanged,
+    libvlc_VlmMediaInstanceStarted,
+    libvlc_VlmMediaInstanceStopped,
+    libvlc_VlmMediaInstanceStatusInit,
+    libvlc_VlmMediaInstanceStatusOpening,
+    libvlc_VlmMediaInstanceStatusPlaying,
+    libvlc_VlmMediaInstanceStatusPause,
+    libvlc_VlmMediaInstanceStatusEnd,
+    libvlc_VlmMediaInstanceStatusError
+};
+
+/**
+ * A LibVLC event
+ */
+typedef struct libvlc_event_t
+{
+    int   type; /**< Event type (see @ref libvlc_event_e) */
+    void *p_obj; /**< Object emitting the event */
+    union
+    {
+        /* media descriptor */
+        struct
+        {
+            libvlc_meta_t meta_type;
+        } media_meta_changed;
+        struct
+        {
+            libvlc_media_t * new_child;
+        } media_subitem_added;
+        struct
+        {
+            int64_t new_duration;
+        } media_duration_changed;
+        struct
+        {
+            int new_status;
+        } media_parsed_changed;
+        struct
+        {
+            libvlc_media_t * md;
+        } media_freed;
+        struct
+        {
+            libvlc_state_t new_state;
+        } media_state_changed;
+
+        /* media instance */
+        struct
+        {
+            float new_cache;
+        } media_player_buffering;
+        struct
+        {
+            float new_position;
+        } media_player_position_changed;
+        struct
+        {
+            libvlc_time_t new_time;
+        } media_player_time_changed;
+        struct
+        {
+            int new_title;
+        } media_player_title_changed;
+        struct
+        {
+            int new_seekable;
+        } media_player_seekable_changed;
+        struct
+        {
+            int new_pausable;
+        } media_player_pausable_changed;
+        struct
+        {
+            int new_count;
+        } media_player_vout;
+
+        /* media list */
+        struct
+        {
+            libvlc_media_t * item;
+            int index;
+        } media_list_item_added;
+        struct
+        {
+            libvlc_media_t * item;
+            int index;
+        } media_list_will_add_item;
+        struct
+        {
+            libvlc_media_t * item;
+            int index;
+        } media_list_item_deleted;
+        struct
+        {
+            libvlc_media_t * item;
+            int index;
+        } media_list_will_delete_item;
+
+        /* media list player */
+        struct
+        {
+            libvlc_media_t * item;
+        } media_list_player_next_item_set;
+
+        /* snapshot taken */
+        struct
+        {
+             char* psz_filename ;
+        } media_player_snapshot_taken ;
+
+        /* Length changed */
+        struct
+        {
+            libvlc_time_t   new_length;
+        } media_player_length_changed;
+
+        /* VLM media */
+        struct
+        {
+            const char * psz_media_name;
+            const char * psz_instance_name;
+        } vlm_media_event;
+
+        /* Extra MediaPlayer */
+        struct
+        {
+            libvlc_media_t * new_media;
+        } media_player_media_changed;
+    } u; /**< Type-dependent event description */
+} libvlc_event_t;
+
+
+/**@} */
+
+# ifdef __cplusplus
+}
+# endif
+
+#endif /* _LIBVLC_EVENTS_H */

=== added file 'DivCity/DivCity/vlc/libvlc_media.h'
--- DivCity/DivCity/vlc/libvlc_media.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/libvlc_media.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,513 @@
+/*****************************************************************************
+ * libvlc.h:  libvlc external API
+ *****************************************************************************
+ * Copyright (C) 1998-2009 VLC authors and VideoLAN
+ * $Id: bce93c1afed56111c0fc33a1d0b451cfe653a7f3 $
+ *
+ * Authors: ClÃ©ment Stenac <zorglub@videolan.org>
+ *          Jean-Paul Saman <jpsaman@videolan.org>
+ *          Pierre d'Herbemont <pdherbemont@videolan.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+/**
+ * \file
+ * This file defines libvlc_media external API
+ */
+
+#ifndef VLC_LIBVLC_MEDIA_H
+#define VLC_LIBVLC_MEDIA_H 1
+
+# ifdef __cplusplus
+extern "C" {
+# endif
+
+/** \defgroup libvlc_media LibVLC media
+ * \ingroup libvlc
+ * @ref libvlc_media_t is an abstract representation of a playable media.
+ * It consists of a media location and various optional meta data.
+ * @{
+ */
+
+typedef struct libvlc_media_t libvlc_media_t;
+
+/** defgroup libvlc_meta LibVLC meta data
+ * \ingroup libvlc_media
+ * @{
+ */
+
+/** Meta data types */
+typedef enum libvlc_meta_t {
+    libvlc_meta_Title,
+    libvlc_meta_Artist,
+    libvlc_meta_Genre,
+    libvlc_meta_Copyright,
+    libvlc_meta_Album,
+    libvlc_meta_TrackNumber,
+    libvlc_meta_Description,
+    libvlc_meta_Rating,
+    libvlc_meta_Date,
+    libvlc_meta_Setting,
+    libvlc_meta_URL,
+    libvlc_meta_Language,
+    libvlc_meta_NowPlaying,
+    libvlc_meta_Publisher,
+    libvlc_meta_EncodedBy,
+    libvlc_meta_ArtworkURL,
+    libvlc_meta_TrackID
+    /* Add new meta types HERE */
+} libvlc_meta_t;
+
+/** @}*/
+
+/**
+ * Note the order of libvlc_state_t enum must match exactly the order of
+ * \see mediacontrol_PlayerStatus, \see input_state_e enums,
+ * and VideoLAN.LibVLC.State (at bindings/cil/src/media.cs).
+ *
+ * Expected states by web plugins are:
+ * IDLE/CLOSE=0, OPENING=1, BUFFERING=2, PLAYING=3, PAUSED=4,
+ * STOPPING=5, ENDED=6, ERROR=7
+ */
+typedef enum libvlc_state_t
+{
+    libvlc_NothingSpecial=0,
+    libvlc_Opening,
+    libvlc_Buffering,
+    libvlc_Playing,
+    libvlc_Paused,
+    libvlc_Stopped,
+    libvlc_Ended,
+    libvlc_Error
+} libvlc_state_t;
+
+enum
+{
+    libvlc_media_option_trusted = 0x2,
+    libvlc_media_option_unique = 0x100
+};
+
+typedef enum libvlc_track_type_t
+{
+    libvlc_track_unknown   = -1,
+    libvlc_track_audio     = 0,
+    libvlc_track_video     = 1,
+    libvlc_track_text      = 2
+} libvlc_track_type_t;
+
+/** defgroup libvlc_media_stats_t LibVLC media statistics
+ * \ingroup libvlc_media
+ * @{
+ */
+typedef struct libvlc_media_stats_t
+{
+    /* Input */
+    int         i_read_bytes;
+    float       f_input_bitrate;
+
+    /* Demux */
+    int         i_demux_read_bytes;
+    float       f_demux_bitrate;
+    int         i_demux_corrupted;
+    int         i_demux_discontinuity;
+
+    /* Decoders */
+    int         i_decoded_video;
+    int         i_decoded_audio;
+
+    /* Video Output */
+    int         i_displayed_pictures;
+    int         i_lost_pictures;
+
+    /* Audio output */
+    int         i_played_abuffers;
+    int         i_lost_abuffers;
+
+    /* Stream output */
+    int         i_sent_packets;
+    int         i_sent_bytes;
+    float       f_send_bitrate;
+} libvlc_media_stats_t;
+/** @}*/
+
+typedef struct libvlc_media_track_info_t
+{
+    /* Codec fourcc */
+    uint32_t    i_codec;
+    int         i_id;
+    libvlc_track_type_t i_type;
+
+    /* Codec specific */
+    int         i_profile;
+    int         i_level;
+
+    union {
+        struct {
+            /* Audio specific */
+            unsigned    i_channels;
+            unsigned    i_rate;
+        } audio;
+        struct {
+            /* Video specific */
+            unsigned    i_height;
+            unsigned    i_width;
+        } video;
+    } u;
+
+} libvlc_media_track_info_t;
+
+
+/**
+ * Create a media with a certain given media resource location,
+ * for instance a valid URL.
+ *
+ * \note To refer to a local file with this function,
+ * the file://... URI syntax <b>must</b> be used (see IETF RFC3986).
+ * We recommend using libvlc_media_new_path() instead when dealing with
+ * local files.
+ *
+ * \see libvlc_media_release
+ *
+ * \param p_instance the instance
+ * \param psz_mrl the media location
+ * \return the newly created media or NULL on error
+ */
+LIBVLC_API libvlc_media_t *libvlc_media_new_location(
+                                   libvlc_instance_t *p_instance,
+                                   const char * psz_mrl );
+
+/**
+ * Create a media for a certain file path.
+ *
+ * \see libvlc_media_release
+ *
+ * \param p_instance the instance
+ * \param path local filesystem path
+ * \return the newly created media or NULL on error
+ */
+LIBVLC_API libvlc_media_t *libvlc_media_new_path(
+                                   libvlc_instance_t *p_instance,
+                                   const char *path );
+
+/**
+ * Create a media for an already open file descriptor.
+ * The file descriptor shall be open for reading (or reading and writing).
+ *
+ * Regular file descriptors, pipe read descriptors and character device
+ * descriptors (including TTYs) are supported on all platforms.
+ * Block device descriptors are supported where available.
+ * Directory descriptors are supported on systems that provide fdopendir().
+ * Sockets are supported on all platforms where they are file descriptors,
+ * i.e. all except Windows.
+ *
+ * \note This library will <b>not</b> automatically close the file descriptor
+ * under any circumstance. Nevertheless, a file descriptor can usually only be
+ * rendered once in a media player. To render it a second time, the file
+ * descriptor should probably be rewound to the beginning with lseek().
+ *
+ * \see libvlc_media_release
+ *
+ * \version LibVLC 1.1.5 and later.
+ *
+ * \param p_instance the instance
+ * \param fd open file descriptor
+ * \return the newly created media or NULL on error
+ */
+LIBVLC_API libvlc_media_t *libvlc_media_new_fd(
+                                   libvlc_instance_t *p_instance,
+                                   int fd );
+
+
+/**
+ * Create a media as an empty node with a given name.
+ *
+ * \see libvlc_media_release
+ *
+ * \param p_instance the instance
+ * \param psz_name the name of the node
+ * \return the new empty media or NULL on error
+ */
+LIBVLC_API libvlc_media_t *libvlc_media_new_as_node(
+                                   libvlc_instance_t *p_instance,
+                                   const char * psz_name );
+
+/**
+ * Add an option to the media.
+ *
+ * This option will be used to determine how the media_player will
+ * read the media. This allows to use VLC's advanced
+ * reading/streaming options on a per-media basis.
+ *
+ * The options are detailed in vlc --long-help, for instance "--sout-all"
+ *
+ * \param p_md the media descriptor
+ * \param ppsz_options the options (as a string)
+ */
+LIBVLC_API void libvlc_media_add_option(
+                                   libvlc_media_t *p_md,
+                                   const char * ppsz_options );
+
+/**
+ * Add an option to the media with configurable flags.
+ *
+ * This option will be used to determine how the media_player will
+ * read the media. This allows to use VLC's advanced
+ * reading/streaming options on a per-media basis.
+ *
+ * The options are detailed in vlc --long-help, for instance "--sout-all"
+ *
+ * \param p_md the media descriptor
+ * \param ppsz_options the options (as a string)
+ * \param i_flags the flags for this option
+ */
+LIBVLC_API void libvlc_media_add_option_flag(
+                                   libvlc_media_t *p_md,
+                                   const char * ppsz_options,
+                                   unsigned i_flags );
+
+
+/**
+ * Retain a reference to a media descriptor object (libvlc_media_t). Use
+ * libvlc_media_release() to decrement the reference count of a
+ * media descriptor object.
+ *
+ * \param p_md the media descriptor
+ */
+LIBVLC_API void libvlc_media_retain( libvlc_media_t *p_md );
+
+/**
+ * Decrement the reference count of a media descriptor object. If the
+ * reference count is 0, then libvlc_media_release() will release the
+ * media descriptor object. It will send out an libvlc_MediaFreed event
+ * to all listeners. If the media descriptor object has been released it
+ * should not be used again.
+ *
+ * \param p_md the media descriptor
+ */
+LIBVLC_API void libvlc_media_release( libvlc_media_t *p_md );
+
+
+/**
+ * Get the media resource locator (mrl) from a media descriptor object
+ *
+ * \param p_md a media descriptor object
+ * \return string with mrl of media descriptor object
+ */
+LIBVLC_API char *libvlc_media_get_mrl( libvlc_media_t *p_md );
+
+/**
+ * Duplicate a media descriptor object.
+ *
+ * \param p_md a media descriptor object.
+ */
+LIBVLC_API libvlc_media_t *libvlc_media_duplicate( libvlc_media_t *p_md );
+
+/**
+ * Read the meta of the media.
+ *
+ * If the media has not yet been parsed this will return NULL.
+ *
+ * This methods automatically calls libvlc_media_parse_async(), so after calling
+ * it you may receive a libvlc_MediaMetaChanged event. If you prefer a synchronous
+ * version ensure that you call libvlc_media_parse() before get_meta().
+ *
+ * \see libvlc_media_parse
+ * \see libvlc_media_parse_async
+ * \see libvlc_MediaMetaChanged
+ *
+ * \param p_md the media descriptor
+ * \param e_meta the meta to read
+ * \return the media's meta
+ */
+LIBVLC_API char *libvlc_media_get_meta( libvlc_media_t *p_md,
+                                             libvlc_meta_t e_meta );
+
+/**
+ * Set the meta of the media (this function will not save the meta, call
+ * libvlc_media_save_meta in order to save the meta)
+ *
+ * \param p_md the media descriptor
+ * \param e_meta the meta to write
+ * \param psz_value the media's meta
+ */
+LIBVLC_API void libvlc_media_set_meta( libvlc_media_t *p_md,
+                                           libvlc_meta_t e_meta,
+                                           const char *psz_value );
+
+
+/**
+ * Save the meta previously set
+ *
+ * \param p_md the media desriptor
+ * \return true if the write operation was successfull
+ */
+LIBVLC_API int libvlc_media_save_meta( libvlc_media_t *p_md );
+
+
+/**
+ * Get current state of media descriptor object. Possible media states
+ * are defined in libvlc_structures.c ( libvlc_NothingSpecial=0,
+ * libvlc_Opening, libvlc_Buffering, libvlc_Playing, libvlc_Paused,
+ * libvlc_Stopped, libvlc_Ended,
+ * libvlc_Error).
+ *
+ * \see libvlc_state_t
+ * \param p_md a media descriptor object
+ * \return state of media descriptor object
+ */
+LIBVLC_API libvlc_state_t libvlc_media_get_state(
+                                   libvlc_media_t *p_md );
+
+
+/**
+ * Get the current statistics about the media
+ * \param p_md: media descriptor object
+ * \param p_stats: structure that contain the statistics about the media
+ *                 (this structure must be allocated by the caller)
+ * \return true if the statistics are available, false otherwise
+ *
+ * \libvlc_return_bool
+ */
+LIBVLC_API int libvlc_media_get_stats( libvlc_media_t *p_md,
+                                           libvlc_media_stats_t *p_stats );
+
+/**
+ * Get subitems of media descriptor object. This will increment
+ * the reference count of supplied media descriptor object. Use
+ * libvlc_media_list_release() to decrement the reference counting.
+ *
+ * \param p_md media descriptor object
+ * \return list of media descriptor subitems or NULL
+ */
+
+/* This method uses libvlc_media_list_t, however, media_list usage is optionnal
+ * and this is here for convenience */
+#define VLC_FORWARD_DECLARE_OBJECT(a) struct a
+
+LIBVLC_API VLC_FORWARD_DECLARE_OBJECT(libvlc_media_list_t *)
+libvlc_media_subitems( libvlc_media_t *p_md );
+
+/**
+ * Get event manager from media descriptor object.
+ * NOTE: this function doesn't increment reference counting.
+ *
+ * \param p_md a media descriptor object
+ * \return event manager object
+ */
+LIBVLC_API libvlc_event_manager_t *
+    libvlc_media_event_manager( libvlc_media_t *p_md );
+
+/**
+ * Get duration (in ms) of media descriptor object item.
+ *
+ * \param p_md media descriptor object
+ * \return duration of media item or -1 on error
+ */
+LIBVLC_API libvlc_time_t
+   libvlc_media_get_duration( libvlc_media_t *p_md );
+
+/**
+ * Parse a media.
+ *
+ * This fetches (local) meta data and tracks information.
+ * The method is synchronous.
+ *
+ * \see libvlc_media_parse_async
+ * \see libvlc_media_get_meta
+ * \see libvlc_media_get_tracks_info
+ *
+ * \param p_md media descriptor object
+ */
+LIBVLC_API void
+libvlc_media_parse( libvlc_media_t *p_md );
+
+/**
+ * Parse a media.
+ *
+ * This fetches (local) meta data and tracks information.
+ * The method is the asynchronous of libvlc_media_parse().
+ *
+ * To track when this is over you can listen to libvlc_MediaParsedChanged
+ * event. However if the media was already parsed you will not receive this
+ * event.
+ *
+ * \see libvlc_media_parse
+ * \see libvlc_MediaParsedChanged
+ * \see libvlc_media_get_meta
+ * \see libvlc_media_get_tracks_info
+ *
+ * \param p_md media descriptor object
+ */
+LIBVLC_API void
+libvlc_media_parse_async( libvlc_media_t *p_md );
+
+/**
+ * Get Parsed status for media descriptor object.
+ *
+ * \see libvlc_MediaParsedChanged
+ *
+ * \param p_md media descriptor object
+ * \return true if media object has been parsed otherwise it returns false
+ *
+ * \libvlc_return_bool
+ */
+LIBVLC_API int
+   libvlc_media_is_parsed( libvlc_media_t *p_md );
+
+/**
+ * Sets media descriptor's user_data. user_data is specialized data
+ * accessed by the host application, VLC.framework uses it as a pointer to
+ * an native object that references a libvlc_media_t pointer
+ *
+ * \param p_md media descriptor object
+ * \param p_new_user_data pointer to user data
+ */
+LIBVLC_API void
+    libvlc_media_set_user_data( libvlc_media_t *p_md, void *p_new_user_data );
+
+/**
+ * Get media descriptor's user_data. user_data is specialized data
+ * accessed by the host application, VLC.framework uses it as a pointer to
+ * an native object that references a libvlc_media_t pointer
+ *
+ * \param p_md media descriptor object
+ */
+LIBVLC_API void *libvlc_media_get_user_data( libvlc_media_t *p_md );
+
+/**
+ * Get media descriptor's elementary streams description
+ *
+ * Note, you need to call libvlc_media_parse() or play the media at least once
+ * before calling this function.
+ * Not doing this will result in an empty array.
+ *
+ * \param p_md media descriptor object
+ * \param tracks address to store an allocated array of Elementary Streams
+ * descriptions (must be freed by the caller)
+ *
+ * \return the number of Elementary Streams
+ */
+LIBVLC_API
+int libvlc_media_get_tracks_info( libvlc_media_t *p_md,
+                                  libvlc_media_track_info_t **tracks );
+
+/** @}*/
+
+# ifdef __cplusplus
+}
+# endif
+
+#endif /* VLC_LIBVLC_MEDIA_H */

=== added file 'DivCity/DivCity/vlc/libvlc_media_discoverer.h'
--- DivCity/DivCity/vlc/libvlc_media_discoverer.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/libvlc_media_discoverer.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,111 @@
+/*****************************************************************************
+ * libvlc.h:  libvlc external API
+ *****************************************************************************
+ * Copyright (C) 1998-2009 VLC authors and VideoLAN
+ * $Id: 45f3e9a3af409fb00b887b96f6609805465d1062 $
+ *
+ * Authors: ClÃ©ment Stenac <zorglub@videolan.org>
+ *          Jean-Paul Saman <jpsaman@videolan.org>
+ *          Pierre d'Herbemont <pdherbemont@videolan.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+/**
+ * \file
+ * This file defines libvlc_media_discoverer external API
+ */
+
+#ifndef VLC_LIBVLC_MEDIA_DISCOVERER_H
+#define VLC_LIBVLC_MEDIA_DISCOVERER_H 1
+
+# ifdef __cplusplus
+extern "C" {
+# endif
+
+/** \defgroup libvlc_media_discoverer LibVLC media discovery
+ * \ingroup libvlc
+ * LibVLC media discovery finds available media via various means.
+ * This corresponds to the service discovery functionality in VLC media player.
+ * Different plugins find potential medias locally (e.g. user media directory),
+ * from peripherals (e.g. video capture device), on the local network
+ * (e.g. SAP) or on the Internet (e.g. Internet radios).
+ * @{
+ */
+
+typedef struct libvlc_media_discoverer_t libvlc_media_discoverer_t;
+
+/**
+ * Discover media service by name.
+ *
+ * \param p_inst libvlc instance
+ * \param psz_name service name
+ * \return media discover object or NULL in case of error
+ */
+LIBVLC_API libvlc_media_discoverer_t *
+libvlc_media_discoverer_new_from_name( libvlc_instance_t * p_inst,
+                                       const char * psz_name );
+
+/**
+ * Release media discover object. If the reference count reaches 0, then
+ * the object will be released.
+ *
+ * \param p_mdis media service discover object
+ */
+LIBVLC_API void   libvlc_media_discoverer_release( libvlc_media_discoverer_t * p_mdis );
+
+/**
+ * Get media service discover object its localized name.
+ *
+ * \param p_mdis media discover object
+ * \return localized name
+ */
+LIBVLC_API char * libvlc_media_discoverer_localized_name( libvlc_media_discoverer_t * p_mdis );
+
+/**
+ * Get media service discover media list.
+ *
+ * \param p_mdis media service discover object
+ * \return list of media items
+ */
+LIBVLC_API libvlc_media_list_t * libvlc_media_discoverer_media_list( libvlc_media_discoverer_t * p_mdis );
+
+/**
+ * Get event manager from media service discover object.
+ *
+ * \param p_mdis media service discover object
+ * \return event manager object.
+ */
+LIBVLC_API libvlc_event_manager_t *
+        libvlc_media_discoverer_event_manager( libvlc_media_discoverer_t * p_mdis );
+
+/**
+ * Query if media service discover object is running.
+ *
+ * \param p_mdis media service discover object
+ * \return true if running, false if not
+ *
+ * \libvlc_return_bool
+ */
+LIBVLC_API int
+        libvlc_media_discoverer_is_running( libvlc_media_discoverer_t * p_mdis );
+
+/**@} */
+
+# ifdef __cplusplus
+}
+# endif
+
+#endif /* <vlc/libvlc.h> */

=== added file 'DivCity/DivCity/vlc/libvlc_media_library.h'
--- DivCity/DivCity/vlc/libvlc_media_library.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/libvlc_media_library.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,99 @@
+/*****************************************************************************
+ * libvlc.h:  libvlc external API
+ *****************************************************************************
+ * Copyright (C) 1998-2009 VLC authors and VideoLAN
+ * $Id: b9a8153ac58186260481e99c8a6b5b5a84e06d9b $
+ *
+ * Authors: ClÃ©ment Stenac <zorglub@videolan.org>
+ *          Jean-Paul Saman <jpsaman@videolan.org>
+ *          Pierre d'Herbemont <pdherbemont@videolan.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+/**
+ * \file
+ * This file defines libvlc_media_library external API
+ */
+
+#ifndef VLC_LIBVLC_MEDIA_LIBRARY_H
+#define VLC_LIBVLC_MEDIA_LIBRARY_H 1
+
+# ifdef __cplusplus
+extern "C" {
+# endif
+
+/** \defgroup libvlc_media_library LibVLC media library
+ * \ingroup libvlc
+ * @{
+ */
+
+typedef struct libvlc_media_library_t libvlc_media_library_t;
+
+/**
+ * Create an new Media Library object
+ *
+ * \param p_instance the libvlc instance
+ * \return a new object or NULL on error
+ */
+LIBVLC_API libvlc_media_library_t *
+    libvlc_media_library_new( libvlc_instance_t * p_instance );
+
+/**
+ * Release media library object. This functions decrements the
+ * reference count of the media library object. If it reaches 0,
+ * then the object will be released.
+ *
+ * \param p_mlib media library object
+ */
+LIBVLC_API void
+    libvlc_media_library_release( libvlc_media_library_t * p_mlib );
+
+/**
+ * Retain a reference to a media library object. This function will
+ * increment the reference counting for this object. Use
+ * libvlc_media_library_release() to decrement the reference count.
+ *
+ * \param p_mlib media library object
+ */
+LIBVLC_API void
+    libvlc_media_library_retain( libvlc_media_library_t * p_mlib );
+
+/**
+ * Load media library.
+ *
+ * \param p_mlib media library object
+ * \return 0 on success, -1 on error
+ */
+LIBVLC_API int
+    libvlc_media_library_load( libvlc_media_library_t * p_mlib );
+
+/**
+ * Get media library subitems.
+ *
+ * \param p_mlib media library object
+ * \return media list subitems
+ */
+LIBVLC_API libvlc_media_list_t *
+    libvlc_media_library_media_list( libvlc_media_library_t * p_mlib );
+
+
+/** @} */
+
+# ifdef __cplusplus
+}
+# endif
+
+#endif /* VLC_LIBVLC_MEDIA_LIBRARY_H */

=== added file 'DivCity/DivCity/vlc/libvlc_media_list.h'
--- DivCity/DivCity/vlc/libvlc_media_list.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/libvlc_media_list.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,209 @@
+/*****************************************************************************
+ * libvlc_media_list.h:  libvlc_media_list API
+ *****************************************************************************
+ * Copyright (C) 1998-2008 VLC authors and VideoLAN
+ * $Id: 015824bf54e656cc67838452c7e99a00a452af6e $
+ *
+ * Authors: Pierre d'Herbemont
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef LIBVLC_MEDIA_LIST_H
+#define LIBVLC_MEDIA_LIST_H 1
+
+/**
+ * \file
+ * This file defines libvlc_media_list API
+ */
+
+# ifdef __cplusplus
+extern "C" {
+# endif
+
+/** \defgroup libvlc_media_list LibVLC media list
+ * \ingroup libvlc
+ * A LibVLC media list holds multiple @ref libvlc_media_t media descriptors.
+ * @{
+ */
+
+typedef struct libvlc_media_list_t libvlc_media_list_t;
+
+/**
+ * Create an empty media list.
+ *
+ * \param p_instance libvlc instance
+ * \return empty media list, or NULL on error
+ */
+LIBVLC_API libvlc_media_list_t *
+    libvlc_media_list_new( libvlc_instance_t *p_instance );
+
+/**
+ * Release media list created with libvlc_media_list_new().
+ *
+ * \param p_ml a media list created with libvlc_media_list_new()
+ */
+LIBVLC_API void
+    libvlc_media_list_release( libvlc_media_list_t *p_ml );
+
+/**
+ * Retain reference to a media list
+ *
+ * \param p_ml a media list created with libvlc_media_list_new()
+ */
+LIBVLC_API void
+    libvlc_media_list_retain( libvlc_media_list_t *p_ml );
+
+LIBVLC_DEPRECATED int
+    libvlc_media_list_add_file_content( libvlc_media_list_t * p_ml,
+                                        const char * psz_uri );
+
+/**
+ * Associate media instance with this media list instance.
+ * If another media instance was present it will be released.
+ * The libvlc_media_list_lock should NOT be held upon entering this function.
+ *
+ * \param p_ml a media list instance
+ * \param p_md media instance to add
+ */
+LIBVLC_API void
+libvlc_media_list_set_media( libvlc_media_list_t *p_ml, libvlc_media_t *p_md );
+
+/**
+ * Get media instance from this media list instance. This action will increase
+ * the refcount on the media instance.
+ * The libvlc_media_list_lock should NOT be held upon entering this function.
+ *
+ * \param p_ml a media list instance
+ * \return media instance
+ */
+LIBVLC_API libvlc_media_t *
+    libvlc_media_list_media( libvlc_media_list_t *p_ml );
+
+/**
+ * Add media instance to media list
+ * The libvlc_media_list_lock should be held upon entering this function.
+ *
+ * \param p_ml a media list instance
+ * \param p_md a media instance
+ * \return 0 on success, -1 if the media list is read-only
+ */
+LIBVLC_API int
+libvlc_media_list_add_media( libvlc_media_list_t *p_ml, libvlc_media_t *p_md );
+
+/**
+ * Insert media instance in media list on a position
+ * The libvlc_media_list_lock should be held upon entering this function.
+ *
+ * \param p_ml a media list instance
+ * \param p_md a media instance
+ * \param i_pos position in array where to insert
+ * \return 0 on success, -1 if the media list is read-only
+ */
+LIBVLC_API int
+libvlc_media_list_insert_media( libvlc_media_list_t *p_ml,
+                                libvlc_media_t *p_md, int i_pos );
+
+/**
+ * Remove media instance from media list on a position
+ * The libvlc_media_list_lock should be held upon entering this function.
+ *
+ * \param p_ml a media list instance
+ * \param i_pos position in array where to insert
+ * \return 0 on success, -1 if the list is read-only or the item was not found
+ */
+LIBVLC_API int
+libvlc_media_list_remove_index( libvlc_media_list_t *p_ml, int i_pos );
+
+/**
+ * Get count on media list items
+ * The libvlc_media_list_lock should be held upon entering this function.
+ *
+ * \param p_ml a media list instance
+ * \return number of items in media list
+ */
+LIBVLC_API int
+    libvlc_media_list_count( libvlc_media_list_t *p_ml );
+
+/**
+ * List media instance in media list at a position
+ * The libvlc_media_list_lock should be held upon entering this function.
+ *
+ * \param p_ml a media list instance
+ * \param i_pos position in array where to insert
+ * \return media instance at position i_pos, or NULL if not found.
+ * In case of success, libvlc_media_retain() is called to increase the refcount
+ * on the media.
+ */
+LIBVLC_API libvlc_media_t *
+    libvlc_media_list_item_at_index( libvlc_media_list_t *p_ml, int i_pos );
+/**
+ * Find index position of List media instance in media list.
+ * Warning: the function will return the first matched position.
+ * The libvlc_media_list_lock should be held upon entering this function.
+ *
+ * \param p_ml a media list instance
+ * \param p_md media instance
+ * \return position of media instance or -1 if media not found
+ */
+LIBVLC_API int
+    libvlc_media_list_index_of_item( libvlc_media_list_t *p_ml,
+                                     libvlc_media_t *p_md );
+
+/**
+ * This indicates if this media list is read-only from a user point of view
+ *
+ * \param p_ml media list instance
+ * \return 1 on readonly, 0 on readwrite
+ *
+ * \libvlc_return_bool
+ */
+LIBVLC_API int
+    libvlc_media_list_is_readonly( libvlc_media_list_t * p_ml );
+
+/**
+ * Get lock on media list items
+ *
+ * \param p_ml a media list instance
+ */
+LIBVLC_API void
+    libvlc_media_list_lock( libvlc_media_list_t *p_ml );
+
+/**
+ * Release lock on media list items
+ * The libvlc_media_list_lock should be held upon entering this function.
+ *
+ * \param p_ml a media list instance
+ */
+LIBVLC_API void
+    libvlc_media_list_unlock( libvlc_media_list_t *p_ml );
+
+/**
+ * Get libvlc_event_manager from this media list instance.
+ * The p_event_manager is immutable, so you don't have to hold the lock
+ *
+ * \param p_ml a media list instance
+ * \return libvlc_event_manager
+ */
+LIBVLC_API libvlc_event_manager_t *
+    libvlc_media_list_event_manager( libvlc_media_list_t *p_ml );
+
+/** @} media_list */
+
+# ifdef __cplusplus
+}
+# endif
+
+#endif /* _LIBVLC_MEDIA_LIST_H */

=== added file 'DivCity/DivCity/vlc/libvlc_media_list_player.h'
--- DivCity/DivCity/vlc/libvlc_media_list_player.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/libvlc_media_list_player.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,224 @@
+/*****************************************************************************
+ * libvlc_media_list.h:  libvlc_media_list API
+ *****************************************************************************
+ * Copyright (C) 1998-2008 VLC authors and VideoLAN
+ * $Id: c037843c15177eebd12053c0a21118afa8333e06 $
+ *
+ * Authors: Pierre d'Herbemont
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef LIBVLC_MEDIA_LIST_PLAYER_H
+#define LIBVLC_MEDIA_LIST_PLAYER_H 1
+
+/**
+ * \file
+ * This file defines libvlc_media_list_player API
+ */
+
+# ifdef __cplusplus
+extern "C" {
+# endif
+
+/*****************************************************************************
+ * Media List Player
+ *****************************************************************************/
+/** \defgroup libvlc_media_list_player LibVLC media list player
+ * \ingroup libvlc
+ * The LibVLC media list player plays a @ref libvlc_media_list_t list of media,
+ * in a certain order.
+ * This is required to especially support playlist files.
+ * The normal @ref libvlc_media_player_t LibVLC media player can only play a
+ * single media, and does not handle playlist files properly.
+ * @{
+ */
+
+typedef struct libvlc_media_list_player_t libvlc_media_list_player_t;
+
+/**
+ *  Defines playback modes for playlist.
+ */
+typedef enum libvlc_playback_mode_t
+{
+    libvlc_playback_mode_default,
+    libvlc_playback_mode_loop,
+    libvlc_playback_mode_repeat
+} libvlc_playback_mode_t;
+
+/**
+ * Create new media_list_player.
+ *
+ * \param p_instance libvlc instance
+ * \return media list player instance or NULL on error
+ */
+LIBVLC_API libvlc_media_list_player_t *
+    libvlc_media_list_player_new( libvlc_instance_t * p_instance );
+
+/**
+ * Release a media_list_player after use
+ * Decrement the reference count of a media player object. If the
+ * reference count is 0, then libvlc_media_list_player_release() will
+ * release the media player object. If the media player object
+ * has been released, then it should not be used again.
+ *
+ * \param p_mlp media list player instance
+ */
+LIBVLC_API void
+    libvlc_media_list_player_release( libvlc_media_list_player_t * p_mlp );
+
+/**
+ * Retain a reference to a media player list object. Use
+ * libvlc_media_list_player_release() to decrement reference count.
+ *
+ * \param p_mlp media player list object
+ */
+LIBVLC_API void
+    libvlc_media_list_player_retain( libvlc_media_list_player_t *p_mlp );
+
+/**
+ * Return the event manager of this media_list_player.
+ *
+ * \param p_mlp media list player instance
+ * \return the event manager
+ */
+LIBVLC_API libvlc_event_manager_t *
+    libvlc_media_list_player_event_manager(libvlc_media_list_player_t * p_mlp);
+
+/**
+ * Replace media player in media_list_player with this instance.
+ *
+ * \param p_mlp media list player instance
+ * \param p_mi media player instance
+ */
+LIBVLC_API void
+    libvlc_media_list_player_set_media_player(
+                                     libvlc_media_list_player_t * p_mlp,
+                                     libvlc_media_player_t * p_mi );
+
+/**
+ * Set the media list associated with the player
+ *
+ * \param p_mlp media list player instance
+ * \param p_mlist list of media
+ */
+LIBVLC_API void
+    libvlc_media_list_player_set_media_list(
+                                     libvlc_media_list_player_t * p_mlp,
+                                     libvlc_media_list_t * p_mlist );
+
+/**
+ * Play media list
+ *
+ * \param p_mlp media list player instance
+ */
+LIBVLC_API
+void libvlc_media_list_player_play(libvlc_media_list_player_t * p_mlp);
+
+/**
+ * Pause media list
+ *
+ * \param p_mlp media list player instance
+ */
+LIBVLC_API
+void libvlc_media_list_player_pause(libvlc_media_list_player_t * p_mlp);
+
+/**
+ * Is media list playing?
+ *
+ * \param p_mlp media list player instance
+ * \return true for playing and false for not playing
+ *
+ * \libvlc_return_bool
+ */
+LIBVLC_API int
+    libvlc_media_list_player_is_playing( libvlc_media_list_player_t * p_mlp );
+
+/**
+ * Get current libvlc_state of media list player
+ *
+ * \param p_mlp media list player instance
+ * \return libvlc_state_t for media list player
+ */
+LIBVLC_API libvlc_state_t
+    libvlc_media_list_player_get_state( libvlc_media_list_player_t * p_mlp );
+
+/**
+ * Play media list item at position index
+ *
+ * \param p_mlp media list player instance
+ * \param i_index index in media list to play
+ * \return 0 upon success -1 if the item wasn't found
+ */
+LIBVLC_API
+int libvlc_media_list_player_play_item_at_index(libvlc_media_list_player_t * p_mlp,
+                                                int i_index);
+
+/**
+ * Play the given media item
+ *
+ * \param p_mlp media list player instance
+ * \param p_md the media instance
+ * \return 0 upon success, -1 if the media is not part of the media list
+ */
+LIBVLC_API
+int libvlc_media_list_player_play_item(libvlc_media_list_player_t * p_mlp,
+                                       libvlc_media_t * p_md);
+
+/**
+ * Stop playing media list
+ *
+ * \param p_mlp media list player instance
+ */
+LIBVLC_API void
+    libvlc_media_list_player_stop( libvlc_media_list_player_t * p_mlp);
+
+/**
+ * Play next item from media list
+ *
+ * \param p_mlp media list player instance
+ * \return 0 upon success -1 if there is no next item
+ */
+LIBVLC_API
+int libvlc_media_list_player_next(libvlc_media_list_player_t * p_mlp);
+
+/**
+ * Play previous item from media list
+ *
+ * \param p_mlp media list player instance
+ * \return 0 upon success -1 if there is no previous item
+ */
+LIBVLC_API
+int libvlc_media_list_player_previous(libvlc_media_list_player_t * p_mlp);
+
+
+
+/**
+ * Sets the playback mode for the playlist
+ *
+ * \param p_mlp media list player instance
+ * \param e_mode playback mode specification
+ */
+LIBVLC_API
+void libvlc_media_list_player_set_playback_mode(libvlc_media_list_player_t * p_mlp,
+                                                libvlc_playback_mode_t e_mode );
+
+/** @} media_list_player */
+
+# ifdef __cplusplus
+}
+# endif
+
+#endif /* LIBVLC_MEDIA_LIST_PLAYER_H */

=== added file 'DivCity/DivCity/vlc/libvlc_media_player.h'
--- DivCity/DivCity/vlc/libvlc_media_player.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/libvlc_media_player.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,1581 @@
+/*****************************************************************************
+ * libvlc_media_player.h:  libvlc_media_player external API
+ *****************************************************************************
+ * Copyright (C) 1998-2010 VLC authors and VideoLAN
+ * $Id: cc575218a9341d3f8371cff1c2e0e3440edca9f2 $
+ *
+ * Authors: ClÃ©ment Stenac <zorglub@videolan.org>
+ *          Jean-Paul Saman <jpsaman@videolan.org>
+ *          Pierre d'Herbemont <pdherbemont@videolan.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+/**
+ * \file
+ * This file defines libvlc_media_player external API
+ */
+
+#ifndef VLC_LIBVLC_MEDIA_PLAYER_H
+#define VLC_LIBVLC_MEDIA_PLAYER_H 1
+
+# ifdef __cplusplus
+extern "C" {
+# else
+#  include <stdbool.h>
+# endif
+
+/*****************************************************************************
+ * Media Player
+ *****************************************************************************/
+/** \defgroup libvlc_media_player LibVLC media player
+ * \ingroup libvlc
+ * A LibVLC media player plays one media (usually in a custom drawable).
+ * @{
+ */
+
+typedef struct libvlc_media_player_t libvlc_media_player_t;
+
+/**
+ * Description for video, audio tracks and subtitles. It contains
+ * id, name (description string) and pointer to next record.
+ */
+typedef struct libvlc_track_description_t
+{
+    int   i_id;
+    char *psz_name;
+    struct libvlc_track_description_t *p_next;
+
+} libvlc_track_description_t;
+
+/**
+ * Description for audio output. It contains
+ * name, description and pointer to next record.
+ */
+typedef struct libvlc_audio_output_t
+{
+    char *psz_name;
+    char *psz_description;
+    struct libvlc_audio_output_t *p_next;
+
+} libvlc_audio_output_t;
+
+/**
+ * Rectangle type for video geometry
+ */
+typedef struct libvlc_rectangle_t
+{
+    int top, left;
+    int bottom, right;
+} libvlc_rectangle_t;
+
+/**
+ * Marq options definition
+ */
+typedef enum libvlc_video_marquee_option_t {
+    libvlc_marquee_Enable = 0,
+    libvlc_marquee_Text,                  /** string argument */
+    libvlc_marquee_Color,
+    libvlc_marquee_Opacity,
+    libvlc_marquee_Position,
+    libvlc_marquee_Refresh,
+    libvlc_marquee_Size,
+    libvlc_marquee_Timeout,
+    libvlc_marquee_X,
+    libvlc_marquee_Y
+} libvlc_video_marquee_option_t;
+
+/**
+ * Navigation mode
+ */
+typedef enum libvlc_navigate_mode_t
+{
+    libvlc_navigate_activate = 0,
+    libvlc_navigate_up,
+    libvlc_navigate_down,
+    libvlc_navigate_left,
+    libvlc_navigate_right
+} libvlc_navigate_mode_t;
+
+/**
+ * Create an empty Media Player object
+ *
+ * \param p_libvlc_instance the libvlc instance in which the Media Player
+ *        should be created.
+ * \return a new media player object, or NULL on error.
+ */
+LIBVLC_API libvlc_media_player_t * libvlc_media_player_new( libvlc_instance_t *p_libvlc_instance );
+
+/**
+ * Create a Media Player object from a Media
+ *
+ * \param p_md the media. Afterwards the p_md can be safely
+ *        destroyed.
+ * \return a new media player object, or NULL on error.
+ */
+LIBVLC_API libvlc_media_player_t * libvlc_media_player_new_from_media( libvlc_media_t *p_md );
+
+/**
+ * Release a media_player after use
+ * Decrement the reference count of a media player object. If the
+ * reference count is 0, then libvlc_media_player_release() will
+ * release the media player object. If the media player object
+ * has been released, then it should not be used again.
+ *
+ * \param p_mi the Media Player to free
+ */
+LIBVLC_API void libvlc_media_player_release( libvlc_media_player_t *p_mi );
+
+/**
+ * Retain a reference to a media player object. Use
+ * libvlc_media_player_release() to decrement reference count.
+ *
+ * \param p_mi media player object
+ */
+LIBVLC_API void libvlc_media_player_retain( libvlc_media_player_t *p_mi );
+
+/**
+ * Set the media that will be used by the media_player. If any,
+ * previous md will be released.
+ *
+ * \param p_mi the Media Player
+ * \param p_md the Media. Afterwards the p_md can be safely
+ *        destroyed.
+ */
+LIBVLC_API void libvlc_media_player_set_media( libvlc_media_player_t *p_mi,
+                                                   libvlc_media_t *p_md );
+
+/**
+ * Get the media used by the media_player.
+ *
+ * \param p_mi the Media Player
+ * \return the media associated with p_mi, or NULL if no
+ *         media is associated
+ */
+LIBVLC_API libvlc_media_t * libvlc_media_player_get_media( libvlc_media_player_t *p_mi );
+
+/**
+ * Get the Event Manager from which the media player send event.
+ *
+ * \param p_mi the Media Player
+ * \return the event manager associated with p_mi
+ */
+LIBVLC_API libvlc_event_manager_t * libvlc_media_player_event_manager ( libvlc_media_player_t *p_mi );
+
+/**
+ * is_playing
+ *
+ * \param p_mi the Media Player
+ * \return 1 if the media player is playing, 0 otherwise
+ *
+ * \libvlc_return_bool
+ */
+LIBVLC_API int libvlc_media_player_is_playing ( libvlc_media_player_t *p_mi );
+
+/**
+ * Play
+ *
+ * \param p_mi the Media Player
+ * \return 0 if playback started (and was already started), or -1 on error.
+ */
+LIBVLC_API int libvlc_media_player_play ( libvlc_media_player_t *p_mi );
+
+/**
+ * Pause or resume (no effect if there is no media)
+ *
+ * \param mp the Media Player
+ * \param do_pause play/resume if zero, pause if non-zero
+ * \version LibVLC 1.1.1 or later
+ */
+LIBVLC_API void libvlc_media_player_set_pause ( libvlc_media_player_t *mp,
+                                                    int do_pause );
+
+/**
+ * Toggle pause (no effect if there is no media)
+ *
+ * \param p_mi the Media Player
+ */
+LIBVLC_API void libvlc_media_player_pause ( libvlc_media_player_t *p_mi );
+
+/**
+ * Stop (no effect if there is no media)
+ *
+ * \param p_mi the Media Player
+ */
+LIBVLC_API void libvlc_media_player_stop ( libvlc_media_player_t *p_mi );
+
+/**
+ * Callback prototype to allocate and lock a picture buffer.
+ *
+ * Whenever a new video frame needs to be decoded, the lock callback is
+ * invoked. Depending on the video chroma, one or three pixel planes of
+ * adequate dimensions must be returned via the second parameter. Those
+ * planes must be aligned on 32-bytes boundaries.
+ *
+ * \param opaque private pointer as passed to libvlc_video_set_callbacks() [IN]
+ * \param planes start address of the pixel planes (LibVLC allocates the array
+ *             of void pointers, this callback must initialize the array) [OUT]
+ * \return a private pointer for the display and unlock callbacks to identify
+ *         the picture buffers
+ */
+typedef void *(*libvlc_video_lock_cb)(void *opaque, void **planes);
+
+/**
+ * Callback prototype to unlock a picture buffer.
+ *
+ * When the video frame decoding is complete, the unlock callback is invoked.
+ * This callback might not be needed at all. It is only an indication that the
+ * application can now read the pixel values if it needs to.
+ *
+ * \warning A picture buffer is unlocked after the picture is decoded,
+ * but before the picture is displayed.
+ *
+ * \param opaque private pointer as passed to libvlc_video_set_callbacks() [IN]
+ * \param picture private pointer returned from the @ref libvlc_video_lock_cb
+ *                callback [IN]
+ * \param planes pixel planes as defined by the @ref libvlc_video_lock_cb
+ *               callback (this parameter is only for convenience) [IN]
+ */
+typedef void (*libvlc_video_unlock_cb)(void *opaque, void *picture,
+                                       void *const *planes);
+
+/**
+ * Callback prototype to display a picture.
+ *
+ * When the video frame needs to be shown, as determined by the media playback
+ * clock, the display callback is invoked.
+ *
+ * \param opaque private pointer as passed to libvlc_video_set_callbacks() [IN]
+ * \param picture private pointer returned from the @ref libvlc_video_lock_cb
+ *                callback [IN]
+ */
+typedef void (*libvlc_video_display_cb)(void *opaque, void *picture);
+
+/**
+ * Callback prototype to configure picture buffers format.
+ * This callback gets the format of the video as output by the video decoder
+ * and the chain of video filters (if any). It can opt to change any parameter
+ * as it needs. In that case, LibVLC will attempt to convert the video format
+ * (rescaling and chroma conversion) but these operations can be CPU intensive.
+ *
+ * \param opaque pointer to the private pointer passed to
+ *               libvlc_video_set_callbacks() [IN/OUT]
+ * \param chroma pointer to the 4 bytes video format identifier [IN/OUT]
+ * \param width pointer to the pixel width [IN/OUT]
+ * \param height pointer to the pixel height [IN/OUT]
+ * \param pitches table of scanline pitches in bytes for each pixel plane
+ *                (the table is allocated by LibVLC) [OUT]
+ * \param lines table of scanlines count for each plane [OUT]
+ * \return the number of picture buffers allocated, 0 indicates failure
+ *
+ * \note
+ * For each pixels plane, the scanline pitch must be bigger than or equal to
+ * the number of bytes per pixel multiplied by the pixel width.
+ * Similarly, the number of scanlines must be bigger than of equal to
+ * the pixel height.
+ * Furthermore, we recommend that pitches and lines be multiple of 32
+ * to not break assumption that might be made by various optimizations
+ * in the video decoders, video filters and/or video converters.
+ */
+typedef unsigned (*libvlc_video_format_cb)(void **opaque, char *chroma,
+                                           unsigned *width, unsigned *height,
+                                           unsigned *pitches,
+                                           unsigned *lines);
+
+/**
+ * Callback prototype to configure picture buffers format.
+ *
+ * \param opaque private pointer as passed to libvlc_video_set_callbacks()
+ *               (and possibly modified by @ref libvlc_video_format_cb) [IN]
+ */
+typedef void (*libvlc_video_cleanup_cb)(void *opaque);
+
+
+/**
+ * Set callbacks and private data to render decoded video to a custom area
+ * in memory.
+ * Use libvlc_video_set_format() or libvlc_video_set_format_callbacks()
+ * to configure the decoded format.
+ *
+ * \param mp the media player
+ * \param lock callback to lock video memory (must not be NULL)
+ * \param unlock callback to unlock video memory (or NULL if not needed)
+ * \param display callback to display video (or NULL if not needed)
+ * \param opaque private pointer for the three callbacks (as first parameter)
+ * \version LibVLC 1.1.1 or later
+ */
+LIBVLC_API
+void libvlc_video_set_callbacks( libvlc_media_player_t *mp,
+                                 libvlc_video_lock_cb lock,
+                                 libvlc_video_unlock_cb unlock,
+                                 libvlc_video_display_cb display,
+                                 void *opaque );
+
+/**
+ * Set decoded video chroma and dimensions.
+ * This only works in combination with libvlc_video_set_callbacks(),
+ * and is mutually exclusive with libvlc_video_set_format_callbacks().
+ *
+ * \param mp the media player
+ * \param chroma a four-characters string identifying the chroma
+ *               (e.g. "RV32" or "YUYV")
+ * \param width pixel width
+ * \param height pixel height
+ * \param pitch line pitch (in bytes)
+ * \version LibVLC 1.1.1 or later
+ * \bug All pixel planes are expected to have the same pitch.
+ * To use the YCbCr color space with chrominance subsampling,
+ * consider using libvlc_video_set_format_callbacks() instead.
+ */
+LIBVLC_API
+void libvlc_video_set_format( libvlc_media_player_t *mp, const char *chroma,
+                              unsigned width, unsigned height,
+                              unsigned pitch );
+
+/**
+ * Set decoded video chroma and dimensions. This only works in combination with
+ * libvlc_video_set_callbacks().
+ *
+ * \param mp the media player
+ * \param setup callback to select the video format (cannot be NULL)
+ * \param cleanup callback to release any allocated resources (or NULL)
+ * \version LibVLC 2.0.0 or later
+ */
+LIBVLC_API
+void libvlc_video_set_format_callbacks( libvlc_media_player_t *mp,
+                                        libvlc_video_format_cb setup,
+                                        libvlc_video_cleanup_cb cleanup );
+
+/**
+ * Set the NSView handler where the media player should render its video output.
+ *
+ * Use the vout called "macosx".
+ *
+ * The drawable is an NSObject that follow the VLCOpenGLVideoViewEmbedding
+ * protocol:
+ *
+ * @begincode
+ * \@protocol VLCOpenGLVideoViewEmbedding <NSObject>
+ * - (void)addVoutSubview:(NSView *)view;
+ * - (void)removeVoutSubview:(NSView *)view;
+ * \@end
+ * @endcode
+ *
+ * Or it can be an NSView object.
+ *
+ * If you want to use it along with Qt4 see the QMacCocoaViewContainer. Then
+ * the following code should work:
+ * @begincode
+ * {
+ *     NSView *video = [[NSView alloc] init];
+ *     QMacCocoaViewContainer *container = new QMacCocoaViewContainer(video, parent);
+ *     libvlc_media_player_set_nsobject(mp, video);
+ *     [video release];
+ * }
+ * @endcode
+ *
+ * You can find a live example in VLCVideoView in VLCKit.framework.
+ *
+ * \param p_mi the Media Player
+ * \param drawable the drawable that is either an NSView or an object following
+ * the VLCOpenGLVideoViewEmbedding protocol.
+ */
+LIBVLC_API void libvlc_media_player_set_nsobject ( libvlc_media_player_t *p_mi, void * drawable );
+
+/**
+ * Get the NSView handler previously set with libvlc_media_player_set_nsobject().
+ *
+ * \param p_mi the Media Player
+ * \return the NSView handler or 0 if none where set
+ */
+LIBVLC_API void * libvlc_media_player_get_nsobject ( libvlc_media_player_t *p_mi );
+
+/**
+ * Set the agl handler where the media player should render its video output.
+ *
+ * \param p_mi the Media Player
+ * \param drawable the agl handler
+ */
+LIBVLC_API void libvlc_media_player_set_agl ( libvlc_media_player_t *p_mi, uint32_t drawable );
+
+/**
+ * Get the agl handler previously set with libvlc_media_player_set_agl().
+ *
+ * \param p_mi the Media Player
+ * \return the agl handler or 0 if none where set
+ */
+LIBVLC_API uint32_t libvlc_media_player_get_agl ( libvlc_media_player_t *p_mi );
+
+/**
+ * Set an X Window System drawable where the media player should render its
+ * video output. If LibVLC was built without X11 output support, then this has
+ * no effects.
+ *
+ * The specified identifier must correspond to an existing Input/Output class
+ * X11 window. Pixmaps are <b>not</b> supported. The caller shall ensure that
+ * the X11 server is the same as the one the VLC instance has been configured
+ * with. This function must be called before video playback is started;
+ * otherwise it will only take effect after playback stop and restart.
+ *
+ * \param p_mi the Media Player
+ * \param drawable the ID of the X window
+ */
+LIBVLC_API void libvlc_media_player_set_xwindow ( libvlc_media_player_t *p_mi, uint32_t drawable );
+
+/**
+ * Get the X Window System window identifier previously set with
+ * libvlc_media_player_set_xwindow(). Note that this will return the identifier
+ * even if VLC is not currently using it (for instance if it is playing an
+ * audio-only input).
+ *
+ * \param p_mi the Media Player
+ * \return an X window ID, or 0 if none where set.
+ */
+LIBVLC_API uint32_t libvlc_media_player_get_xwindow ( libvlc_media_player_t *p_mi );
+
+/**
+ * Set a Win32/Win64 API window handle (HWND) where the media player should
+ * render its video output. If LibVLC was built without Win32/Win64 API output
+ * support, then this has no effects.
+ *
+ * \param p_mi the Media Player
+ * \param drawable windows handle of the drawable
+ */
+LIBVLC_API void libvlc_media_player_set_hwnd ( libvlc_media_player_t *p_mi, void *drawable );
+
+/**
+ * Get the Windows API window handle (HWND) previously set with
+ * libvlc_media_player_set_hwnd(). The handle will be returned even if LibVLC
+ * is not currently outputting any video to it.
+ *
+ * \param p_mi the Media Player
+ * \return a window handle or NULL if there are none.
+ */
+LIBVLC_API void *libvlc_media_player_get_hwnd ( libvlc_media_player_t *p_mi );
+
+/**
+ * Callback prototype for audio playback.
+ * \param data data pointer as passed to libvlc_audio_set_callbacks() [IN]
+ * \param samples pointer to the first audio sample to play back [IN]
+ * \param count number of audio samples to play back
+ * \param pts expected play time stamp (see libvlc_delay())
+ */
+typedef void (*libvlc_audio_play_cb)(void *data, const void *samples,
+                                     unsigned count, int64_t pts);
+
+/**
+ * Callback prototype for audio pause.
+ * \note The pause callback is never called if the audio is already paused.
+ * \param data data pointer as passed to libvlc_audio_set_callbacks() [IN]
+ * \param pts time stamp of the pause request (should be elapsed already)
+ */
+typedef void (*libvlc_audio_pause_cb)(void *data, int64_t pts);
+
+/**
+ * Callback prototype for audio resumption (i.e. restart from pause).
+ * \note The resume callback is never called if the audio is not paused.
+ * \param data data pointer as passed to libvlc_audio_set_callbacks() [IN]
+ * \param pts time stamp of the resumption request (should be elapsed already)
+ */
+typedef void (*libvlc_audio_resume_cb)(void *data, int64_t pts);
+
+/**
+ * Callback prototype for audio buffer flush
+ * (i.e. discard all pending buffers and stop playback as soon as possible).
+ * \param data data pointer as passed to libvlc_audio_set_callbacks() [IN]
+ */
+typedef void (*libvlc_audio_flush_cb)(void *data, int64_t pts);
+
+/**
+ * Callback prototype for audio buffer drain
+ * (i.e. wait for pending buffers to be played).
+ * \param data data pointer as passed to libvlc_audio_set_callbacks() [IN]
+ */
+typedef void (*libvlc_audio_drain_cb)(void *data);
+
+/**
+ * Callback prototype for audio volume change.
+ * \param data data pointer as passed to libvlc_audio_set_callbacks() [IN]
+ * \param volume software volume (1. = nominal, 0. = mute)
+ * \param mute muted flag
+ */
+typedef void (*libvlc_audio_set_volume_cb)(void *data,
+                                           float volume, bool mute);
+
+/**
+ * Set callbacks and private data for decoded audio.
+ * Use libvlc_audio_set_format() or libvlc_audio_set_format_callbacks()
+ * to configure the decoded audio format.
+ *
+ * \param mp the media player
+ * \param play callback to play audio samples (must not be NULL)
+ * \param pause callback to pause playback (or NULL to ignore)
+ * \param resume callback to resume playback (or NULL to ignore)
+ * \param flush callback to flush audio buffers (or NULL to ignore)
+ * \param drain callback to drain audio buffers (or NULL to ignore)
+ * \param opaque private pointer for the audio callbacks (as first parameter)
+ * \version LibVLC 2.0.0 or later
+ */
+LIBVLC_API
+void libvlc_audio_set_callbacks( libvlc_media_player_t *mp,
+                                 libvlc_audio_play_cb play,
+                                 libvlc_audio_pause_cb pause,
+                                 libvlc_audio_resume_cb resume,
+                                 libvlc_audio_flush_cb flush,
+                                 libvlc_audio_drain_cb drain,
+                                 void *opaque );
+
+/**
+ * Set callbacks and private data for decoded audio.
+ * Use libvlc_audio_set_format() or libvlc_audio_set_format_callbacks()
+ * to configure the decoded audio format.
+ *
+ * \param mp the media player
+ * \param set_volume callback to apply audio volume,
+ *                   or NULL to apply volume in software
+ * \version LibVLC 2.0.0 or later
+ */
+LIBVLC_API
+void libvlc_audio_set_volume_callback( libvlc_media_player_t *mp,
+                                       libvlc_audio_set_volume_cb set_volume );
+
+/**
+ * Callback prototype to setup the audio playback.
+ * This is called when the media player needs to create a new audio output.
+ * \param opaque pointer to the data pointer passed to
+ *               libvlc_audio_set_callbacks() [IN/OUT]
+ * \param format 4 bytes sample format [IN/OUT]
+ * \param rate sample rate [IN/OUT]
+ * \param channels channels count [IN/OUT]
+ * \return 0 on success, anything else to skip audio playback
+ */
+typedef int (*libvlc_audio_setup_cb)(void **data, char *format, unsigned *rate,
+                                     unsigned *channels);
+
+/**
+ * Callback prototype for audio playback cleanup.
+ * This is called when the media player no longer needs an audio output.
+ * \param opaque data pointer as passed to libvlc_audio_set_callbacks() [IN]
+ */
+typedef void (*libvlc_audio_cleanup_cb)(void *data);
+
+/**
+ * Set decoded audio format. This only works in combination with
+ * libvlc_audio_set_callbacks().
+ *
+ * \param mp the media player
+ * \param setup callback to select the audio format (cannot be NULL)
+ * \param cleanup callback to release any allocated resources (or NULL)
+ * \version LibVLC 2.0.0 or later
+ */
+LIBVLC_API
+void libvlc_audio_set_format_callbacks( libvlc_media_player_t *mp,
+                                        libvlc_audio_setup_cb setup,
+                                        libvlc_audio_cleanup_cb cleanup );
+
+/**
+ * Set decoded audio format.
+ * This only works in combination with libvlc_audio_set_callbacks(),
+ * and is mutually exclusive with libvlc_audio_set_format_callbacks().
+ *
+ * \param mp the media player
+ * \param format a four-characters string identifying the sample format
+ *               (e.g. "S16N" or "FL32")
+ * \param rate sample rate (expressed in Hz)
+ * \param channels channels count
+ * \version LibVLC 2.0.0 or later
+ */
+LIBVLC_API
+void libvlc_audio_set_format( libvlc_media_player_t *mp, const char *format,
+                              unsigned rate, unsigned channels );
+
+/** \bug This might go away ... to be replaced by a broader system */
+
+/**
+ * Get the current movie length (in ms).
+ *
+ * \param p_mi the Media Player
+ * \return the movie length (in ms), or -1 if there is no media.
+ */
+LIBVLC_API libvlc_time_t libvlc_media_player_get_length( libvlc_media_player_t *p_mi );
+
+/**
+ * Get the current movie time (in ms).
+ *
+ * \param p_mi the Media Player
+ * \return the movie time (in ms), or -1 if there is no media.
+ */
+LIBVLC_API libvlc_time_t libvlc_media_player_get_time( libvlc_media_player_t *p_mi );
+
+/**
+ * Set the movie time (in ms). This has no effect if no media is being played.
+ * Not all formats and protocols support this.
+ *
+ * \param p_mi the Media Player
+ * \param i_time the movie time (in ms).
+ */
+LIBVLC_API void libvlc_media_player_set_time( libvlc_media_player_t *p_mi, libvlc_time_t i_time );
+
+/**
+ * Get movie position.
+ *
+ * \param p_mi the Media Player
+ * \return movie position, or -1. in case of error
+ */
+LIBVLC_API float libvlc_media_player_get_position( libvlc_media_player_t *p_mi );
+
+/**
+ * Set movie position. This has no effect if playback is not enabled.
+ * This might not work depending on the underlying input format and protocol.
+ *
+ * \param p_mi the Media Player
+ * \param f_pos the position
+ */
+LIBVLC_API void libvlc_media_player_set_position( libvlc_media_player_t *p_mi, float f_pos );
+
+/**
+ * Set movie chapter (if applicable).
+ *
+ * \param p_mi the Media Player
+ * \param i_chapter chapter number to play
+ */
+LIBVLC_API void libvlc_media_player_set_chapter( libvlc_media_player_t *p_mi, int i_chapter );
+
+/**
+ * Get movie chapter.
+ *
+ * \param p_mi the Media Player
+ * \return chapter number currently playing, or -1 if there is no media.
+ */
+LIBVLC_API int libvlc_media_player_get_chapter( libvlc_media_player_t *p_mi );
+
+/**
+ * Get movie chapter count
+ *
+ * \param p_mi the Media Player
+ * \return number of chapters in movie, or -1.
+ */
+LIBVLC_API int libvlc_media_player_get_chapter_count( libvlc_media_player_t *p_mi );
+
+/**
+ * Is the player able to play
+ *
+ * \param p_mi the Media Player
+ * \return boolean
+ *
+ * \libvlc_return_bool
+ */
+LIBVLC_API int libvlc_media_player_will_play( libvlc_media_player_t *p_mi );
+
+/**
+ * Get title chapter count
+ *
+ * \param p_mi the Media Player
+ * \param i_title title
+ * \return number of chapters in title, or -1
+ */
+LIBVLC_API int libvlc_media_player_get_chapter_count_for_title(
+                       libvlc_media_player_t *p_mi, int i_title );
+
+/**
+ * Set movie title
+ *
+ * \param p_mi the Media Player
+ * \param i_title title number to play
+ */
+LIBVLC_API void libvlc_media_player_set_title( libvlc_media_player_t *p_mi, int i_title );
+
+/**
+ * Get movie title
+ *
+ * \param p_mi the Media Player
+ * \return title number currently playing, or -1
+ */
+LIBVLC_API int libvlc_media_player_get_title( libvlc_media_player_t *p_mi );
+
+/**
+ * Get movie title count
+ *
+ * \param p_mi the Media Player
+ * \return title number count, or -1
+ */
+LIBVLC_API int libvlc_media_player_get_title_count( libvlc_media_player_t *p_mi );
+
+/**
+ * Set previous chapter (if applicable)
+ *
+ * \param p_mi the Media Player
+ */
+LIBVLC_API void libvlc_media_player_previous_chapter( libvlc_media_player_t *p_mi );
+
+/**
+ * Set next chapter (if applicable)
+ *
+ * \param p_mi the Media Player
+ */
+LIBVLC_API void libvlc_media_player_next_chapter( libvlc_media_player_t *p_mi );
+
+/**
+ * Get the requested movie play rate.
+ * @warning Depending on the underlying media, the requested rate may be
+ * different from the real playback rate.
+ *
+ * \param p_mi the Media Player
+ * \return movie play rate
+ */
+LIBVLC_API float libvlc_media_player_get_rate( libvlc_media_player_t *p_mi );
+
+/**
+ * Set movie play rate
+ *
+ * \param p_mi the Media Player
+ * \param rate movie play rate to set
+ * \return -1 if an error was detected, 0 otherwise (but even then, it might
+ * not actually work depending on the underlying media protocol)
+ */
+LIBVLC_API int libvlc_media_player_set_rate( libvlc_media_player_t *p_mi, float rate );
+
+/**
+ * Get current movie state
+ *
+ * \param p_mi the Media Player
+ * \return the current state of the media player (playing, paused, ...) \see libvlc_state_t
+ */
+LIBVLC_API libvlc_state_t libvlc_media_player_get_state( libvlc_media_player_t *p_mi );
+
+/**
+ * Get movie fps rate
+ *
+ * \param p_mi the Media Player
+ * \return frames per second (fps) for this playing movie, or 0 if unspecified
+ */
+LIBVLC_API float libvlc_media_player_get_fps( libvlc_media_player_t *p_mi );
+
+/** end bug */
+
+/**
+ * How many video outputs does this media player have?
+ *
+ * \param p_mi the media player
+ * \return the number of video outputs
+ */
+LIBVLC_API unsigned libvlc_media_player_has_vout( libvlc_media_player_t *p_mi );
+
+/**
+ * Is this media player seekable?
+ *
+ * \param p_mi the media player
+ * \return true if the media player can seek
+ *
+ * \libvlc_return_bool
+ */
+LIBVLC_API int libvlc_media_player_is_seekable( libvlc_media_player_t *p_mi );
+
+/**
+ * Can this media player be paused?
+ *
+ * \param p_mi the media player
+ * \return true if the media player can pause
+ *
+ * \libvlc_return_bool
+ */
+LIBVLC_API int libvlc_media_player_can_pause( libvlc_media_player_t *p_mi );
+
+
+/**
+ * Display the next frame (if supported)
+ *
+ * \param p_mi the media player
+ */
+LIBVLC_API void libvlc_media_player_next_frame( libvlc_media_player_t *p_mi );
+
+/**
+ * Navigate through DVD Menu
+ *
+ * \param p_mi the Media Player
+ * \param navigate the Navigation mode
+ * \version libVLC 2.0.0 or later
+ */
+LIBVLC_API void libvlc_media_player_navigate( libvlc_media_player_t* p_mi,
+                                              unsigned navigate );
+
+/**
+ * Release (free) libvlc_track_description_t
+ *
+ * \param p_track_description the structure to release
+ */
+LIBVLC_API void libvlc_track_description_list_release( libvlc_track_description_t *p_track_description );
+
+/**
+ * \deprecated Use libvlc_track_description_list_release instead
+ */
+LIBVLC_DEPRECATED
+LIBVLC_API void libvlc_track_description_release( libvlc_track_description_t *p_track_description );
+
+/** \defgroup libvlc_video LibVLC video controls
+ * @{
+ */
+
+/**
+ * Toggle fullscreen status on non-embedded video outputs.
+ *
+ * @warning The same limitations applies to this function
+ * as to libvlc_set_fullscreen().
+ *
+ * \param p_mi the media player
+ */
+LIBVLC_API void libvlc_toggle_fullscreen( libvlc_media_player_t *p_mi );
+
+/**
+ * Enable or disable fullscreen.
+ *
+ * @warning With most window managers, only a top-level windows can be in
+ * full-screen mode. Hence, this function will not operate properly if
+ * libvlc_media_player_set_xwindow() was used to embed the video in a
+ * non-top-level window. In that case, the embedding window must be reparented
+ * to the root window <b>before</b> fullscreen mode is enabled. You will want
+ * to reparent it back to its normal parent when disabling fullscreen.
+ *
+ * \param p_mi the media player
+ * \param b_fullscreen boolean for fullscreen status
+ */
+LIBVLC_API void libvlc_set_fullscreen( libvlc_media_player_t *p_mi, int b_fullscreen );
+
+/**
+ * Get current fullscreen status.
+ *
+ * \param p_mi the media player
+ * \return the fullscreen status (boolean)
+ *
+ * \libvlc_return_bool
+ */
+LIBVLC_API int libvlc_get_fullscreen( libvlc_media_player_t *p_mi );
+
+/**
+ * Enable or disable key press events handling, according to the LibVLC hotkeys
+ * configuration. By default and for historical reasons, keyboard events are
+ * handled by the LibVLC video widget.
+ *
+ * \note On X11, there can be only one subscriber for key press and mouse
+ * click events per window. If your application has subscribed to those events
+ * for the X window ID of the video widget, then LibVLC will not be able to
+ * handle key presses and mouse clicks in any case.
+ *
+ * \warning This function is only implemented for X11 and Win32 at the moment.
+ *
+ * \param p_mi the media player
+ * \param on true to handle key press events, false to ignore them.
+ */
+LIBVLC_API
+void libvlc_video_set_key_input( libvlc_media_player_t *p_mi, unsigned on );
+
+/**
+ * Enable or disable mouse click events handling. By default, those events are
+ * handled. This is needed for DVD menus to work, as well as a few video
+ * filters such as "puzzle".
+ *
+ * \see libvlc_video_set_key_input().
+ *
+ * \warning This function is only implemented for X11 and Win32 at the moment.
+ *
+ * \param p_mi the media player
+ * \param on true to handle mouse click events, false to ignore them.
+ */
+LIBVLC_API
+void libvlc_video_set_mouse_input( libvlc_media_player_t *p_mi, unsigned on );
+
+/**
+ * Get the pixel dimensions of a video.
+ *
+ * \param p_mi media player
+ * \param num number of the video (starting from, and most commonly 0)
+ * \param px pointer to get the pixel width [OUT]
+ * \param py pointer to get the pixel height [OUT]
+ * \return 0 on success, -1 if the specified video does not exist
+ */
+LIBVLC_API
+int libvlc_video_get_size( libvlc_media_player_t *p_mi, unsigned num,
+                           unsigned *px, unsigned *py );
+
+/**
+ * Get current video height.
+ * \deprecated Use libvlc_video_get_size() instead.
+ *
+ * \param p_mi the media player
+ * \return the video pixel height or 0 if not applicable
+ */
+LIBVLC_DEPRECATED LIBVLC_API
+int libvlc_video_get_height( libvlc_media_player_t *p_mi );
+
+/**
+ * Get current video width.
+ * \deprecated Use libvlc_video_get_size() instead.
+ *
+ * \param p_mi the media player
+ * \return the video pixel width or 0 if not applicable
+ */
+LIBVLC_DEPRECATED LIBVLC_API
+int libvlc_video_get_width( libvlc_media_player_t *p_mi );
+
+/**
+ * Get the mouse pointer coordinates over a video.
+ * Coordinates are expressed in terms of the decoded video resolution,
+ * <b>not</b> in terms of pixels on the screen/viewport (to get the latter,
+ * you can query your windowing system directly).
+ *
+ * Either of the coordinates may be negative or larger than the corresponding
+ * dimension of the video, if the cursor is outside the rendering area.
+ *
+ * @warning The coordinates may be out-of-date if the pointer is not located
+ * on the video rendering area. LibVLC does not track the pointer if it is
+ * outside of the video widget.
+ *
+ * @note LibVLC does not support multiple pointers (it does of course support
+ * multiple input devices sharing the same pointer) at the moment.
+ *
+ * \param p_mi media player
+ * \param num number of the video (starting from, and most commonly 0)
+ * \param px pointer to get the abscissa [OUT]
+ * \param py pointer to get the ordinate [OUT]
+ * \return 0 on success, -1 if the specified video does not exist
+ */
+LIBVLC_API
+int libvlc_video_get_cursor( libvlc_media_player_t *p_mi, unsigned num,
+                             int *px, int *py );
+
+/**
+ * Get the current video scaling factor.
+ * See also libvlc_video_set_scale().
+ *
+ * \param p_mi the media player
+ * \return the currently configured zoom factor, or 0. if the video is set
+ * to fit to the output window/drawable automatically.
+ */
+LIBVLC_API float libvlc_video_get_scale( libvlc_media_player_t *p_mi );
+
+/**
+ * Set the video scaling factor. That is the ratio of the number of pixels on
+ * screen to the number of pixels in the original decoded video in each
+ * dimension. Zero is a special value; it will adjust the video to the output
+ * window/drawable (in windowed mode) or the entire screen.
+ *
+ * Note that not all video outputs support scaling.
+ *
+ * \param p_mi the media player
+ * \param f_factor the scaling factor, or zero
+ */
+LIBVLC_API void libvlc_video_set_scale( libvlc_media_player_t *p_mi, float f_factor );
+
+/**
+ * Get current video aspect ratio.
+ *
+ * \param p_mi the media player
+ * \return the video aspect ratio or NULL if unspecified
+ * (the result must be released with free() or libvlc_free()).
+ */
+LIBVLC_API char *libvlc_video_get_aspect_ratio( libvlc_media_player_t *p_mi );
+
+/**
+ * Set new video aspect ratio.
+ *
+ * \param p_mi the media player
+ * \param psz_aspect new video aspect-ratio or NULL to reset to default
+ * \note Invalid aspect ratios are ignored.
+ */
+LIBVLC_API void libvlc_video_set_aspect_ratio( libvlc_media_player_t *p_mi, const char *psz_aspect );
+
+/**
+ * Get current video subtitle.
+ *
+ * \param p_mi the media player
+ * \return the video subtitle selected, or -1 if none
+ */
+LIBVLC_API int libvlc_video_get_spu( libvlc_media_player_t *p_mi );
+
+/**
+ * Get the number of available video subtitles.
+ *
+ * \param p_mi the media player
+ * \return the number of available video subtitles
+ */
+LIBVLC_API int libvlc_video_get_spu_count( libvlc_media_player_t *p_mi );
+
+/**
+ * Get the description of available video subtitles.
+ *
+ * \param p_mi the media player
+ * \return list containing description of available video subtitles
+ */
+LIBVLC_API libvlc_track_description_t *
+        libvlc_video_get_spu_description( libvlc_media_player_t *p_mi );
+
+/**
+ * Set new video subtitle.
+ *
+ * \param p_mi the media player
+ * \param i_spu new video subtitle to select
+ * \return 0 on success, -1 if out of range
+ */
+LIBVLC_API int libvlc_video_set_spu( libvlc_media_player_t *p_mi, unsigned i_spu );
+
+/**
+ * Set new video subtitle file.
+ *
+ * \param p_mi the media player
+ * \param psz_subtitle new video subtitle file
+ * \return the success status (boolean)
+ */
+LIBVLC_API int libvlc_video_set_subtitle_file( libvlc_media_player_t *p_mi, const char *psz_subtitle );
+
+/**
+ * Get the current subtitle delay. Positive values means subtitles are being
+ * displayed later, negative values earlier.
+ *
+ * \param p_mi media player
+ * \return time (in microseconds) the display of subtitles is being delayed
+ * \version LibVLC 2.0.0 or later
+ */
+LIBVLC_API int64_t libvlc_video_get_spu_delay( libvlc_media_player_t *p_mi );
+
+/**
+ * Set the subtitle delay. This affects the timing of when the subtitle will
+ * be displayed. Positive values result in subtitles being displayed later,
+ * while negative values will result in subtitles being displayed earlier.
+ *
+ * The subtitle delay will be reset to zero each time the media changes.
+ *
+ * \param p_mi media player
+ * \param i_delay time (in microseconds) the display of subtitles should be delayed
+ * \return 0 on success, -1 on error
+ * \version LibVLC 2.0.0 or later
+ */
+LIBVLC_API int libvlc_video_set_spu_delay( libvlc_media_player_t *p_mi, int64_t i_delay );
+
+/**
+ * Get the description of available titles.
+ *
+ * \param p_mi the media player
+ * \return list containing description of available titles
+ */
+LIBVLC_API libvlc_track_description_t *
+        libvlc_video_get_title_description( libvlc_media_player_t *p_mi );
+
+/**
+ * Get the description of available chapters for specific title.
+ *
+ * \param p_mi the media player
+ * \param i_title selected title
+ * \return list containing description of available chapter for title i_title
+ */
+LIBVLC_API libvlc_track_description_t *
+        libvlc_video_get_chapter_description( libvlc_media_player_t *p_mi, int i_title );
+
+/**
+ * Get current crop filter geometry.
+ *
+ * \param p_mi the media player
+ * \return the crop filter geometry or NULL if unset
+ */
+LIBVLC_API char *libvlc_video_get_crop_geometry( libvlc_media_player_t *p_mi );
+
+/**
+ * Set new crop filter geometry.
+ *
+ * \param p_mi the media player
+ * \param psz_geometry new crop filter geometry (NULL to unset)
+ */
+LIBVLC_API
+void libvlc_video_set_crop_geometry( libvlc_media_player_t *p_mi, const char *psz_geometry );
+
+/**
+ * Get current teletext page requested.
+ *
+ * \param p_mi the media player
+ * \return the current teletext page requested.
+ */
+LIBVLC_API int libvlc_video_get_teletext( libvlc_media_player_t *p_mi );
+
+/**
+ * Set new teletext page to retrieve.
+ *
+ * \param p_mi the media player
+ * \param i_page teletex page number requested
+ */
+LIBVLC_API void libvlc_video_set_teletext( libvlc_media_player_t *p_mi, int i_page );
+
+/**
+ * Toggle teletext transparent status on video output.
+ *
+ * \param p_mi the media player
+ */
+LIBVLC_API void libvlc_toggle_teletext( libvlc_media_player_t *p_mi );
+
+/**
+ * Get number of available video tracks.
+ *
+ * \param p_mi media player
+ * \return the number of available video tracks (int)
+ */
+LIBVLC_API int libvlc_video_get_track_count( libvlc_media_player_t *p_mi );
+
+/**
+ * Get the description of available video tracks.
+ *
+ * \param p_mi media player
+ * \return list with description of available video tracks, or NULL on error
+ */
+LIBVLC_API libvlc_track_description_t *
+        libvlc_video_get_track_description( libvlc_media_player_t *p_mi );
+
+/**
+ * Get current video track.
+ *
+ * \param p_mi media player
+ * \return the video track (int) or -1 if none
+ */
+LIBVLC_API int libvlc_video_get_track( libvlc_media_player_t *p_mi );
+
+/**
+ * Set video track.
+ *
+ * \param p_mi media player
+ * \param i_track the track (int)
+ * \return 0 on success, -1 if out of range
+ */
+LIBVLC_API
+int libvlc_video_set_track( libvlc_media_player_t *p_mi, int i_track );
+
+/**
+ * Take a snapshot of the current video window.
+ *
+ * If i_width AND i_height is 0, original size is used.
+ * If i_width XOR i_height is 0, original aspect-ratio is preserved.
+ *
+ * \param p_mi media player instance
+ * \param num number of video output (typically 0 for the first/only one)
+ * \param psz_filepath the path where to save the screenshot to
+ * \param i_width the snapshot's width
+ * \param i_height the snapshot's height
+ * \return 0 on success, -1 if the video was not found
+ */
+LIBVLC_API
+int libvlc_video_take_snapshot( libvlc_media_player_t *p_mi, unsigned num,
+                                const char *psz_filepath, unsigned int i_width,
+                                unsigned int i_height );
+
+/**
+ * Enable or disable deinterlace filter
+ *
+ * \param p_mi libvlc media player
+ * \param psz_mode type of deinterlace filter, NULL to disable
+ */
+LIBVLC_API void libvlc_video_set_deinterlace( libvlc_media_player_t *p_mi,
+                                                  const char *psz_mode );
+
+/**
+ * Get an integer marquee option value
+ *
+ * \param p_mi libvlc media player
+ * \param option marq option to get \see libvlc_video_marquee_int_option_t
+ */
+LIBVLC_API int libvlc_video_get_marquee_int( libvlc_media_player_t *p_mi,
+                                                 unsigned option );
+
+/**
+ * Get a string marquee option value
+ *
+ * \param p_mi libvlc media player
+ * \param option marq option to get \see libvlc_video_marquee_string_option_t
+ */
+LIBVLC_API char *libvlc_video_get_marquee_string( libvlc_media_player_t *p_mi,
+                                                      unsigned option );
+
+/**
+ * Enable, disable or set an integer marquee option
+ *
+ * Setting libvlc_marquee_Enable has the side effect of enabling (arg !0)
+ * or disabling (arg 0) the marq filter.
+ *
+ * \param p_mi libvlc media player
+ * \param option marq option to set \see libvlc_video_marquee_int_option_t
+ * \param i_val marq option value
+ */
+LIBVLC_API void libvlc_video_set_marquee_int( libvlc_media_player_t *p_mi,
+                                                  unsigned option, int i_val );
+
+/**
+ * Set a marquee string option
+ *
+ * \param p_mi libvlc media player
+ * \param option marq option to set \see libvlc_video_marquee_string_option_t
+ * \param psz_text marq option value
+ */
+LIBVLC_API void libvlc_video_set_marquee_string( libvlc_media_player_t *p_mi,
+                                                     unsigned option, const char *psz_text );
+
+/** option values for libvlc_video_{get,set}_logo_{int,string} */
+enum libvlc_video_logo_option_t {
+    libvlc_logo_enable,
+    libvlc_logo_file,           /**< string argument, "file,d,t;file,d,t;..." */
+    libvlc_logo_x,
+    libvlc_logo_y,
+    libvlc_logo_delay,
+    libvlc_logo_repeat,
+    libvlc_logo_opacity,
+    libvlc_logo_position
+};
+
+/**
+ * Get integer logo option.
+ *
+ * \param p_mi libvlc media player instance
+ * \param option logo option to get, values of libvlc_video_logo_option_t
+ */
+LIBVLC_API int libvlc_video_get_logo_int( libvlc_media_player_t *p_mi,
+                                              unsigned option );
+
+/**
+ * Set logo option as integer. Options that take a different type value
+ * are ignored.
+ * Passing libvlc_logo_enable as option value has the side effect of
+ * starting (arg !0) or stopping (arg 0) the logo filter.
+ *
+ * \param p_mi libvlc media player instance
+ * \param option logo option to set, values of libvlc_video_logo_option_t
+ * \param value logo option value
+ */
+LIBVLC_API void libvlc_video_set_logo_int( libvlc_media_player_t *p_mi,
+                                               unsigned option, int value );
+
+/**
+ * Set logo option as string. Options that take a different type value
+ * are ignored.
+ *
+ * \param p_mi libvlc media player instance
+ * \param option logo option to set, values of libvlc_video_logo_option_t
+ * \param psz_value logo option value
+ */
+LIBVLC_API void libvlc_video_set_logo_string( libvlc_media_player_t *p_mi,
+                                      unsigned option, const char *psz_value );
+
+
+/** option values for libvlc_video_{get,set}_adjust_{int,float,bool} */
+enum libvlc_video_adjust_option_t {
+    libvlc_adjust_Enable = 0,
+    libvlc_adjust_Contrast,
+    libvlc_adjust_Brightness,
+    libvlc_adjust_Hue,
+    libvlc_adjust_Saturation,
+    libvlc_adjust_Gamma
+};
+
+/**
+ * Get integer adjust option.
+ *
+ * \param p_mi libvlc media player instance
+ * \param option adjust option to get, values of libvlc_video_adjust_option_t
+ * \version LibVLC 1.1.1 and later.
+ */
+LIBVLC_API int libvlc_video_get_adjust_int( libvlc_media_player_t *p_mi,
+                                                unsigned option );
+
+/**
+ * Set adjust option as integer. Options that take a different type value
+ * are ignored.
+ * Passing libvlc_adjust_enable as option value has the side effect of
+ * starting (arg !0) or stopping (arg 0) the adjust filter.
+ *
+ * \param p_mi libvlc media player instance
+ * \param option adust option to set, values of libvlc_video_adjust_option_t
+ * \param value adjust option value
+ * \version LibVLC 1.1.1 and later.
+ */
+LIBVLC_API void libvlc_video_set_adjust_int( libvlc_media_player_t *p_mi,
+                                                 unsigned option, int value );
+
+/**
+ * Get float adjust option.
+ *
+ * \param p_mi libvlc media player instance
+ * \param option adjust option to get, values of libvlc_video_adjust_option_t
+ * \version LibVLC 1.1.1 and later.
+ */
+LIBVLC_API float libvlc_video_get_adjust_float( libvlc_media_player_t *p_mi,
+                                                    unsigned option );
+
+/**
+ * Set adjust option as float. Options that take a different type value
+ * are ignored.
+ *
+ * \param p_mi libvlc media player instance
+ * \param option adust option to set, values of libvlc_video_adjust_option_t
+ * \param value adjust option value
+ * \version LibVLC 1.1.1 and later.
+ */
+LIBVLC_API void libvlc_video_set_adjust_float( libvlc_media_player_t *p_mi,
+                                                   unsigned option, float value );
+
+/** @} video */
+
+/** \defgroup libvlc_audio LibVLC audio controls
+ * @{
+ */
+
+/**
+ * Audio device types
+ */
+typedef enum libvlc_audio_output_device_types_t {
+    libvlc_AudioOutputDevice_Error  = -1,
+    libvlc_AudioOutputDevice_Mono   =  1,
+    libvlc_AudioOutputDevice_Stereo =  2,
+    libvlc_AudioOutputDevice_2F2R   =  4,
+    libvlc_AudioOutputDevice_3F2R   =  5,
+    libvlc_AudioOutputDevice_5_1    =  6,
+    libvlc_AudioOutputDevice_6_1    =  7,
+    libvlc_AudioOutputDevice_7_1    =  8,
+    libvlc_AudioOutputDevice_SPDIF  = 10
+} libvlc_audio_output_device_types_t;
+
+/**
+ * Audio channels
+ */
+typedef enum libvlc_audio_output_channel_t {
+    libvlc_AudioChannel_Error   = -1,
+    libvlc_AudioChannel_Stereo  =  1,
+    libvlc_AudioChannel_RStereo =  2,
+    libvlc_AudioChannel_Left    =  3,
+    libvlc_AudioChannel_Right   =  4,
+    libvlc_AudioChannel_Dolbys  =  5
+} libvlc_audio_output_channel_t;
+
+
+/**
+ * Get the list of available audio outputs
+ *
+ * \param p_instance libvlc instance
+ * \return list of available audio outputs. It must be freed it with
+*          \see libvlc_audio_output_list_release \see libvlc_audio_output_t .
+ *         In case of error, NULL is returned.
+ */
+LIBVLC_API libvlc_audio_output_t *
+        libvlc_audio_output_list_get( libvlc_instance_t *p_instance );
+
+/**
+ * Free the list of available audio outputs
+ *
+ * \param p_list list with audio outputs for release
+ */
+LIBVLC_API void libvlc_audio_output_list_release( libvlc_audio_output_t *p_list );
+
+/**
+ * Set the audio output.
+ * Change will be applied after stop and play.
+ *
+ * \param p_mi media player
+ * \param psz_name name of audio output,
+ *               use psz_name of \see libvlc_audio_output_t
+ * \return 0 if function succeded, -1 on error
+ */
+LIBVLC_API int libvlc_audio_output_set( libvlc_media_player_t *p_mi,
+                                            const char *psz_name );
+
+/**
+ * Get count of devices for audio output, these devices are hardware oriented
+ * like analor or digital output of sound card
+ *
+ * \param p_instance libvlc instance
+ * \param psz_audio_output - name of audio output, \see libvlc_audio_output_t
+ * \return number of devices
+ */
+LIBVLC_API int libvlc_audio_output_device_count( libvlc_instance_t *p_instance,
+                                                     const char *psz_audio_output );
+
+/**
+ * Get long name of device, if not available short name given
+ *
+ * \param p_instance libvlc instance
+ * \param psz_audio_output - name of audio output, \see libvlc_audio_output_t
+ * \param i_device device index
+ * \return long name of device
+ */
+LIBVLC_API char * libvlc_audio_output_device_longname( libvlc_instance_t *p_instance,
+                                                           const char *psz_audio_output,
+                                                           int i_device );
+
+/**
+ * Get id name of device
+ *
+ * \param p_instance libvlc instance
+ * \param psz_audio_output - name of audio output, \see libvlc_audio_output_t
+ * \param i_device device index
+ * \return id name of device, use for setting device, need to be free after use
+ */
+LIBVLC_API char * libvlc_audio_output_device_id( libvlc_instance_t *p_instance,
+                                                     const char *psz_audio_output,
+                                                     int i_device );
+
+/**
+ * Set audio output device. Changes are only effective after stop and play.
+ *
+ * \param p_mi media player
+ * \param psz_audio_output - name of audio output, \see libvlc_audio_output_t
+ * \param psz_device_id device
+ */
+LIBVLC_API void libvlc_audio_output_device_set( libvlc_media_player_t *p_mi,
+                                                    const char *psz_audio_output,
+                                                    const char *psz_device_id );
+
+/**
+ * Get current audio device type. Device type describes something like
+ * character of output sound - stereo sound, 2.1, 5.1 etc
+ *
+ * \param p_mi media player
+ * \return the audio devices type \see libvlc_audio_output_device_types_t
+ */
+LIBVLC_API int libvlc_audio_output_get_device_type( libvlc_media_player_t *p_mi );
+
+/**
+ * Set current audio device type.
+ *
+ * \param p_mi vlc instance
+ * \param device_type the audio device type,
+          according to \see libvlc_audio_output_device_types_t
+ */
+LIBVLC_API void libvlc_audio_output_set_device_type( libvlc_media_player_t *p_mi,
+                                                         int device_type );
+
+
+/**
+ * Toggle mute status.
+ *
+ * \param p_mi media player
+ */
+LIBVLC_API void libvlc_audio_toggle_mute( libvlc_media_player_t *p_mi );
+
+/**
+ * Get current mute status.
+ *
+ * \param p_mi media player
+ * \return the mute status (boolean)
+ *
+ * \libvlc_return_bool
+ */
+LIBVLC_API int libvlc_audio_get_mute( libvlc_media_player_t *p_mi );
+
+/**
+ * Set mute status.
+ *
+ * \param p_mi media player
+ * \param status If status is true then mute, otherwise unmute
+ */
+LIBVLC_API void libvlc_audio_set_mute( libvlc_media_player_t *p_mi, int status );
+
+/**
+ * Get current software audio volume.
+ *
+ * \param p_mi media player
+ * \return the software volume in percents
+ * (0 = mute, 100 = nominal / 0dB)
+ */
+LIBVLC_API int libvlc_audio_get_volume( libvlc_media_player_t *p_mi );
+
+/**
+ * Set current software audio volume.
+ *
+ * \param p_mi media player
+ * \param i_volume the volume in percents (0 = mute, 100 = 0dB)
+ * \return 0 if the volume was set, -1 if it was out of range
+ */
+LIBVLC_API int libvlc_audio_set_volume( libvlc_media_player_t *p_mi, int i_volume );
+
+/**
+ * Get number of available audio tracks.
+ *
+ * \param p_mi media player
+ * \return the number of available audio tracks (int), or -1 if unavailable
+ */
+LIBVLC_API int libvlc_audio_get_track_count( libvlc_media_player_t *p_mi );
+
+/**
+ * Get the description of available audio tracks.
+ *
+ * \param p_mi media player
+ * \return list with description of available audio tracks, or NULL
+ */
+LIBVLC_API libvlc_track_description_t *
+        libvlc_audio_get_track_description( libvlc_media_player_t *p_mi );
+
+/**
+ * Get current audio track.
+ *
+ * \param p_mi media player
+ * \return the audio track (int), or -1 if none.
+ */
+LIBVLC_API int libvlc_audio_get_track( libvlc_media_player_t *p_mi );
+
+/**
+ * Set current audio track.
+ *
+ * \param p_mi media player
+ * \param i_track the track (int)
+ * \return 0 on success, -1 on error
+ */
+LIBVLC_API int libvlc_audio_set_track( libvlc_media_player_t *p_mi, int i_track );
+
+/**
+ * Get current audio channel.
+ *
+ * \param p_mi media player
+ * \return the audio channel \see libvlc_audio_output_channel_t
+ */
+LIBVLC_API int libvlc_audio_get_channel( libvlc_media_player_t *p_mi );
+
+/**
+ * Set current audio channel.
+ *
+ * \param p_mi media player
+ * \param channel the audio channel, \see libvlc_audio_output_channel_t
+ * \return 0 on success, -1 on error
+ */
+LIBVLC_API int libvlc_audio_set_channel( libvlc_media_player_t *p_mi, int channel );
+
+/**
+ * Get current audio delay.
+ *
+ * \param p_mi media player
+ * \return the audio delay (microseconds)
+ * \version LibVLC 1.1.1 or later
+ */
+LIBVLC_API int64_t libvlc_audio_get_delay( libvlc_media_player_t *p_mi );
+
+/**
+ * Set current audio delay. The audio delay will be reset to zero each time the media changes.
+ *
+ * \param p_mi media player
+ * \param i_delay the audio delay (microseconds)
+ * \return 0 on success, -1 on error
+ * \version LibVLC 1.1.1 or later
+ */
+LIBVLC_API int libvlc_audio_set_delay( libvlc_media_player_t *p_mi, int64_t i_delay );
+
+/** @} audio */
+
+/** @} media_player */
+
+# ifdef __cplusplus
+}
+# endif
+
+#endif /* VLC_LIBVLC_MEDIA_PLAYER_H */

=== added file 'DivCity/DivCity/vlc/libvlc_structures.h'
--- DivCity/DivCity/vlc/libvlc_structures.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/libvlc_structures.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,76 @@
+/*****************************************************************************
+ * libvlc.h:  libvlc_* new external API structures
+ *****************************************************************************
+ * Copyright (C) 1998-2008 VLC authors and VideoLAN
+ * $Id $
+ *
+ * Authors: Filippo Carone <littlejohn@videolan.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef LIBVLC_STRUCTURES_H
+#define LIBVLC_STRUCTURES_H 1
+
+/**
+ * \file
+ * This file defines libvlc_* new external API structures
+ */
+
+#include <stdint.h>
+
+# ifdef __cplusplus
+extern "C" {
+# endif
+
+/**
+ * \ingroup libvlc_core
+ * @{
+ */
+
+/** This structure is opaque. It represents a libvlc instance */
+typedef struct libvlc_instance_t libvlc_instance_t;
+
+typedef int64_t libvlc_time_t;
+
+/**@} */
+
+/**
+ * \ingroup libvlc_log
+ * @{
+ */
+
+/** This structure is opaque. It represents a libvlc log instance */
+typedef struct libvlc_log_t libvlc_log_t;
+
+/** This structure is opaque. It represents a libvlc log iterator */
+typedef struct libvlc_log_iterator_t libvlc_log_iterator_t;
+
+typedef struct libvlc_log_message_t
+{
+    int         i_severity;   /* 0=INFO, 1=ERR, 2=WARN, 3=DBG */
+    const char *psz_type;     /* module type */
+    const char *psz_name;     /* module name */
+    const char *psz_header;   /* optional header */
+    const char *psz_message;  /* message */
+} libvlc_log_message_t;
+
+/**@} */
+
+# ifdef __cplusplus
+}
+# endif
+
+#endif

=== added file 'DivCity/DivCity/vlc/libvlc_version.h'
--- DivCity/DivCity/vlc/libvlc_version.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/libvlc_version.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,55 @@
+/*****************************************************************************
+ * libvlc_version.h
+ *****************************************************************************
+ * Copyright (C) 2010 RÃ©mi Denis-Courmont
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+/**
+ * \file
+ * This file defines version macros for LibVLC.
+ * Those macros are primilarly intended for conditional (pre)compilation.
+ * To get the run-time LibVLC version, use libvlc_get_version() instead
+ * (the run-time version may be more recent than build-time one, thanks to
+ * backward binary compatibility).
+ *
+ * \version This header file is available in LibVLC 1.1.4 and higher.
+ */
+
+#ifndef LIBVLC_VERSION_H
+# define LIBVLC_VERSION_H 1
+
+/** LibVLC major version number */
+# define LIBVLC_VERSION_MAJOR    (2)
+
+/** LibVLC minor version number */
+# define LIBVLC_VERSION_MINOR    (0)
+
+/** LibVLC revision */
+# define LIBVLC_VERSION_REVISION (4)
+
+# define LIBVLC_VERSION_EXTRA    (0)
+
+/** Makes a single integer from a LibVLC version numbers */
+# define LIBVLC_VERSION(maj,min,rev,extra) \
+         ((maj << 24) | (min << 16) | (rev << 8) | (extra))
+
+/** LibVLC full version as a single integer (for comparison) */
+# define LIBVLC_VERSION_INT \
+         LIBVLC_VERSION(LIBVLC_VERSION_MAJOR, LIBVLC_VERSION_MINOR, \
+                        LIBVLC_VERSION_REVISION, LIBVLC_VERSION_EXTRA)
+
+#endif

=== added file 'DivCity/DivCity/vlc/libvlc_vlm.h'
--- DivCity/DivCity/vlc/libvlc_vlm.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/libvlc_vlm.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,349 @@
+/*****************************************************************************
+ * libvlc_vlm.h:  libvlc_* new external API
+ *****************************************************************************
+ * Copyright (C) 1998-2008 VLC authors and VideoLAN
+ * $Id: 26e5cbb5ee7968a21520af0b8f553a4a117d4f99 $
+ *
+ * Authors: ClÃ©ment Stenac <zorglub@videolan.org>
+ *          Jean-Paul Saman <jpsaman _at_ m2x _dot_ nl>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef LIBVLC_VLM_H
+#define LIBVLC_VLM_H 1
+
+/**
+ * \file
+ * This file defines libvlc_vlm_* external API
+ */
+
+# ifdef __cplusplus
+extern "C" {
+# endif
+
+/*****************************************************************************
+ * VLM
+ *****************************************************************************/
+/** \defgroup libvlc_vlm LibVLC VLM
+ * \ingroup libvlc
+ * @{
+ */
+
+
+/**
+ * Release the vlm instance related to the given libvlc_instance_t
+ *
+ * \param p_instance the instance
+ */
+LIBVLC_API void libvlc_vlm_release( libvlc_instance_t *p_instance );
+
+/**
+ * Add a broadcast, with one input.
+ *
+ * \param p_instance the instance
+ * \param psz_name the name of the new broadcast
+ * \param psz_input the input MRL
+ * \param psz_output the output MRL (the parameter to the "sout" variable)
+ * \param i_options number of additional options
+ * \param ppsz_options additional options
+ * \param b_enabled boolean for enabling the new broadcast
+ * \param b_loop Should this broadcast be played in loop ?
+ * \return 0 on success, -1 on error
+ */
+LIBVLC_API int libvlc_vlm_add_broadcast( libvlc_instance_t *p_instance,
+                                             const char *psz_name, const char *psz_input,
+                                             const char *psz_output, int i_options,
+                                             const char * const* ppsz_options,
+                                             int b_enabled, int b_loop );
+
+/**
+ * Add a vod, with one input.
+ *
+ * \param p_instance the instance
+ * \param psz_name the name of the new vod media
+ * \param psz_input the input MRL
+ * \param i_options number of additional options
+ * \param ppsz_options additional options
+ * \param b_enabled boolean for enabling the new vod
+ * \param psz_mux the muxer of the vod media
+ * \return 0 on success, -1 on error
+ */
+LIBVLC_API int libvlc_vlm_add_vod( libvlc_instance_t * p_instance,
+                                       const char *psz_name, const char *psz_input,
+                                       int i_options, const char * const* ppsz_options,
+                                       int b_enabled, const char *psz_mux );
+
+/**
+ * Delete a media (VOD or broadcast).
+ *
+ * \param p_instance the instance
+ * \param psz_name the media to delete
+ * \return 0 on success, -1 on error
+ */
+LIBVLC_API int libvlc_vlm_del_media( libvlc_instance_t * p_instance,
+                                         const char *psz_name );
+
+/**
+ * Enable or disable a media (VOD or broadcast).
+ *
+ * \param p_instance the instance
+ * \param psz_name the media to work on
+ * \param b_enabled the new status
+ * \return 0 on success, -1 on error
+ */
+LIBVLC_API int libvlc_vlm_set_enabled( libvlc_instance_t *p_instance,
+                                           const char *psz_name, int b_enabled );
+
+/**
+ * Set the output for a media.
+ *
+ * \param p_instance the instance
+ * \param psz_name the media to work on
+ * \param psz_output the output MRL (the parameter to the "sout" variable)
+ * \return 0 on success, -1 on error
+ */
+LIBVLC_API int libvlc_vlm_set_output( libvlc_instance_t *p_instance,
+                                          const char *psz_name,
+                                          const char *psz_output );
+
+/**
+ * Set a media's input MRL. This will delete all existing inputs and
+ * add the specified one.
+ *
+ * \param p_instance the instance
+ * \param psz_name the media to work on
+ * \param psz_input the input MRL
+ * \return 0 on success, -1 on error
+ */
+LIBVLC_API int libvlc_vlm_set_input( libvlc_instance_t *p_instance,
+                                         const char *psz_name,
+                                         const char *psz_input );
+
+/**
+ * Add a media's input MRL. This will add the specified one.
+ *
+ * \param p_instance the instance
+ * \param psz_name the media to work on
+ * \param psz_input the input MRL
+ * \return 0 on success, -1 on error
+ */
+LIBVLC_API int libvlc_vlm_add_input( libvlc_instance_t *p_instance,
+                                         const char *psz_name,
+                                         const char *psz_input );
+
+/**
+ * Set a media's loop status.
+ *
+ * \param p_instance the instance
+ * \param psz_name the media to work on
+ * \param b_loop the new status
+ * \return 0 on success, -1 on error
+ */
+LIBVLC_API int libvlc_vlm_set_loop( libvlc_instance_t *p_instance,
+                                        const char *psz_name,
+                                        int b_loop );
+
+/**
+ * Set a media's vod muxer.
+ *
+ * \param p_instance the instance
+ * \param psz_name the media to work on
+ * \param psz_mux the new muxer
+ * \return 0 on success, -1 on error
+ */
+LIBVLC_API int libvlc_vlm_set_mux( libvlc_instance_t *p_instance,
+                                       const char *psz_name,
+                                       const char *psz_mux );
+
+/**
+ * Edit the parameters of a media. This will delete all existing inputs and
+ * add the specified one.
+ *
+ * \param p_instance the instance
+ * \param psz_name the name of the new broadcast
+ * \param psz_input the input MRL
+ * \param psz_output the output MRL (the parameter to the "sout" variable)
+ * \param i_options number of additional options
+ * \param ppsz_options additional options
+ * \param b_enabled boolean for enabling the new broadcast
+ * \param b_loop Should this broadcast be played in loop ?
+ * \return 0 on success, -1 on error
+ */
+LIBVLC_API int libvlc_vlm_change_media( libvlc_instance_t *p_instance,
+                                            const char *psz_name, const char *psz_input,
+                                            const char *psz_output, int i_options,
+                                            const char * const *ppsz_options,
+                                            int b_enabled, int b_loop );
+
+/**
+ * Play the named broadcast.
+ *
+ * \param p_instance the instance
+ * \param psz_name the name of the broadcast
+ * \return 0 on success, -1 on error
+ */
+LIBVLC_API int libvlc_vlm_play_media ( libvlc_instance_t *p_instance,
+                                           const char *psz_name );
+
+/**
+ * Stop the named broadcast.
+ *
+ * \param p_instance the instance
+ * \param psz_name the name of the broadcast
+ * \return 0 on success, -1 on error
+ */
+LIBVLC_API int libvlc_vlm_stop_media ( libvlc_instance_t *p_instance,
+                                           const char *psz_name );
+
+/**
+ * Pause the named broadcast.
+ *
+ * \param p_instance the instance
+ * \param psz_name the name of the broadcast
+ * \return 0 on success, -1 on error
+ */
+LIBVLC_API int libvlc_vlm_pause_media( libvlc_instance_t *p_instance,
+                                           const char *psz_name );
+
+/**
+ * Seek in the named broadcast.
+ *
+ * \param p_instance the instance
+ * \param psz_name the name of the broadcast
+ * \param f_percentage the percentage to seek to
+ * \return 0 on success, -1 on error
+ */
+LIBVLC_API int libvlc_vlm_seek_media( libvlc_instance_t *p_instance,
+                                          const char *psz_name,
+                                          float f_percentage );
+
+/**
+ * Return information about the named media as a JSON
+ * string representation.
+ *
+ * This function is mainly intended for debugging use,
+ * if you want programmatic access to the state of
+ * a vlm_media_instance_t, please use the corresponding
+ * libvlc_vlm_get_media_instance_xxx -functions.
+ * Currently there are no such functions available for
+ * vlm_media_t though.
+ *
+ * \param p_instance the instance
+ * \param psz_name the name of the media,
+ *      if the name is an empty string, all media is described
+ * \return string with information about named media, or NULL on error
+ */
+LIBVLC_API const char* libvlc_vlm_show_media( libvlc_instance_t *p_instance,
+                                                  const char *psz_name );
+
+/**
+ * Get vlm_media instance position by name or instance id
+ *
+ * \param p_instance a libvlc instance
+ * \param psz_name name of vlm media instance
+ * \param i_instance instance id
+ * \return position as float or -1. on error
+ */
+LIBVLC_API float libvlc_vlm_get_media_instance_position( libvlc_instance_t *p_instance,
+                                                             const char *psz_name,
+                                                             int i_instance );
+
+/**
+ * Get vlm_media instance time by name or instance id
+ *
+ * \param p_instance a libvlc instance
+ * \param psz_name name of vlm media instance
+ * \param i_instance instance id
+ * \return time as integer or -1 on error
+ */
+LIBVLC_API int libvlc_vlm_get_media_instance_time( libvlc_instance_t *p_instance,
+                                                       const char *psz_name,
+                                                       int i_instance );
+
+/**
+ * Get vlm_media instance length by name or instance id
+ *
+ * \param p_instance a libvlc instance
+ * \param psz_name name of vlm media instance
+ * \param i_instance instance id
+ * \return length of media item or -1 on error
+ */
+LIBVLC_API int libvlc_vlm_get_media_instance_length( libvlc_instance_t *p_instance,
+                                                         const char *psz_name,
+                                                         int i_instance );
+
+/**
+ * Get vlm_media instance playback rate by name or instance id
+ *
+ * \param p_instance a libvlc instance
+ * \param psz_name name of vlm media instance
+ * \param i_instance instance id
+ * \return playback rate or -1 on error
+ */
+LIBVLC_API int libvlc_vlm_get_media_instance_rate( libvlc_instance_t *p_instance,
+                                                       const char *psz_name,
+                                                       int i_instance );
+#if 0
+/**
+ * Get vlm_media instance title number by name or instance id
+ * \bug will always return 0
+ * \param p_instance a libvlc instance
+ * \param psz_name name of vlm media instance
+ * \param i_instance instance id
+ * \return title as number or -1 on error
+ */
+LIBVLC_API int libvlc_vlm_get_media_instance_title( libvlc_instance_t *,
+                                                        const char *, int );
+
+/**
+ * Get vlm_media instance chapter number by name or instance id
+ * \bug will always return 0
+ * \param p_instance a libvlc instance
+ * \param psz_name name of vlm media instance
+ * \param i_instance instance id
+ * \return chapter as number or -1 on error
+ */
+LIBVLC_API int libvlc_vlm_get_media_instance_chapter( libvlc_instance_t *,
+                                                          const char *, int );
+
+/**
+ * Is libvlc instance seekable ?
+ * \bug will always return 0
+ * \param p_instance a libvlc instance
+ * \param psz_name name of vlm media instance
+ * \param i_instance instance id
+ * \return 1 if seekable, 0 if not, -1 if media does not exist
+ */
+LIBVLC_API int libvlc_vlm_get_media_instance_seekable( libvlc_instance_t *,
+                                                           const char *, int );
+#endif
+/**
+ * Get libvlc_event_manager from a vlm media.
+ * The p_event_manager is immutable, so you don't have to hold the lock
+ *
+ * \param p_instance a libvlc instance
+ * \return libvlc_event_manager
+ */
+LIBVLC_API libvlc_event_manager_t *
+    libvlc_vlm_get_event_manager( libvlc_instance_t *p_instance );
+
+/** @} */
+
+# ifdef __cplusplus
+}
+# endif
+
+#endif /* <vlc/libvlc_vlm.h> */

=== added directory 'DivCity/DivCity/vlc/plugins'
=== added file 'DivCity/DivCity/vlc/plugins/vlc_about.h'
--- DivCity/DivCity/vlc/plugins/vlc_about.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_about.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,1115 @@
+/* Automatically generated file - DO NOT EDIT */
+static const char psz_license[] =
+"                    GNU GENERAL PUBLIC LICENSE\n"
+"                       Version 2, June 1991\n"
+"\n"
+" Copyright (C) 1989, 1991 Free Software Foundation, Inc.,\n"
+" 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n"
+" Everyone is permitted to copy and distribute verbatim copies\n"
+" of this license document, but changing it is not allowed.\n"
+"\n"
+"                            Preamble\n"
+"\n"
+"  The licenses for most software are designed to take away your\n"
+"freedom to share and change it.  By contrast, the GNU General Public\n"
+"License is intended to guarantee your freedom to share and change free\n"
+"software--to make sure the software is free for all its users.  This\n"
+"General Public License applies to most of the Free Software\n"
+"Foundation's software and to any other program whose authors commit to\n"
+"using it.  (Some other Free Software Foundation software is covered by\n"
+"the GNU Lesser General Public License instead.)  You can apply it to\n"
+"your programs, too.\n"
+"\n"
+"  When we speak of free software, we are referring to freedom, not\n"
+"price.  Our General Public Licenses are designed to make sure that you\n"
+"have the freedom to distribute copies of free software (and charge for\n"
+"this service if you wish), that you receive source code or can get it\n"
+"if you want it, that you can change the software or use pieces of it\n"
+"in new free programs; and that you know you can do these things.\n"
+"\n"
+"  To protect your rights, we need to make restrictions that forbid\n"
+"anyone to deny you these rights or to ask you to surrender the rights.\n"
+"These restrictions translate to certain responsibilities for you if you\n"
+"distribute copies of the software, or if you modify it.\n"
+"\n"
+"  For example, if you distribute copies of such a program, whether\n"
+"gratis or for a fee, you must give the recipients all the rights that\n"
+"you have.  You must make sure that they, too, receive or can get the\n"
+"source code.  And you must show them these terms so they know their\n"
+"rights.\n"
+"\n"
+"  We protect your rights with two steps: (1) copyright the software, and\n"
+"(2) offer you this license which gives you legal permission to copy,\n"
+"distribute and/or modify the software.\n"
+"\n"
+"  Also, for each author's protection and ours, we want to make certain\n"
+"that everyone understands that there is no warranty for this free\n"
+"software.  If the software is modified by someone else and passed on, we\n"
+"want its recipients to know that what they have is not the original, so\n"
+"that any problems introduced by others will not reflect on the original\n"
+"authors' reputations.\n"
+"\n"
+"  Finally, any free program is threatened constantly by software\n"
+"patents.  We wish to avoid the danger that redistributors of a free\n"
+"program will individually obtain patent licenses, in effect making the\n"
+"program proprietary.  To prevent this, we have made it clear that any\n"
+"patent must be licensed for everyone's free use or not licensed at all.\n"
+"\n"
+"  The precise terms and conditions for copying, distribution and\n"
+"modification follow.\n"
+"\n"
+"                    GNU GENERAL PUBLIC LICENSE\n"
+"   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n"
+"\n"
+"  0. This License applies to any program or other work which contains\n"
+"a notice placed by the copyright holder saying it may be distributed\n"
+"under the terms of this General Public License.  The \"Program\", below,\n"
+"refers to any such program or work, and a \"work based on the Program\"\n"
+"means either the Program or any derivative work under copyright law:\n"
+"that is to say, a work containing the Program or a portion of it,\n"
+"either verbatim or with modifications and/or translated into another\n"
+"language.  (Hereinafter, translation is included without limitation in\n"
+"the term \"modification\".)  Each licensee is addressed as \"you\".\n"
+"\n"
+"Activities other than copying, distribution and modification are not\n"
+"covered by this License; they are outside its scope.  The act of\n"
+"running the Program is not restricted, and the output from the Program\n"
+"is covered only if its contents constitute a work based on the\n"
+"Program (independent of having been made by running the Program).\n"
+"Whether that is true depends on what the Program does.\n"
+"\n"
+"  1. You may copy and distribute verbatim copies of the Program's\n"
+"source code as you receive it, in any medium, provided that you\n"
+"conspicuously and appropriately publish on each copy an appropriate\n"
+"copyright notice and disclaimer of warranty; keep intact all the\n"
+"notices that refer to this License and to the absence of any warranty;\n"
+"and give any other recipients of the Program a copy of this License\n"
+"along with the Program.\n"
+"\n"
+"You may charge a fee for the physical act of transferring a copy, and\n"
+"you may at your option offer warranty protection in exchange for a fee.\n"
+"\n"
+"  2. You may modify your copy or copies of the Program or any portion\n"
+"of it, thus forming a work based on the Program, and copy and\n"
+"distribute such modifications or work under the terms of Section 1\n"
+"above, provided that you also meet all of these conditions:\n"
+"\n"
+"    a) You must cause the modified files to carry prominent notices\n"
+"    stating that you changed the files and the date of any change.\n"
+"\n"
+"    b) You must cause any work that you distribute or publish, that in\n"
+"    whole or in part contains or is derived from the Program or any\n"
+"    part thereof, to be licensed as a whole at no charge to all third\n"
+"    parties under the terms of this License.\n"
+"\n"
+"    c) If the modified program normally reads commands interactively\n"
+"    when run, you must cause it, when started running for such\n"
+"    interactive use in the most ordinary way, to print or display an\n"
+"    announcement including an appropriate copyright notice and a\n"
+"    notice that there is no warranty (or else, saying that you provide\n"
+"    a warranty) and that users may redistribute the program under\n"
+"    these conditions, and telling the user how to view a copy of this\n"
+"    License.  (Exception: if the Program itself is interactive but\n"
+"    does not normally print such an announcement, your work based on\n"
+"    the Program is not required to print an announcement.)\n"
+"\n"
+"These requirements apply to the modified work as a whole.  If\n"
+"identifiable sections of that work are not derived from the Program,\n"
+"and can be reasonably considered independent and separate works in\n"
+"themselves, then this License, and its terms, do not apply to those\n"
+"sections when you distribute them as separate works.  But when you\n"
+"distribute the same sections as part of a whole which is a work based\n"
+"on the Program, the distribution of the whole must be on the terms of\n"
+"this License, whose permissions for other licensees extend to the\n"
+"entire whole, and thus to each and every part regardless of who wrote it.\n"
+"\n"
+"Thus, it is not the intent of this section to claim rights or contest\n"
+"your rights to work written entirely by you; rather, the intent is to\n"
+"exercise the right to control the distribution of derivative or\n"
+"collective works based on the Program.\n"
+"\n"
+"In addition, mere aggregation of another work not based on the Program\n"
+"with the Program (or with a work based on the Program) on a volume of\n"
+"a storage or distribution medium does not bring the other work under\n"
+"the scope of this License.\n"
+"\n"
+"  3. You may copy and distribute the Program (or a work based on it,\n"
+"under Section 2) in object code or executable form under the terms of\n"
+"Sections 1 and 2 above provided that you also do one of the following:\n"
+"\n"
+"    a) Accompany it with the complete corresponding machine-readable\n"
+"    source code, which must be distributed under the terms of Sections\n"
+"    1 and 2 above on a medium customarily used for software interchange; or,\n"
+"\n"
+"    b) Accompany it with a written offer, valid for at least three\n"
+"    years, to give any third party, for a charge no more than your\n"
+"    cost of physically performing source distribution, a complete\n"
+"    machine-readable copy of the corresponding source code, to be\n"
+"    distributed under the terms of Sections 1 and 2 above on a medium\n"
+"    customarily used for software interchange; or,\n"
+"\n"
+"    c) Accompany it with the information you received as to the offer\n"
+"    to distribute corresponding source code.  (This alternative is\n"
+"    allowed only for noncommercial distribution and only if you\n"
+"    received the program in object code or executable form with such\n"
+"    an offer, in accord with Subsection b above.)\n"
+"\n"
+"The source code for a work means the preferred form of the work for\n"
+"making modifications to it.  For an executable work, complete source\n"
+"code means all the source code for all modules it contains, plus any\n"
+"associated interface definition files, plus the scripts used to\n"
+"control compilation and installation of the executable.  However, as a\n"
+"special exception, the source code distributed need not include\n"
+"anything that is normally distributed (in either source or binary\n"
+"form) with the major components (compiler, kernel, and so on) of the\n"
+"operating system on which the executable runs, unless that component\n"
+"itself accompanies the executable.\n"
+"\n"
+"If distribution of executable or object code is made by offering\n"
+"access to copy from a designated place, then offering equivalent\n"
+"access to copy the source code from the same place counts as\n"
+"distribution of the source code, even though third parties are not\n"
+"compelled to copy the source along with the object code.\n"
+"\n"
+"  4. You may not copy, modify, sublicense, or distribute the Program\n"
+"except as expressly provided under this License.  Any attempt\n"
+"otherwise to copy, modify, sublicense or distribute the Program is\n"
+"void, and will automatically terminate your rights under this License.\n"
+"However, parties who have received copies, or rights, from you under\n"
+"this License will not have their licenses terminated so long as such\n"
+"parties remain in full compliance.\n"
+"\n"
+"  5. You are not required to accept this License, since you have not\n"
+"signed it.  However, nothing else grants you permission to modify or\n"
+"distribute the Program or its derivative works.  These actions are\n"
+"prohibited by law if you do not accept this License.  Therefore, by\n"
+"modifying or distributing the Program (or any work based on the\n"
+"Program), you indicate your acceptance of this License to do so, and\n"
+"all its terms and conditions for copying, distributing or modifying\n"
+"the Program or works based on it.\n"
+"\n"
+"  6. Each time you redistribute the Program (or any work based on the\n"
+"Program), the recipient automatically receives a license from the\n"
+"original licensor to copy, distribute or modify the Program subject to\n"
+"these terms and conditions.  You may not impose any further\n"
+"restrictions on the recipients' exercise of the rights granted herein.\n"
+"You are not responsible for enforcing compliance by third parties to\n"
+"this License.\n"
+"\n"
+"  7. If, as a consequence of a court judgment or allegation of patent\n"
+"infringement or for any other reason (not limited to patent issues),\n"
+"conditions are imposed on you (whether by court order, agreement or\n"
+"otherwise) that contradict the conditions of this License, they do not\n"
+"excuse you from the conditions of this License.  If you cannot\n"
+"distribute so as to satisfy simultaneously your obligations under this\n"
+"License and any other pertinent obligations, then as a consequence you\n"
+"may not distribute the Program at all.  For example, if a patent\n"
+"license would not permit royalty-free redistribution of the Program by\n"
+"all those who receive copies directly or indirectly through you, then\n"
+"the only way you could satisfy both it and this License would be to\n"
+"refrain entirely from distribution of the Program.\n"
+"\n"
+"If any portion of this section is held invalid or unenforceable under\n"
+"any particular circumstance, the balance of the section is intended to\n"
+"apply and the section as a whole is intended to apply in other\n"
+"circumstances.\n"
+"\n"
+"It is not the purpose of this section to induce you to infringe any\n"
+"patents or other property right claims or to contest validity of any\n"
+"such claims; this section has the sole purpose of protecting the\n"
+"integrity of the free software distribution system, which is\n"
+"implemented by public license practices.  Many people have made\n"
+"generous contributions to the wide range of software distributed\n"
+"through that system in reliance on consistent application of that\n"
+"system; it is up to the author/donor to decide if he or she is willing\n"
+"to distribute software through any other system and a licensee cannot\n"
+"impose that choice.\n"
+"\n"
+"This section is intended to make thoroughly clear what is believed to\n"
+"be a consequence of the rest of this License.\n"
+"\n"
+"  8. If the distribution and/or use of the Program is restricted in\n"
+"certain countries either by patents or by copyrighted interfaces, the\n"
+"original copyright holder who places the Program under this License\n"
+"may add an explicit geographical distribution limitation excluding\n"
+"those countries, so that distribution is permitted only in or among\n"
+"countries not thus excluded.  In such case, this License incorporates\n"
+"the limitation as if written in the body of this License.\n"
+"\n"
+"  9. The Free Software Foundation may publish revised and/or new versions\n"
+"of the General Public License from time to time.  Such new versions will\n"
+"be similar in spirit to the present version, but may differ in detail to\n"
+"address new problems or concerns.\n"
+"\n"
+"Each version is given a distinguishing version number.  If the Program\n"
+"specifies a version number of this License which applies to it and \"any\n"
+"later version\", you have the option of following the terms and conditions\n"
+"either of that version or of any later version published by the Free\n"
+"Software Foundation.  If the Program does not specify a version number of\n"
+"this License, you may choose any version ever published by the Free Software\n"
+"Foundation.\n"
+"\n"
+"  10. If you wish to incorporate parts of the Program into other free\n"
+"programs whose distribution conditions are different, write to the author\n"
+"to ask for permission.  For software which is copyrighted by the Free\n"
+"Software Foundation, write to the Free Software Foundation; we sometimes\n"
+"make exceptions for this.  Our decision will be guided by the two goals\n"
+"of preserving the free status of all derivatives of our free software and\n"
+"of promoting the sharing and reuse of software generally.\n"
+"\n"
+"                            NO WARRANTY\n"
+"\n"
+"  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\n"
+"FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN\n"
+"OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES\n"
+"PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\n"
+"OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n"
+"MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS\n"
+"TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE\n"
+"PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\n"
+"REPAIR OR CORRECTION.\n"
+"\n"
+"  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\n"
+"WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\n"
+"REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\n"
+"INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING\n"
+"OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\n"
+"TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\n"
+"YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\n"
+"PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\n"
+"POSSIBILITY OF SUCH DAMAGES.\n"
+"\n"
+"                     END OF TERMS AND CONDITIONS\n"
+"\n"
+"            How to Apply These Terms to Your New Programs\n"
+"\n"
+"  If you develop a new program, and you want it to be of the greatest\n"
+"possible use to the public, the best way to achieve this is to make it\n"
+"free software which everyone can redistribute and change under these terms.\n"
+"\n"
+"  To do so, attach the following notices to the program.  It is safest\n"
+"to attach them to the start of each source file to most effectively\n"
+"convey the exclusion of warranty; and each file should have at least\n"
+"the \"copyright\" line and a pointer to where the full notice is found.\n"
+"\n"
+"    <one line to give the program's name and a brief idea of what it does.>\n"
+"    Copyright (C) <year>  <name of author>\n"
+"\n"
+"    This program is free software; you can redistribute it and/or modify\n"
+"    it under the terms of the GNU General Public License as published by\n"
+"    the Free Software Foundation; either version 2 of the License, or\n"
+"    (at your option) any later version.\n"
+"\n"
+"    This program is distributed in the hope that it will be useful,\n"
+"    but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
+"    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
+"    GNU General Public License for more details.\n"
+"\n"
+"    You should have received a copy of the GNU General Public License along\n"
+"    with this program; if not, write to the Free Software Foundation, Inc.,\n"
+"    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n"
+"\n"
+"Also add information on how to contact you by electronic and paper mail.\n"
+"\n"
+"If the program is interactive, make it output a short notice like this\n"
+"when it starts in an interactive mode:\n"
+"\n"
+"    Gnomovision version 69, Copyright (C) year name of author\n"
+"    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n"
+"    This is free software, and you are welcome to redistribute it\n"
+"    under certain conditions; type `show c' for details.\n"
+"\n"
+"The hypothetical commands `show w' and `show c' should show the appropriate\n"
+"parts of the General Public License.  Of course, the commands you use may\n"
+"be called something other than `show w' and `show c'; they could even be\n"
+"mouse-clicks or menu items--whatever suits your program.\n"
+"\n"
+"You should also get your employer (if you work as a programmer) or your\n"
+"school, if any, to sign a \"copyright disclaimer\" for the program, if\n"
+"necessary.  Here is a sample; alter the names:\n"
+"\n"
+"  Yoyodyne, Inc., hereby disclaims all copyright interest in the program\n"
+"  `Gnomovision' (which makes passes at compilers) written by James Hacker.\n"
+"\n"
+"  <signature of Ty Coon>, 1 April 1989\n"
+"  Ty Coon, President of Vice\n"
+"\n"
+"This General Public License does not permit incorporating your program into\n"
+"proprietary programs.  If your program is a subroutine library, you may\n"
+"consider it more useful to permit linking proprietary applications with the\n"
+"library.  If this is what you want to do, use the GNU Lesser General\n"
+"Public License instead of this License.\n"
+;
+static const char psz_thanks[] =
+"The VideoLAN team would like to thank the following donators:\n"
+"\n"
+"Julian Cain, who made a $1000 donation\n"
+"The French website MacBidouille gave â‚¬500 to help us buy a PowerMac G5\n"
+"The French magazine Ã  vos MAC gave â‚¬500 to help us buy a PowerMac G5\n"
+"Laurent Dupuy, who made a â‚¬540 donation\n"
+"The French company Cybervia (Actech) gave â‚¬2000 to pay for webserver hosting\n"
+"Dennis Perov - Hardware donation\n"
+"\n"
+"...the following active members of our user's community:\n"
+"\n"
+"Alan Wright\n"
+"David J LaBarre \"DJ\"\n"
+"Eric Adler\n"
+"Julien Bouquillon\n"
+"\n"
+"...and code auditors and testers:\n"
+"\n"
+"David Thiel\n"
+"Philippe A. aka \"LotesdelÃ¨re\"\n"
+"Sebastien Chaumat\n"
+"\n"
+"Some VLC plugins use external libraries and makes extensive use of the\n"
+"following persons' or companies' code:\n"
+"\n"
+"FFmpeg - Copyright (c) 2000-2010 the FFmpeg developers\n"
+"liba52 - Aaron Holtzman & Michel Lespinasse, et al.\n"
+"FAAD2 - \"Code from FAAD2 is copyright (c) Nero AG, www.nero.com\"\n"
+"FAAC - Menno Bakker, Krzysztof Nikiel & The individual contributors\n"
+"libmpeg2 - Aaron Holtzman & Michel Lespinasse, et al.\n"
+"ogg, theora, vorbis - Monty & the Xiph.org Foundation\n"
+"flac - Josh Coalson et al.\n"
+"Sparkle â€” Andy Matuschak et al.\n"
+;
+static const char psz_authors[] =
+"The VideoLAN team would like to acknowledge the following contributors:\n"
+"\n"
+"Programming\n"
+"-----------\n"
+"RÃ©mi Denis-Courmont\n"
+"Jean-Baptiste Kempf\n"
+"Laurent Aimar\n"
+"Gildas Bazin\n"
+"Pierre d'Herbemont\n"
+"RafaÃ«l CarrÃ©\n"
+"Felix Paul KÃ¼hne\n"
+"RÃ©mi Duraffort\n"
+"Derk-Jan Hartman\n"
+"Antoine Cellerier\n"
+"Samuel Hocevar\n"
+"Jean-Paul Saman\n"
+"Christophe Mutricy\n"
+"ClÃ©ment Stenac\n"
+"Christophe Massiot\n"
+"Ilkka Ollakka\n"
+"Pierre Ynard\n"
+"Damien Fouilleul\n"
+"Sigmund Augdal Helberg\n"
+"Erwan Tulou\n"
+"Olivier TeuliÃ¨re\n"
+"Cyril Deguet\n"
+"Eric Petit\n"
+"Filippo Carone\n"
+"Rocky Bernstein\n"
+"FranÃ§ois Cartegnie\n"
+"Olivier Aubert\n"
+"Jakob Leben\n"
+"Benjamin Pracht\n"
+"Pavlov Konstantin\n"
+"Jean-Philippe AndrÃ©\n"
+"Hugo BeauzÃ©e-Luyssen\n"
+"Steve Lhomme\n"
+"StÃ©phane Borel\n"
+"JP Dinger\n"
+"Geoffroy Couprie\n"
+"David Fuhrmann\n"
+"Marian ÄŽurkoviÄ\n"
+"Yoann Peronneau\n"
+"Jon Lech Johansen\n"
+"SÃ©bastien Escudier\n"
+"Dennis van Amerongen\n"
+"JÃ©rÃ´me Decoodt\n"
+"Faustino Osuna\n"
+"LoÃ¯c Minier\n"
+"Ludovic Fauvet\n"
+"KO Myung-Hun\n"
+"David Flynn\n"
+"Mark Moriarty\n"
+"Fabio Ritrovato\n"
+"Mirsal Ennaime\n"
+"Tony Castley\n"
+"Srikanth Raju\n"
+"Kaarlo Raiha\n"
+"Michel Kaempf\n"
+"Jean-Marc Dressler\n"
+"Johan Bilien\n"
+"Vincent Seguin\n"
+"Martin StorsjÃ¶\n"
+"Simon Latapie\n"
+"Bernie Purcell\n"
+"Henri Fallon\n"
+"Denis Charmet\n"
+"Emmanuel Puig\n"
+"Sebastien Zwickert\n"
+"Edward Wang\n"
+"Adrien Maglo\n"
+"Renaud Dartus\n"
+"Alexis de Lattre\n"
+"Vincent Penquerc'h\n"
+"Arnaud de Bossoreille de Ribou\n"
+"Mohammed AdnÃ¨ne Trojette\n"
+"Boris DorÃ¨s\n"
+"Jai Menon\n"
+"Anil Daoud\n"
+"Pierre Baillet\n"
+"Daniel Mierswa\n"
+"Dominique Leuenberger\n"
+"Rob Jonson\n"
+"Andre Pang\n"
+"Christoph Miebach\n"
+"Akash Mehrotra\n"
+"AndrÃ© Weber\n"
+"Anthony Loiseau\n"
+"Lukas Durfina\n"
+"Xavier Marchesini\n"
+"Cyril MathÃ©\n"
+"Ã‰ric Lassauge\n"
+"Juha Jeronen\n"
+"Juho VÃ¤hÃ¤-Herttua\n"
+"Ken Self\n"
+"Richard Hosking\n"
+"Alexis Ballier\n"
+"Marc Ariberti\n"
+"Benoit Steiner\n"
+"Michel Lespinasse\n"
+"Naohiro Koriyama\n"
+"Carlo CalabrÃ²\n"
+"Nicolas Chauvet\n"
+"Cheng Sun\n"
+"Alexey Sokolov\n"
+"Basos G\n"
+"Brad Smith\n"
+"Philippe Morin\n"
+"Tobias GÃ¼ntner\n"
+"Vicente Jimenez Aguilar\n"
+"Yuval Tze\n"
+"Brendon Justin\n"
+"Yves Duret\n"
+"FrÃ©dÃ©ric Yhuel\n"
+"Michael Hanselmann\n"
+"Damien Lucas\n"
+"Richard Shepherd\n"
+"SÃ©bastien Toque\n"
+"Alexander Lakhin\n"
+"Benjamin Drung\n"
+"GaÃ«l Hendryckx\n"
+"Grigori Goronzy\n"
+"Stephan Assmus\n"
+"Adrien Grand\n"
+"Colin Guthrie\n"
+"David Menestrina\n"
+"Dominique Martinet\n"
+"Jason Luka\n"
+"Luc Saillard\n"
+"Pankaj Yadav\n"
+"Ramiro Polla\n"
+"Steinar H. Gunderson\n"
+"Can Wu\n"
+"Christophe Courtaut\n"
+"Hannes Domani\n"
+"Manol Manolov\n"
+"Antoine Lejeune\n"
+"Arnaud Schauly\n"
+"Branko Kokanovic\n"
+"Dylan Yudaken\n"
+"Florian G. Pflug\n"
+"G Finch\n"
+"Keary Griffin\n"
+"Konstanty Bialkowski\n"
+"Przemyslaw Fiala\n"
+"Tanguy Krotoff\n"
+"David Kaplan\n"
+"Devin Heitmueller\n"
+"Eugenio Jarosiewicz\n"
+"Fabian Keil\n"
+"Guillaume Poussel\n"
+"Justus Piater\n"
+"Luca Barbato\n"
+"Martin T. H. Sandsmark\n"
+"Rune Botten\n"
+"SÃ¸ren BÃ¸g\n"
+"Toralf Niebuhr\n"
+"Austin Burrow\n"
+"Bill C. Riemers\n"
+"Casian Andrei\n"
+"Chris Smowton\n"
+"Colin Delacroix\n"
+"Cristian Maglie\n"
+"Elminster2031\n"
+"FranÃ§ois Revol\n"
+"Jakub Wieczorek\n"
+"John Peterson\n"
+"Martin Briza\n"
+"Mike Houben\n"
+"Romain Goyet\n"
+"Rui Zhang\n"
+"Adrian Yanes\n"
+"Arai/Fujisawa Tooru\n"
+"AurÃ©lien Nephtali\n"
+"Barry Wardell\n"
+"Ben Hutchings\n"
+"Besnard Jean-Baptiste\n"
+"Brian Weaver\n"
+"Clement Chesnin\n"
+"Jonathan Rosser\n"
+"Joris van Rooij\n"
+"Kaloyan Kovachev\n"
+"Katsushi Kobayashi\n"
+"Loren Merritt\n"
+"Maciej Blizinski\n"
+"Mark Bidewell\n"
+"Mark Hassman\n"
+"Michael Feurstein\n"
+"Miguel Angel Cabrera Moya\n"
+"Ming Hu\n"
+"Niles Bindel\n"
+"Scott Caudle\n"
+"Sean Robinson\n"
+"Simon Hailes\n"
+"Thierry Reding\n"
+"Timothy B. Terriberry\n"
+"Xavier Martin\n"
+"Alex Converse\n"
+"Alexander Bethke\n"
+"Andres Krapf\n"
+"Andri PÃ¡lsson\n"
+"Andy Chenee\n"
+"Anuradha Suraparaju\n"
+"Benjamin Poulain\n"
+"Brieuc Jeunhomme\n"
+"Chris Clayton\n"
+"Christopher Mueller\n"
+"CÃ©dric Cocquebert\n"
+"Danny Wood\n"
+"David K\n"
+"Edouard Gomez\n"
+"Emmanuel de Roux\n"
+"GBX\n"
+"Georgi Chorbadzhiyski\n"
+"Jan Winter\n"
+"Jean-FranÃ§ois Massol\n"
+"Jean-Philippe Grimaldi\n"
+"John Freed\n"
+"Jon Stacey\n"
+"Kai Lauterbach\n"
+"Konstantin Bogdanov\n"
+"Kuan-Chung Chiu\n"
+"Mark Lee\n"
+"Matthias Dahl\n"
+"Michael McEll\n"
+"Michael Ploujnikov\n"
+"Mike Schrag\n"
+"Niklas Hayer\n"
+"Olivier Gambier\n"
+"Paul Corke\n"
+"Ron Frederick\n"
+"Ronald Wright\n"
+"Rov Juvano\n"
+"Sabourin Gilles\n"
+"Sam Lade\n"
+"Sasha Koruga\n"
+"Sreng Jean\n"
+"Sven Petai\n"
+"Tomer Barletz\n"
+"Tristan Leteurtre\n"
+"Wang Bo\n"
+"Zoran Turalija\n"
+"maxime Ripard\n"
+"xxcv\n"
+"Adam Hoka\n"
+"Adrian Knoth\n"
+"Adrien Cunin\n"
+"Alan Fischer\n"
+"Alex Helfet\n"
+"Alexandre Ferreira\n"
+"Alina Friedrichsen\n"
+"An L. Ber\n"
+"Andreas Schlick\n"
+"Andrey Makhnutin\n"
+"Arnaud Vallat\n"
+"Ashok Bhat\n"
+"Austin English\n"
+"Baptiste Coudurier\n"
+"Benoit Calvez\n"
+"BjÃ¶rn Stenberg\n"
+"Blake Livingston\n"
+"Brandon Brooks\n"
+"Brian Johnson\n"
+"Brian Kurle\n"
+"Chris White\n"
+"Christian Masus\n"
+"Christoph Seibert\n"
+"Christopher Key\n"
+"Christopher Rath\n"
+"Claudio Ortelli\n"
+"Clement Lecigne\n"
+"ClÃ©ment Lecigne\n"
+"Cody Russell\n"
+"Cristian Morales Vega\n"
+"Dan Rosenberg\n"
+"Daniel Marth\n"
+"Daniel Tisza\n"
+"Detlef Schroeder\n"
+"Diego Fernando Nieto\n"
+"Dominik 'Rathann' Mierzejewski\n"
+"Edward Sheldrake\n"
+"Elliot Murphy\n"
+"Eren Inan Canpolat\n"
+"Ernest E. Teem III\n"
+"Etienne Membrives\n"
+"Fargier Sylvain\n"
+"Fathi Boudra\n"
+"Felix Geyer\n"
+"Filipe Azevedo\n"
+"Florian Hubold\n"
+"Frank Enderle\n"
+"Frode TennebÃ¸\n"
+"FrÃ©dÃ©ric Crozat\n"
+"Gaurav Narula\n"
+"Georg Seifert\n"
+"Geraud CONTINSOUZAS\n"
+"Gertjan Van Droogenbroeck\n"
+"Gilles Chanteperdrix\n"
+"Greg Farrell\n"
+"Gregory Maxwell\n"
+"Gwenole Beauchesne\n"
+"GÃ¶tz Waschk\n"
+"Hans-Kristian Arntzen\n"
+"Harry Sintonen\n"
+"Iain Wade\n"
+"Ibraheem Paredath\n"
+"James Bond\n"
+"James Turner\n"
+"Janne KujanpÃ¤Ã¤\n"
+"Jarmo Torvinen\n"
+"Jason Scheunemann\n"
+"Jeff Lu\n"
+"Jeroen Ost\n"
+"Joe Taber\n"
+"Johann Ransay\n"
+"Johannes WeiÃŸl\n"
+"John Hendrikx\n"
+"John Stebbins\n"
+"Jonas Gehring\n"
+"Joseph S. Atkinson\n"
+"Julien / Gellule\n"
+"Julien Humbert\n"
+"Kamil Baldyga\n"
+"Kamil Klimek\n"
+"Karlheinz Wohlmuth\n"
+"Kelly Anderson\n"
+"Kevin DuBois\n"
+"Lari Natri\n"
+"Lorenzo Pistone\n"
+"Lucas C. Villa Real\n"
+"LukÃ¡Å¡ LalinskÃ½\n"
+"Mal Graty\n"
+"Malte Tancred\n"
+"Martin PÃ¶hlmann\n"
+"Marton Balint\n"
+"Mathew King\n"
+"Mathieu Sonet\n"
+"Matthew A. Townsend\n"
+"Matthias Bauer\n"
+"Mika Tiainen\n"
+"Mike Cardillo\n"
+"Mounir Lamouri (volkmar)\n"
+"Natanael Copa\n"
+"Nathan Phillip Brink\n"
+"Nick Briggs\n"
+"Nick Pope\n"
+"Peter Bak Nielsen\n"
+"Phil Roffe and David Grellscheid\n"
+"Pierre Souchay\n"
+"Piotr Fusik\n"
+"PÃ¡draig Brady\n"
+"R.M\n"
+"Ralph Giles\n"
+"Robert Jedrzejczyk\n"
+"Robert Paciorek\n"
+"Rolf Ahrenberg\n"
+"Roman Pen\n"
+"Ruud Althuizen\n"
+"Samuli Suominen\n"
+"Scott Lyons\n"
+"Sebastian Birk\n"
+"Sergey Puzanov\n"
+"Sharad Dixit\n"
+"Song Ye Wen\n"
+"Stephan Krempel\n"
+"Steven Kramer\n"
+"Steven Sheehy\n"
+"Sveinung Kvilhaugsvik\n"
+"Sylvain Cadhillac\n"
+"Theron Lewis\n"
+"Thijs Alkemade\n"
+"Timo Paulssen\n"
+"Tomasen\n"
+"Tony Vankrunkelsven\n"
+"Tristan Heaven\n"
+"Varphone Wong\n"
+"Yannick BrÃ©hon\n"
+"Yavor Doganov\n"
+"Yohann Martineau\n"
+"dharani.prabhu.s\n"
+"suheaven\n"
+"wucan\n"
+"ê¹€ì •ì€\n"
+"Adam Sampson\n"
+"Alexander Gall\n"
+"Alex Antropoff\n"
+"Alexis Guillard\n"
+"Alex Izvorski\n"
+"Amir Gouini\n"
+"Andrea Guzzo\n"
+"Andrew Flintham\n"
+"Andrew Zaikin\n"
+"Andy Lindsay\n"
+"Arkadiusz Miskiewicz\n"
+"Arnaud Gomes-do-Vale\n"
+"Arwed v. Merkatz\n"
+"Barak Ori\n"
+"Basil Achermann\n"
+"Benjamin Mironer\n"
+"Bill\n"
+"Bob Maguire\n"
+"Brian C. Wiles\n"
+"Brian Raymond\n"
+"Brian Robb\n"
+"Carsten GottbehÃ¼t\n"
+"Carsten Haitzler\n"
+"Charles Hordis\n"
+"Chris Clepper\n"
+"Christian Henz\n"
+"Christof Baumgaertner\n"
+"Christophe Burgalat\n"
+"Christopher Johnson\n"
+"Cian Duffy\n"
+"Colin Simmonds\n"
+"Damian Ivereigh\n"
+"Daniel Fischer\n"
+"Daniel StrÃ¤nger\n"
+"Danko Dolch\n"
+"Dennis Lou\n"
+"Dermot McGahon\n"
+"Diego Petteno\n"
+"Douglas West\n"
+"Dugal Harris\n"
+"Emmanuel Blindauer\n"
+"Enrico Gueli\n"
+"Enrique Osuna\n"
+"Eren TÃ¼rkay\n"
+"Eric Dudiak\n"
+"Espen Skoglund\n"
+"Ethan C. Baldridge\n"
+"FranÃ§ois Seingier\n"
+"Frans van Veen\n"
+"FrÃ©dÃ©ric Ruget\n"
+"Gerald Hansink\n"
+"Gisle Vanem\n"
+"Glen Gray\n"
+"Goetz Waschk\n"
+"Gregory Hazel\n"
+"Gustaf Neumann\n"
+"Hang Su\n"
+"Hans Lambermont\n"
+"Hans-Peter Jansen\n"
+"Harris Dugal\n"
+"Heiko Panther\n"
+"Igor Helman\n"
+"Isaac Osunkunle\n"
+"Jan David Mol\n"
+"Jan Gerber\n"
+"Jan Van Boghout\n"
+"Jasper Alias\n"
+"Jean-Alexis Montignies\n"
+"Jean-Baptiste Le Stang\n"
+"Jeffrey Baker\n"
+"Jeroen Massar\n"
+"JÃ©rÃ´me Guilbaud\n"
+"Johannes Buchner\n"
+"Johen Michael Zorko\n"
+"Johnathan Rosser\n"
+"John Dalgliesh\n"
+"John Paul Lorenti\n"
+"JÃ¶rg\n"
+"Joseph Tulou\n"
+"Julien Blache\n"
+"Julien Plissonneau DuquÃ¨ne\n"
+"Julien Robert\n"
+"Kenneth Ostby\n"
+"Kenneth Self\n"
+"Kevin H. Patterson\n"
+"Koehler, Vitally\n"
+"K. Staring\n"
+"Lahiru Lakmal Priyadarshana\n"
+"Laurent Mutricy\n"
+"Leo Spalteholz\n"
+"Loox Thefuture\n"
+"Marc Nolette\n"
+"Marco Munderloh\n"
+"Mark Gritter\n"
+"Markus Kern\n"
+"Markus Kuespert\n"
+"Martin Hamrle\n"
+"Martin Kahr\n"
+"Mateus Krepsky Ludwich\n"
+"Mathias Kretschmer\n"
+"Mats Rojestal\n"
+"Matthias P. Nowak\n"
+"Matthieu Lochegnies\n"
+"Michael Mondragon\n"
+"Michael S. Feurstein\n"
+"Michel Lanners\n"
+"Mickael Hoerdt\n"
+"Miguel Angel Cabrera\n"
+"Mikko Hirvonen\n"
+"Moritz Bunkus\n"
+"Nilmoni Deb\n"
+"Olivier Houchard\n"
+"Olivier Pomel\n"
+"Ondrej Kuda aka Albert\n"
+"Ã˜yvind Kolbu\n"
+"Pascal Levesque\n"
+"Patrick Horn\n"
+"Patrick McLean\n"
+"Pauline Castets\n"
+"Paul Mackerras\n"
+"Peter Surda\n"
+"Petr Vacek\n"
+"Philippe Van Hecke\n"
+"Pierre-Luc Beaudoin\n"
+"Pierre Marc Dumuid\n"
+"RÃ©gis Duchesne\n"
+"Remco Poortinga\n"
+"Rene Gollent\n"
+"Rob Casey\n"
+"Robson Braga Araujo\n"
+"Roine Gustafsson\n"
+"Roman Bednarek\n"
+"Rudolf Cornelissen\n"
+"SaÅ¡o Kiselkov\n"
+"Sebastian Jenny\n"
+"Shane Harper\n"
+"StefÃ¡n Freyr StefÃ¡nsson\n"
+"Steve Brown\n"
+"Steven M. Schultz\n"
+"Tapio Hiltunen\n"
+"Thomas L. Wood\n"
+"Thomas MÃ¼hlgrabner\n"
+"Thomas Parmelan\n"
+"Tim 'O Callagha\n"
+"Tim Schuerewegen\n"
+"Tong Ka Man\n"
+"Torsten Spindler\n"
+"Udo Richter\n"
+"Vincent Dimar\n"
+"Vincent Penne\n"
+"Vitalijus Slavinskas\n"
+"Vitaly V. Bursov\n"
+"Vladimir Chernyshov\n"
+"Wade Majors\n"
+"Wallace Wadge\n"
+"Watanabe Go\n"
+"William Hawkins\n"
+"Xavier Maillard\n"
+"Ye zhang\n"
+"Yuehua Zhao\n"
+"\n"
+"Artwork\n"
+"-------\n"
+"Damien Erambert\n"
+"Daniel Dreibrodt, aka aLtgLasS\n"
+"David Weber\n"
+"Davor Orel\n"
+"Dominic Spitaler\n"
+"Eurodata Computer Club\n"
+"Geoffrey Roussel\n"
+"Joeri van Dooren\n"
+"kty0ne\n"
+"Max Rudberg\n"
+"Richard Ã˜iestad\n"
+"Simon DamkjÃ¦r Andersen\n"
+"Tom Bigelajzen\n"
+"Vincent van den Heuvel\n"
+"\n"
+"Documentation\n"
+"-------------\n"
+"Bill Eldridge\n"
+"\n"
+"Localization\n"
+"------------\n"
+"Abdul Fousan - Tamil\n"
+"A. Decorte - Friulian\n"
+"Adem Gunes - Turkish\n"
+"Adi Nugroho - Tagalog\n"
+"airplanez - Korean\n"
+"Ajith Manjula - Sinhala\n"
+"Alexander Didebulidze - Georgian\n"
+"Alexander Henket - Dutch\n"
+"Alexander Lakhin - Russian\n"
+"Alexey Lugin - Ukrainian\n"
+"Alexey Salmin - Russian\n"
+"Alfred John - Acoli\n"
+"Amanpreet Singh Alam - Punjabi\n"
+"AndrÃ© de Barros Martins Ribeiro - Brazilian portuguese\n"
+"Andrey Brilevskiy - Russian\n"
+"Andrey Wolk - Russian\n"
+"Andri PÃ¡lsson - Icelandic\n"
+"Anh Phan - Vietnamese\n"
+"Animesh Swar - Nepalese\n"
+"Ara Bextiyar - Sorani (Kurdish)\n"
+"Ari ConstÃ¢ncio - Portuguese\n"
+"Arkadiusz Lipiec - Polish\n"
+"Audrey Prevost - French\n"
+"Auk Piseth - Khmer\n"
+"Bayarsaikhan Enkhtaivan Ð‘Ð°ÑÑ€ÑÐ°Ð¹Ñ…Ð°Ð½ Ð­Ð½Ñ…Ñ‚Ð°Ð¹Ð²Ð°Ð½ - Mongolian\n"
+"Bruno QueirÃ³s - Portuguese\n"
+"Bruno Vella - Italian\n"
+"Carlo CalabrÃ² - Italian\n"
+"Chandan Kumar - Hindi\n"
+"Christoph Miebach - German\n"
+"Circo Radu - Romanian\n"
+"Cristian SecarÄƒ - Romanian\n"
+"Daniel Nylander - Swedish\n"
+"David GonzÃ¡lez - Spanish\n"
+"David Planella - Catalan\n"
+"Dean Lee - Chinese\n"
+"Denis Arnaud - Breton\n"
+"Derk-Jan Hartman - Dutch\n"
+"DirektX - Hungarian\n"
+"Dominko AÅ¾dajiÄ‡ - Croatian\n"
+"Dylan AÃ¯ssi - French\n"
+"Eduard Babayan - Armenian\n"
+"Eero - Estonian\n"
+"Eirik U. Birkeland - Norwegian Nynorsk\n"
+"Elizabeth Da Conceicao Baptista - Tetum\n"
+"Ã‰ric Lassauge - French\n"
+"Farzaneh Sarafraz - Persian\n"
+"Florence Tushabe - Chiga\n"
+"Fouzia Bourai - Arabic\n"
+"Frank Chao - Chinese Traditional\n"
+"Freyr Gunnar Ã“lafsson - Icelandic\n"
+"Friedel Wolff - Afrikaans\n"
+"Fumio Nakayama - Japanese\n"
+"Gabor Kelemen - Hungarian\n"
+"GaÃ«tan Rousseaux - Walloon\n"
+"Ghjuvan Pasquinu - Corsican\n"
+"Goce Manevski - Macedonian\n"
+"Golam Maruf Oovee - Bengali\n"
+"GonÃ§alo Cordeiro - Galician\n"
+"Gorana Milicevic - Serbian\n"
+"Haakon Meland Eriksen - Norwegian\n"
+"Han HoJoong - Korean\n"
+"H.Shalitha Vikum - Sinhala\n"
+"Ibrahima Sarr - Peul\n"
+"Israt Jahan - Bengali\n"
+"IvÃ¡n Seoane Pardo - Galician\n"
+"Ivo Ivanov - Bulgarian\n"
+"Jakub Å½Ã¡Äek - Czech\n"
+"James Olweny - Ganda\n"
+"Jamil Ahmed - Bengali\n"
+"Javier Varela - Spanish\n"
+"Jean-Pierre Kuypers - French\n"
+"Jens Seidel - German\n"
+"Joel Arvidsson - Swedish\n"
+"jogijs - Latvian\n"
+"Jonas Larsen - Danish\n"
+"Jon StÃ¸dle - Norwegian Nynorsk\n"
+"Jouni KÃ¤hkÃ¶nen - Finnish\n"
+"Juha Jeronen - Finnish\n"
+"Kai Hermann - German\n"
+"Kamil PÃ¡ral - Czech\n"
+"Kang Jeong-Hee - Korean\n"
+"Kaya Zeren - Turkish\n"
+"Khin Mi Mi Aung - Burmese\n"
+"Khoem Sokhem - Khmer\n"
+"Kola - Albanian\n"
+"Kypchak Kypchak - Kazakh\n"
+"Laurent Jonqueres - Occitan\n"
+"Loba Yeasmeen - Bengali\n"
+"Lorena Gomes - Catalan\n"
+"Luqman Hakim - Indonesian\n"
+"Mahrazi Mohd Kamal - Malay\n"
+"Manolis Stefanis - Modern Greek\n"
+"MariÃ¡n HikanÃ­k - Slovak\n"
+"Mario Siegmann - German\n"
+"Marko Uskokovic - Serbian\n"
+"Martin Zicha - Czech\n"
+"Matej UrbanÄiÄ - Slovenian\n"
+"Mathias C. Berens, welcome-soft - German\n"
+"Mattias PÃµldaru - Estonian\n"
+"Md. Rezwan Shahid - Bengali\n"
+"Meelad Zakaria - Persian\n"
+"Michael Bauer - Gaelic; Scottish Gaelic\n"
+"MichaÅ‚ Trzebiatowski - Polish\n"
+"Mihkel Kirjutas - Estonian\n"
+"Mindaugas Baranauskas - Lithuanian\n"
+"Miroslav OujeskÃ½ - Czech\n"
+"Morten Brix Pedersen - Danish\n"
+"Myckel Habets - Dutch\n"
+"Namhyung Kim - Korean\n"
+"Niels FanÃ¸e - Danish\n"
+"Niklas 'Nille' Ã…kerstrÃ¶m - Swedish\n"
+"Olav Dahlum - Norwegian\n"
+"Oleksandr Natalenko - Ukrainian\n"
+"Omer Ensari - Kurmanji (Kurdish)\n"
+"Osama Khalid - Arabic\n"
+"Otto KekÃ¤lÃ¤inen - Finnish\n"
+"Paula Iglesias - Galician\n"
+"Phan Anh - Vietnamese\n"
+"Philipp Weissenbacher - German\n"
+"Pittayakom Saingtong - Thai\n"
+"Praveen Illa - Telugu\n"
+"Predrag LjubenoviÄ‡ - Serbian\n"
+"Rajnikant Kumbhar - Marathi\n"
+"Ricardo PÃ©rez LÃ³pez - Spanish\n"
+"Roustam Ghizdatov - Russian\n"
+"Sadia Afroz - Bengali\n"
+"Said Marjan Zazai - Pashto\n"
+"Salar Khalilzadeh - Persian\n"
+"Sam Hocevar - British\n"
+"Samuel Hocevar - French\n"
+"Sayan Chowdhury - Hindi\n"
+"SeanÃ¡n Ã“ CoistÃ­n - Irish\n"
+"Shashi Ranjan - Hindi\n"
+"Siarhei Daryichau Ð”Ð°Ñ€'Ñ–Ñ‡Ð°Ñž Ð¡ÑÑ€Ð³ÐµÐ¹ - Belarusian\n"
+"Sidney Doria - Brazilian Portuguese\n"
+"Sigmund Augdal - Norwegian\n"
+"Simos Xenitellis - Greek\n"
+"Sipho Sibiya - Zulu\n"
+"Sok Sophea - Khmer\n"
+"Solomon Gizaw - Amharic\n"
+"Sreejith P - Malayalam\n"
+"Sveinn Ã­ Felli - Icelandic\n"
+"Tadashi Jokagi - Japanese\n"
+"T. Chomphuming - Thai\n"
+"Tero Pelander - Finnish\n"
+"Thomas De Rocker - Dutch\n"
+"Thomas Graf - gettext support, German\n"
+"TomÃ¡Å¡ ChvÃ¡tal - Czech\n"
+"TÃ²ni Galhard - Occitan\n"
+"Umidjon Almasov - Uzbek\n"
+"VÃ¡clav PavlÃ­Äek - Czech\n"
+"Valek Filippov - Russian\n"
+"Vicente Jimenez Aguilar - Spanish\n"
+"Vincenzo Reale - Italian\n"
+"VÃ­t PelÄÃ¡k - Czech\n"
+"viyyer - Hindi\n"
+"Vladimir Yermolayev - Russian\n"
+"VojtÄ›ch Smejkal - Czech\n"
+"Wei Mingzhi - Simplified Chinese\n"
+"Xabier Aramendi - Basque\n"
+"XÃ¨nia AlbÃ  Cantero - Catalan\n"
+"Xuacu Saturio - Asturian\n"
+"Yaron Shahrabani - Hebrew\n"
+"YaÅŸar Tay - Turkish\n"
+"Yoyo - Simplified Chinese\n"
+"Yuksel Yildirim - Turkish\n"
+"Zabeeh Khan - Pashto\n"
+"Zhang Tong - Chinese\n"
+;

=== added file 'DivCity/DivCity/vlc/plugins/vlc_access.h'
--- DivCity/DivCity/vlc/plugins/vlc_access.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_access.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,184 @@
+/*****************************************************************************
+ * vlc_access.h: Access descriptor, queries and methods
+ *****************************************************************************
+ * Copyright (C) 1999-2006 VLC authors and VideoLAN
+ * $Id: df8cf1af98f0fe94a42fa9c402718d9a18bcfa7c $
+ *
+ * Authors: Laurent Aimar <fenrir@via.ecp.fr>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_ACCESS_H
+#define VLC_ACCESS_H 1
+
+/**
+ * \file
+ * This file defines functions and definitions for access object
+ */
+
+#include <vlc_block.h>
+
+/**
+ * \defgroup access Access
+ * @{
+ */
+
+enum access_query_e
+{
+    /* capabilities */
+    ACCESS_CAN_SEEK,        /* arg1= bool*    cannot fail */
+    ACCESS_CAN_FASTSEEK,    /* arg1= bool*    cannot fail */
+    ACCESS_CAN_PAUSE,       /* arg1= bool*    cannot fail */
+    ACCESS_CAN_CONTROL_PACE,/* arg1= bool*    cannot fail */
+
+    /* */
+    ACCESS_GET_PTS_DELAY = 0x101,/* arg1= int64_t*       cannot fail */
+    /* */
+    ACCESS_GET_TITLE_INFO,  /* arg1=input_title_t*** arg2=int*      res=can fail */
+    /* Meta data */
+    ACCESS_GET_META,        /* arg1= vlc_meta_t **                  res=can fail */
+
+    /* */
+    ACCESS_GET_CONTENT_TYPE,/* arg1=char **ppsz_content_type                       res=can fail */
+
+    /* */
+    ACCESS_GET_SIGNAL,      /* arg1=double *pf_quality, arg2=double *pf_strength   res=can fail */
+
+    /* */
+    ACCESS_SET_PAUSE_STATE = 0x200, /* arg1= bool           can fail */
+
+    /* */
+    ACCESS_SET_TITLE,       /* arg1= int            can fail */
+    ACCESS_SET_SEEKPOINT,   /* arg1= int            can fail */
+
+    /* Special mode for access/demux communication
+     * XXX: avoid to use it unless you can't */
+    ACCESS_SET_PRIVATE_ID_STATE = 0x1000, /* arg1= int i_private_data, bool b_selected    res=can fail */
+    ACCESS_SET_PRIVATE_ID_CA,             /* arg1= int i_program_number, uint16_t i_vpid, uint16_t i_apid1, uint16_t i_apid2, uint16_t i_apid3, uint8_t i_length, uint8_t *p_data */
+    ACCESS_GET_PRIVATE_ID_STATE,          /* arg1=int i_private_data arg2=bool *          res=can fail */
+};
+
+struct access_t
+{
+    VLC_COMMON_MEMBERS
+
+    /* Module properties */
+    module_t    *p_module;
+
+    /* Access name (empty if non forced) */
+    char        *psz_access;
+    char        *psz_location; /**< Location (URL with the scheme stripped) */
+    char        *psz_filepath; /**< Local file path (if applicable) */
+
+    /* Access can fill this entry to force a demuxer
+     * XXX: fill it once you know for sure you will succeed
+     * (if you fail, this value won't be reseted */
+    char        *psz_demux;
+
+    /* pf_read/pf_block is used to read data.
+     * XXX A access should set one and only one of them */
+    ssize_t     (*pf_read) ( access_t *, uint8_t *, size_t );  /* Return -1 if no data yet, 0 if no more data, else real data read */
+    block_t    *(*pf_block)( access_t * );                  /* return a block of data in his 'natural' size, NULL if not yet data or eof */
+
+    /* Called for each seek.
+     * XXX can be null */
+    int         (*pf_seek) ( access_t *, uint64_t );         /* can be null if can't seek */
+
+    /* Used to retreive and configure the access
+     * XXX mandatory. look at access_query_e to know what query you *have to* support */
+    int         (*pf_control)( access_t *, int i_query, va_list args);
+
+    /* Access has to maintain them uptodate */
+    struct
+    {
+        unsigned int i_update;  /* Access sets them on change,
+                                   Input removes them once take into account*/
+
+        uint64_t     i_size;    /* Write only for access, read only for input */
+        uint64_t     i_pos;     /* idem */
+        bool         b_eof;     /* idem */
+
+        int          i_title;    /* idem, start from 0 (could be menu) */
+        int          i_seekpoint;/* idem, start from 0 */
+    } info;
+    access_sys_t *p_sys;
+
+    /* Weak link to parent input */
+    input_thread_t *p_input;
+};
+
+static inline int access_vaControl( access_t *p_access, int i_query, va_list args )
+{
+    if( !p_access ) return VLC_EGENERIC;
+    return p_access->pf_control( p_access, i_query, args );
+}
+
+static inline int access_Control( access_t *p_access, int i_query, ... )
+{
+    va_list args;
+    int     i_result;
+
+    va_start( args, i_query );
+    i_result = access_vaControl( p_access, i_query, args );
+    va_end( args );
+    return i_result;
+}
+
+static inline void access_InitFields( access_t *p_a )
+{
+    p_a->info.i_update = 0;
+    p_a->info.i_size = 0;
+    p_a->info.i_pos = 0;
+    p_a->info.b_eof = false;
+    p_a->info.i_title = 0;
+    p_a->info.i_seekpoint = 0;
+}
+
+/**
+ * This function will return the parent input of this access.
+ * It is retained. It can return NULL.
+ */
+VLC_API input_thread_t * access_GetParentInput( access_t *p_access ) VLC_USED;
+
+#define ACCESS_SET_CALLBACKS( read, block, control, seek ) \
+    do { \
+        p_access->pf_read = (read); \
+        p_access->pf_block = (block); \
+        p_access->pf_control = (control); \
+        p_access->pf_seek = (seek); \
+    } while(0)
+
+#define STANDARD_READ_ACCESS_INIT \
+    do { \
+        access_InitFields( p_access ); \
+        ACCESS_SET_CALLBACKS( Read, NULL, Control, Seek ); \
+        p_sys = p_access->p_sys = calloc( 1, sizeof( access_sys_t ) ); \
+        if( !p_sys ) return VLC_ENOMEM;\
+    } while(0);
+
+#define STANDARD_BLOCK_ACCESS_INIT \
+    do { \
+        access_InitFields( p_access ); \
+        ACCESS_SET_CALLBACKS( NULL, Block, Control, Seek ); \
+        p_sys = p_access->p_sys = calloc( 1, sizeof( access_sys_t ) ); \
+        if( !p_sys ) return VLC_ENOMEM; \
+    } while(0);
+
+/**
+ * @}
+ */
+
+#endif

=== added file 'DivCity/DivCity/vlc/plugins/vlc_acl.h'
--- DivCity/DivCity/vlc/plugins/vlc_acl.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_acl.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,40 @@
+/*****************************************************************************
+ * vlc_acl.h: interface to the network Access Control List internal API
+ *****************************************************************************
+ * Copyright (C) 2005 RÃ©mi Denis-Courmont
+ * Copyright (C) 2005 VLC authors and VideoLAN
+ * $Id: 6c979af7cec8feb60b66103019d161ad90b109b6 $
+ *
+ * Authors: RÃ©mi Denis-Courmont <rem # videolan.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_ACL_H
+# define VLC_ACL_H
+
+
+VLC_API int ACL_Check( vlc_acl_t *p_acl, const char *psz_ip );
+VLC_API vlc_acl_t * ACL_Create( vlc_object_t *p_this, bool b_allow ) VLC_USED VLC_MALLOC;
+#define ACL_Create(a, b) ACL_Create(VLC_OBJECT(a), b)
+VLC_API vlc_acl_t * ACL_Duplicate( vlc_object_t *p_this, const vlc_acl_t *p_acl ) VLC_USED VLC_MALLOC;
+#define ACL_Duplicate(a,b) ACL_Duplicate(VLC_OBJECT(a),b)
+VLC_API void ACL_Destroy( vlc_acl_t *p_acl );
+
+#define ACL_AddHost(a,b,c) ACL_AddNet(a,b,-1,c)
+VLC_API int ACL_AddNet( vlc_acl_t *p_acl, const char *psz_ip, int i_len, bool b_allow );
+VLC_API int ACL_LoadFile( vlc_acl_t *p_acl, const char *path );
+
+#endif

=== added file 'DivCity/DivCity/vlc/plugins/vlc_aout.h'
--- DivCity/DivCity/vlc/plugins/vlc_aout.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_aout.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,298 @@
+/*****************************************************************************
+ * vlc_aout.h : audio output interface
+ *****************************************************************************
+ * Copyright (C) 2002-2011 VLC authors and VideoLAN
+ *
+ * Authors: Christophe Massiot <massiot@via.ecp.fr>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_AOUT_H
+#define VLC_AOUT_H 1
+
+/**
+ * \file
+ * This file defines functions, structures and macros for audio output object
+ */
+
+/* Max number of pre-filters per input, and max number of post-filters */
+#define AOUT_MAX_FILTERS                10
+
+/* Buffers which arrive in advance of more than AOUT_MAX_ADVANCE_TIME
+ * will be considered as bogus and be trashed */
+#define AOUT_MAX_ADVANCE_TIME           (AOUT_MAX_PREPARE_TIME + CLOCK_FREQ)
+
+/* Buffers which arrive in advance of more than AOUT_MAX_PREPARE_TIME
+ * will cause the calling thread to sleep */
+#define AOUT_MAX_PREPARE_TIME           (2 * CLOCK_FREQ)
+
+/* Buffers which arrive after pts - AOUT_MIN_PREPARE_TIME will be trashed
+ * to avoid too heavy resampling */
+#define AOUT_MIN_PREPARE_TIME           AOUT_MAX_PTS_ADVANCE
+
+/* Tolerance values from EBU Recommendation 37 */
+/** Maximum advance of actual audio playback time to coded PTS,
+ * above which downsampling will be performed */
+#define AOUT_MAX_PTS_ADVANCE            (CLOCK_FREQ / 25)
+
+/** Maximum delay of actual audio playback time from coded PTS,
+ * above which upsampling will be performed */
+#define AOUT_MAX_PTS_DELAY              (3 * CLOCK_FREQ / 50)
+
+/* Max acceptable resampling (in %) */
+#define AOUT_MAX_RESAMPLING             10
+
+#include "vlc_es.h"
+
+#define AOUT_FMTS_IDENTICAL( p_first, p_second ) (                          \
+    ((p_first)->i_format == (p_second)->i_format)                           \
+      && AOUT_FMTS_SIMILAR(p_first, p_second) )
+
+/* Check if i_rate == i_rate and i_channels == i_channels */
+#define AOUT_FMTS_SIMILAR( p_first, p_second ) (                            \
+    ((p_first)->i_rate == (p_second)->i_rate)                               \
+      && ((p_first)->i_physical_channels == (p_second)->i_physical_channels)\
+      && ((p_first)->i_original_channels == (p_second)->i_original_channels) )
+
+#define AOUT_FMT_LINEAR( p_format ) \
+    (aout_BitsPerSample((p_format)->i_format) != 0)
+
+#define VLC_CODEC_SPDIFL VLC_FOURCC('s','p','d','i')
+#define VLC_CODEC_SPDIFB VLC_FOURCC('s','p','d','b')
+
+#define AOUT_FMT_SPDIF( p_format ) \
+    ( ((p_format)->i_format == VLC_CODEC_SPDIFL)       \
+       || ((p_format)->i_format == VLC_CODEC_SPDIFB)   \
+       || ((p_format)->i_format == VLC_CODEC_A52)       \
+       || ((p_format)->i_format == VLC_CODEC_DTS) )
+
+/* This is heavily borrowed from libmad, by Robert Leslie <rob@mars.org> */
+/*
+ * Fixed-point format: 0xABBBBBBB
+ * A == whole part      (sign + 3 bits)
+ * B == fractional part (28 bits)
+ *
+ * Values are signed two's complement, so the effective range is:
+ * 0x80000000 to 0x7fffffff
+ *       -8.0 to +7.9999999962747097015380859375
+ *
+ * The smallest representable value is:
+ * 0x00000001 == 0.0000000037252902984619140625 (i.e. about 3.725e-9)
+ *
+ * 28 bits of fractional accuracy represent about
+ * 8.6 digits of decimal accuracy.
+ *
+ * Fixed-point numbers can be added or subtracted as normal
+ * integers, but multiplication requires shifting the 64-bit result
+ * from 56 fractional bits back to 28 (and rounding.)
+ */
+typedef int32_t vlc_fixed_t;
+#define FIXED32_FRACBITS 28
+#define FIXED32_MIN ((vlc_fixed_t) -0x80000000L)
+#define FIXED32_MAX ((vlc_fixed_t) +0x7fffffffL)
+#define FIXED32_ONE ((vlc_fixed_t) 0x10000000)
+
+/*
+ * Channels descriptions
+ */
+
+/* Values available for physical and original channels */
+#define AOUT_CHAN_CENTER            0x1
+#define AOUT_CHAN_LEFT              0x2
+#define AOUT_CHAN_RIGHT             0x4
+#define AOUT_CHAN_REARCENTER        0x10
+#define AOUT_CHAN_REARLEFT          0x20
+#define AOUT_CHAN_REARRIGHT         0x40
+#define AOUT_CHAN_MIDDLELEFT        0x100
+#define AOUT_CHAN_MIDDLERIGHT       0x200
+#define AOUT_CHAN_LFE               0x1000
+
+#define AOUT_CHANS_FRONT  (AOUT_CHAN_LEFT       | AOUT_CHAN_RIGHT)
+#define AOUT_CHANS_MIDDLE (AOUT_CHAN_MIDDLELEFT | AOUT_CHAN_MIDDLERIGHT)
+#define AOUT_CHANS_REAR   (AOUT_CHAN_REARLEFT   | AOUT_CHAN_REARRIGHT)
+
+#define AOUT_CHANS_STEREO (AOUT_CHANS_FRONT)
+#define AOUT_CHANS_4_0    (AOUT_CHANS_FRONT | AOUT_CHANS_REAR)
+#define AOUT_CHANS_4_1    (AOUT_CHANS_4_0 | AOUT_CHAN_LFE)
+#define AOUT_CHANS_5_0    (AOUT_CHANS_4_0 | AOUT_CHAN_CENTER)
+#define AOUT_CHANS_5_1    (AOUT_CHANS_5_0 | AOUT_CHAN_LFE)
+#define AOUT_CHANS_7_1    (AOUT_CHANS_5_1 | AOUT_CHANS_MIDDLE)
+
+/* Values available for original channels only */
+#define AOUT_CHAN_DOLBYSTEREO       0x10000
+#define AOUT_CHAN_DUALMONO          0x20000
+#define AOUT_CHAN_REVERSESTEREO     0x40000
+
+#define AOUT_CHAN_PHYSMASK          0xFFFF
+#define AOUT_CHAN_MAX               9
+
+/* Values used for the audio-device and audio-channels object variables */
+#define AOUT_VAR_MONO               1
+#define AOUT_VAR_STEREO             2
+#define AOUT_VAR_2F2R               4
+#define AOUT_VAR_3F2R               5
+#define AOUT_VAR_5_1                6
+#define AOUT_VAR_6_1                7
+#define AOUT_VAR_7_1                8
+#define AOUT_VAR_SPDIF              10
+
+#define AOUT_VAR_CHAN_STEREO        1
+#define AOUT_VAR_CHAN_RSTEREO       2
+#define AOUT_VAR_CHAN_LEFT          3
+#define AOUT_VAR_CHAN_RIGHT         4
+#define AOUT_VAR_CHAN_DOLBYS        5
+
+/*****************************************************************************
+ * Main audio output structures
+ *****************************************************************************/
+
+#define aout_BufferFree( buffer ) block_Release( buffer )
+
+/* Size of a frame for S/PDIF output. */
+#define AOUT_SPDIF_SIZE 6144
+
+/* Number of samples in an A/52 frame. */
+#define A52_FRAME_NB 1536
+
+/* FIXME to remove once aout.h is cleaned a bit more */
+#include <vlc_block.h>
+
+typedef int (*aout_volume_cb) (audio_output_t *, float, bool);
+
+/** Audio output object */
+struct audio_output
+{
+    VLC_COMMON_MEMBERS
+
+    audio_sample_format_t format; /**< Output format (plugin can modify it
+        only when succesfully probed and not afterward) */
+
+    struct aout_sys_t *sys; /**< Output plugin private data */
+    void (*pf_play)(audio_output_t *, block_t *); /**< Audio buffer callback */
+    void (* pf_pause)( audio_output_t *, bool, mtime_t ); /**< Pause/resume
+        callback (optional, may be NULL) */
+    void (* pf_flush)( audio_output_t *, bool ); /**< Flush/drain callback
+        (optional, may be NULL) */
+    aout_volume_cb          pf_volume_set; /**< Volume setter (or NULL) */
+};
+
+/**
+ * It describes the audio channel order VLC expect.
+ */
+static const uint32_t pi_vlc_chan_order_wg4[] =
+{
+    AOUT_CHAN_LEFT, AOUT_CHAN_RIGHT,
+    AOUT_CHAN_MIDDLELEFT, AOUT_CHAN_MIDDLERIGHT,
+    AOUT_CHAN_REARLEFT, AOUT_CHAN_REARRIGHT, AOUT_CHAN_REARCENTER,
+    AOUT_CHAN_CENTER, AOUT_CHAN_LFE, 0
+};
+
+/*****************************************************************************
+ * Prototypes
+ *****************************************************************************/
+
+/**
+ * This function computes the reordering needed to go from pi_chan_order_in to
+ * pi_chan_order_out.
+ * If pi_chan_order_in or pi_chan_order_out is NULL, it will assume that vlc
+ * internal (WG4) order is requested.
+ */
+VLC_API int aout_CheckChannelReorder( const uint32_t *pi_chan_order_in, const uint32_t *pi_chan_order_out, uint32_t i_channel_mask, int i_channels, int *pi_chan_table );
+VLC_API void aout_ChannelReorder( uint8_t *, int, int, const int *, int );
+
+/**
+ * This fonction will compute the extraction parameter into pi_selection to go
+ * from i_channels with their type given by pi_order_src[] into the order
+ * describe by pi_order_dst.
+ * It will also set :
+ * - *pi_channels as the number of channels that will be extracted which is
+ * lower (in case of non understood channels type) or equal to i_channels.
+ * - the layout of the channels (*pi_layout).
+ *
+ * It will return true if channel extraction is really needed, in which case
+ * aout_ChannelExtract must be used
+ *
+ * XXX It must be used when the source may have channel type not understood
+ * by VLC. In this case the channel type pi_order_src[] must be set to 0.
+ * XXX It must also be used if multiple channels have the same type.
+ */
+VLC_API bool aout_CheckChannelExtraction( int *pi_selection, uint32_t *pi_layout, int *pi_channels, const uint32_t pi_order_dst[AOUT_CHAN_MAX], const uint32_t *pi_order_src, int i_channels );
+
+/**
+ * Do the actual channels extraction using the parameters created by
+ * aout_CheckChannelExtraction.
+ *
+ * XXX this function does not work in place (p_dst and p_src must not overlap).
+ * XXX Only 8, 16, 24, 32, 64 bits per sample are supported.
+ */
+VLC_API void aout_ChannelExtract( void *p_dst, int i_dst_channels, const void *p_src, int i_src_channels, int i_sample_count, const int *pi_selection, int i_bits_per_sample );
+
+/* */
+static inline unsigned aout_FormatNbChannels(const audio_sample_format_t *fmt)
+{
+    return popcount(fmt->i_physical_channels & AOUT_CHAN_PHYSMASK);
+}
+
+VLC_API unsigned int aout_BitsPerSample( vlc_fourcc_t i_format ) VLC_USED;
+VLC_API void aout_FormatPrepare( audio_sample_format_t * p_format );
+VLC_API void aout_FormatPrint(vlc_object_t *, const char *,
+                              const audio_sample_format_t *);
+#define aout_FormatPrint(o, t, f) aout_FormatPrint(VLC_OBJECT(o), t, f)
+VLC_API const char * aout_FormatPrintChannels( const audio_sample_format_t * ) VLC_USED;
+
+VLC_API void aout_VolumeNoneInit( audio_output_t * );
+VLC_API void aout_VolumeSoftInit( audio_output_t * );
+VLC_API void aout_VolumeHardInit( audio_output_t *, aout_volume_cb );
+VLC_API void aout_VolumeHardSet( audio_output_t *, float, bool );
+
+VLC_API void aout_TimeReport(audio_output_t *, mtime_t);
+
+VLC_API int aout_ChannelsRestart( vlc_object_t *, const char *, vlc_value_t, vlc_value_t, void * );
+
+/* */
+VLC_API vout_thread_t * aout_filter_RequestVout( filter_t *, vout_thread_t *p_vout, video_format_t *p_fmt ) VLC_USED;
+
+/** Audio output buffer FIFO */
+struct aout_fifo_t
+{
+    aout_buffer_t *         p_first;
+    aout_buffer_t **        pp_last;
+    date_t                  end_date;
+};
+
+/* Legacy packet-oriented audio output helpers */
+typedef struct
+{
+    vlc_mutex_t lock;
+    aout_fifo_t partial; /**< Audio blocks before packetization */
+    aout_fifo_t fifo; /**< Packetized audio blocks */
+    mtime_t pause_date; /**< Date when paused or VLC_TS_INVALID */
+    mtime_t time_report; /**< Desynchronization estimate or VLC_TS_INVALID */
+    unsigned samples; /**< Samples per packet */
+    bool starving; /**< Whether currently starving (to limit error messages) */
+} aout_packet_t;
+
+VLC_API void aout_PacketInit(audio_output_t *, aout_packet_t *, unsigned);
+VLC_API void aout_PacketDestroy(audio_output_t *);
+
+VLC_API void aout_PacketPlay(audio_output_t *, block_t *);
+VLC_API void aout_PacketPause(audio_output_t *, bool, mtime_t);
+VLC_API void aout_PacketFlush(audio_output_t *, bool);
+
+VLC_API block_t *aout_PacketNext(audio_output_t *, mtime_t) VLC_USED;
+
+
+#endif /* VLC_AOUT_H */

=== added file 'DivCity/DivCity/vlc/plugins/vlc_aout_intf.h'
--- DivCity/DivCity/vlc/plugins/vlc_aout_intf.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_aout_intf.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,48 @@
+/*****************************************************************************
+ * vlc_aout_intf.h : audio output control
+ *****************************************************************************
+ * Copyright (C) 2002-2011 VLC authors and VideoLAN
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_AOUT_INTF_H
+#define VLC_AOUT_INTF_H 1
+
+/**
+ * \file
+ * This file defines functions, structures and macros for audio output object
+ */
+
+#define AOUT_VOLUME_DEFAULT             256
+#define AOUT_VOLUME_MAX                 512
+
+VLC_API audio_volume_t aout_VolumeGet( vlc_object_t * );
+#define aout_VolumeGet(a) aout_VolumeGet(VLC_OBJECT(a))
+VLC_API int aout_VolumeSet( vlc_object_t *, audio_volume_t );
+#define aout_VolumeSet(a, b) aout_VolumeSet(VLC_OBJECT(a), b)
+VLC_API int aout_VolumeUp( vlc_object_t *, int, audio_volume_t * );
+#define aout_VolumeUp(a, b, c) aout_VolumeUp(VLC_OBJECT(a), b, c)
+#define aout_VolumeDown(a, b, c) aout_VolumeUp(a, -(b), c)
+VLC_API int aout_ToggleMute( vlc_object_t *, audio_volume_t * );
+#define aout_ToggleMute(a, b) aout_ToggleMute(VLC_OBJECT(a), b)
+VLC_API int aout_SetMute( vlc_object_t *, audio_volume_t *, bool );
+VLC_API bool aout_IsMuted( vlc_object_t * );
+
+VLC_API void aout_EnableFilter( vlc_object_t *, const char *, bool );
+#define aout_EnableFilter( o, n, b ) \
+        aout_EnableFilter( VLC_OBJECT(o), n, b )
+
+#endif /* _VLC_AOUT_H */

=== added file 'DivCity/DivCity/vlc/plugins/vlc_aout_mixer.h'
--- DivCity/DivCity/vlc/plugins/vlc_aout_mixer.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_aout_mixer.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,55 @@
+/*****************************************************************************
+ * vlc_aout_mixer.h : audio output mixer interface
+ *****************************************************************************
+ * Copyright (C) 2002-2009 VLC authors and VideoLAN
+ * $Id: ad0d12e7282b07050d2707ecaf01863fcdaa7599 $
+ *
+ * Authors: Christophe Massiot <massiot@via.ecp.fr>
+ *          Laurent Aimar <fenrir _AT_ videolan _DOT_ org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_AOUT_MIXER_H
+#define VLC_AOUT_MIXER_H 1
+
+/**
+ * \file
+ * This file defines functions, structures and macros for audio output mixer object
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct audio_mixer audio_mixer_t;
+
+/** 
+ * audio output mixer
+ */
+struct audio_mixer
+{
+    VLC_COMMON_MEMBERS
+
+    module_t *module; /**< Module handle */
+    vlc_fourcc_t format; /**< Audio samples format */
+    void (*mix)(audio_mixer_t *, block_t *, float); /**< Amplifier */
+};
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif

=== added file 'DivCity/DivCity/vlc/plugins/vlc_arrays.h'
--- DivCity/DivCity/vlc/plugins/vlc_arrays.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_arrays.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,627 @@
+/*****************************************************************************
+ * vlc_arrays.h : Arrays and data structures handling
+ *****************************************************************************
+ * Copyright (C) 1999-2004 VLC authors and VideoLAN
+ * $Id: 6643197707faf62a22b3ab4313676e8e40cf8355 $
+ *
+ * Authors: Samuel Hocevar <sam@zoy.org>
+ *          ClÃ©ment Stenac <zorglub@videolan.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_ARRAYS_H_
+#define VLC_ARRAYS_H_
+
+/**
+ * \file
+ * This file defines functions, structures and macros for handling arrays in vlc
+ */
+
+/* realloc() that never fails *if* downsizing */
+static inline void *realloc_down( void *ptr, size_t size )
+{
+    void *ret = realloc( ptr, size );
+    return ret ? ret : ptr;
+}
+
+/**
+ * Simple dynamic array handling. Array is realloced at each insert/removal
+ */
+#if defined( _MSC_VER ) && _MSC_VER < 1300 && !defined( UNDER_CE )
+#   define VLCCVP (void**) /* Work-around for broken compiler */
+#else
+#   define VLCCVP
+#endif
+#define INSERT_ELEM( p_ar, i_oldsize, i_pos, elem )                           \
+    do                                                                        \
+    {                                                                         \
+        if( !(i_oldsize) ) (p_ar) = NULL;                                       \
+        (p_ar) = VLCCVP realloc( p_ar, ((i_oldsize) + 1) * sizeof(*(p_ar)) ); \
+        if( !(p_ar) ) abort();                                                \
+        if( (i_oldsize) - (i_pos) )                                           \
+        {                                                                     \
+            memmove( (p_ar) + (i_pos) + 1, (p_ar) + (i_pos),                  \
+                     ((i_oldsize) - (i_pos)) * sizeof( *(p_ar) ) );           \
+        }                                                                     \
+        (p_ar)[(i_pos)] = elem;                                                 \
+        (i_oldsize)++;                                                        \
+    }                                                                         \
+    while( 0 )
+
+#define REMOVE_ELEM( p_ar, i_size, i_pos )                                    \
+    do                                                                        \
+    {                                                                         \
+        if( (i_size) - (i_pos) - 1 )                                          \
+        {                                                                     \
+            memmove( (p_ar) + (i_pos),                                        \
+                     (p_ar) + (i_pos) + 1,                                    \
+                     ((i_size) - (i_pos) - 1) * sizeof( *(p_ar) ) );          \
+        }                                                                     \
+        if( i_size > 1 )                                                      \
+            (p_ar) = realloc_down( p_ar, ((i_size) - 1) * sizeof( *(p_ar) ) );\
+        else                                                                  \
+        {                                                                     \
+            free( p_ar );                                                     \
+            (p_ar) = NULL;                                                    \
+        }                                                                     \
+        (i_size)--;                                                           \
+    }                                                                         \
+    while( 0 )
+
+#define TAB_INIT( count, tab )                  \
+  do {                                          \
+    (count) = 0;                                \
+    (tab) = NULL;                               \
+  } while(0)
+
+#define TAB_CLEAN( count, tab )                 \
+  do {                                          \
+    free( tab );                                \
+    (count)= 0;                                 \
+    (tab)= NULL;                                \
+  } while(0)
+
+#define TAB_APPEND_CAST( cast, count, tab, p )             \
+  do {                                          \
+    if( (count) > 0 )                           \
+        (tab) = cast realloc( tab, sizeof( void ** ) * ( (count) + 1 ) ); \
+    else                                        \
+        (tab) = cast malloc( sizeof( void ** ) );    \
+    if( !(tab) ) abort();                       \
+    (tab)[count] = (p);                         \
+    (count)++;                                  \
+  } while(0)
+
+#define TAB_APPEND( count, tab, p )             \
+    TAB_APPEND_CAST( , count, tab, p )
+
+#define TAB_FIND( count, tab, p, index )        \
+  do {                                          \
+    (index) = -1;                               \
+    for( int i = 0; i < (count); i++ )          \
+        if( (tab)[i] == (p) )                   \
+        {                                       \
+            (index) = i;                        \
+            break;                              \
+        }                                       \
+  } while(0)
+
+
+#define TAB_REMOVE( count, tab, p )             \
+  do {                                          \
+        int i_index;                            \
+        TAB_FIND( count, tab, p, i_index );     \
+        if( i_index >= 0 )                      \
+        {                                       \
+            if( (count) > 1 )                   \
+            {                                   \
+                memmove( ((void**)(tab) + i_index),    \
+                         ((void**)(tab) + i_index+1),  \
+                         ( (count) - i_index - 1 ) * sizeof( void* ) );\
+            }                                   \
+            (count)--;                          \
+            if( (count) == 0 )                  \
+            {                                   \
+                free( tab );                    \
+                (tab) = NULL;                   \
+            }                                   \
+        }                                       \
+  } while(0)
+
+#define TAB_INSERT_CAST( cast, count, tab, p, index ) do { \
+    if( (count) > 0 )                           \
+        (tab) = cast realloc( tab, sizeof( void ** ) * ( (count) + 1 ) ); \
+    else                                        \
+        (tab) = cast malloc( sizeof( void ** ) );       \
+    if( !(tab) ) abort();                       \
+    if( (count) - (index) > 0 )                 \
+        memmove( (void**)(tab) + (index) + 1,   \
+                 (void**)(tab) + (index),       \
+                 ((count) - (index)) * sizeof(*(tab)) );\
+    (tab)[(index)] = (p);                       \
+    (count)++;                                  \
+} while(0)
+
+#define TAB_INSERT( count, tab, p, index )      \
+    TAB_INSERT_CAST( , count, tab, p, index )
+
+/**
+ * Binary search in a sorted array. The key must be comparable by < and >
+ * \param entries array of entries
+ * \param count number of entries
+ * \param elem key to check within an entry (like .id, or ->i_id)
+ * \param zetype type of the key
+ * \param key value of the key
+ * \param answer index of answer within the array. -1 if not found
+ */
+#define BSEARCH( entries, count, elem, zetype, key, answer ) \
+   do {  \
+    int low = 0, high = count - 1;   \
+    answer = -1; \
+    while( low <= high ) {\
+        int mid = (low + high ) / 2; /* Just don't care about 2^30 tables */ \
+        zetype mid_val = entries[mid] elem;\
+        if( mid_val < key ) \
+            low = mid + 1; \
+        else if ( mid_val > key ) \
+            high = mid -1;  \
+        else    \
+        {   \
+            answer = mid;  break;   \
+        }\
+    } \
+ } while(0)
+
+
+/************************************************************************
+ * Dynamic arrays with progressive allocation
+ ************************************************************************/
+
+/* Internal functions */
+#define _ARRAY_ALLOC(array, newsize) {                                      \
+    (array).i_alloc = newsize;                                              \
+    (array).p_elems = VLCCVP realloc( (array).p_elems, (array).i_alloc *    \
+                                    sizeof(*(array).p_elems) );             \
+    if( !(array).p_elems ) abort();                                         \
+}
+
+#define _ARRAY_GROW1(array) {                                               \
+    if( (array).i_alloc < 10 )                                              \
+        _ARRAY_ALLOC(array, 10 )                                            \
+    else if( (array).i_alloc == (array).i_size )                            \
+        _ARRAY_ALLOC(array, (int)(array.i_alloc * 1.5) )                    \
+}
+
+#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
+
+/* API */
+#define DECL_ARRAY(type) struct {                                           \
+    int i_alloc;                                                            \
+    int i_size;                                                             \
+    type *p_elems;                                                          \
+}
+
+#define TYPEDEF_ARRAY(type, name) typedef DECL_ARRAY(type) name;
+
+#define ARRAY_INIT(array)                                                   \
+  do {                                                                      \
+    (array).i_alloc = 0;                                                    \
+    (array).i_size = 0;                                                     \
+    (array).p_elems = NULL;                                                 \
+  } while(0)
+
+#define ARRAY_RESET(array)                                                  \
+  do {                                                                      \
+    (array).i_alloc = 0;                                                    \
+    (array).i_size = 0;                                                     \
+    free( (array).p_elems ); (array).p_elems = NULL;                        \
+  } while(0)
+
+#define ARRAY_APPEND(array, elem)                                           \
+  do {                                                                      \
+    _ARRAY_GROW1(array);                                                    \
+    (array).p_elems[(array).i_size] = elem;                                 \
+    (array).i_size++;                                                       \
+  } while(0)
+
+#define ARRAY_INSERT(array,elem,pos)                                        \
+  do {                                                                      \
+    _ARRAY_GROW1(array);                                                    \
+    if( (array).i_size - pos ) {                                            \
+        memmove( (array).p_elems + pos + 1, (array).p_elems + pos,          \
+                 ((array).i_size-pos) * sizeof(*(array).p_elems) );         \
+    }                                                                       \
+    (array).p_elems[pos] = elem;                                            \
+    (array).i_size++;                                                       \
+  } while(0)
+
+#define _ARRAY_SHRINK(array) {                                              \
+    if( (array).i_size > 10 && (array).i_size < (int)((array).i_alloc / 1.5) ) {  \
+        _ARRAY_ALLOC(array, (array).i_size + 5);                            \
+    }                                                                       \
+}
+
+#define ARRAY_REMOVE(array,pos)                                             \
+  do {                                                                      \
+    if( (array).i_size - (pos) - 1 )                                        \
+    {                                                                       \
+        memmove( (array).p_elems + pos, (array).p_elems + pos + 1,          \
+                 ( (array).i_size - pos - 1 ) *sizeof(*(array).p_elems) );  \
+    }                                                                       \
+    (array).i_size--;                                                       \
+    _ARRAY_SHRINK(array);                                                   \
+  } while(0)
+
+#define ARRAY_VAL(array, pos) array.p_elems[pos]
+
+#define ARRAY_BSEARCH(array, elem, zetype, key, answer) \
+    BSEARCH( (array).p_elems, (array).i_size, elem, zetype, key, answer)
+
+#define FOREACH_ARRAY( item, array ) { \
+    int fe_idx; \
+    for( fe_idx = 0 ; fe_idx < (array).i_size ; fe_idx++ ) \
+    { \
+        item = (array).p_elems[fe_idx];
+
+#define FOREACH_END() } }
+
+
+/************************************************************************
+ * Dynamic arrays with progressive allocation (Preferred API)
+ ************************************************************************/
+typedef struct vlc_array_t
+{
+    int i_count;
+    void ** pp_elems;
+} vlc_array_t;
+
+static inline void vlc_array_init( vlc_array_t * p_array )
+{
+    memset( p_array, 0, sizeof(vlc_array_t) );
+}
+
+static inline void vlc_array_clear( vlc_array_t * p_array )
+{
+    free( p_array->pp_elems );
+    memset( p_array, 0, sizeof(vlc_array_t) );
+}
+
+static inline vlc_array_t * vlc_array_new( void )
+{
+    vlc_array_t * ret = (vlc_array_t *)malloc( sizeof(vlc_array_t) );
+    if( ret ) vlc_array_init( ret );
+    return ret;
+}
+
+static inline void vlc_array_destroy( vlc_array_t * p_array )
+{
+    if( !p_array )
+        return;
+    vlc_array_clear( p_array );
+    free( p_array );
+}
+
+
+/* Read */
+static inline int
+vlc_array_count( vlc_array_t * p_array )
+{
+    return p_array->i_count;
+}
+
+static inline void *
+vlc_array_item_at_index( vlc_array_t * p_array, int i_index )
+{
+    return p_array->pp_elems[i_index];
+}
+
+static inline int
+vlc_array_index_of_item( vlc_array_t * p_array, void * item )
+{
+    int i;
+    for( i = 0; i < p_array->i_count; i++)
+    {
+        if( p_array->pp_elems[i] == item )
+            return i;
+    }
+    return -1;
+}
+
+/* Write */
+static inline void
+vlc_array_insert( vlc_array_t * p_array, void * p_elem, int i_index )
+{
+    TAB_INSERT_CAST( (void **), p_array->i_count, p_array->pp_elems, p_elem, i_index );
+}
+
+static inline void
+vlc_array_append( vlc_array_t * p_array, void * p_elem )
+{
+    vlc_array_insert( p_array, p_elem, p_array->i_count );
+}
+
+static inline void
+vlc_array_remove( vlc_array_t * p_array, int i_index )
+{
+    if( i_index >= 0 )
+    {
+        if( p_array->i_count > 1 )
+        {
+            memmove( p_array->pp_elems + i_index,
+                     p_array->pp_elems + i_index+1,
+                     ( p_array->i_count - i_index - 1 ) * sizeof( void* ) );
+        }
+        p_array->i_count--;
+        if( p_array->i_count == 0 )
+        {
+            free( p_array->pp_elems );
+            p_array->pp_elems = NULL;
+        }
+    }
+}
+
+
+/************************************************************************
+ * Dictionaries
+ ************************************************************************/
+
+/* This function is not intended to be crypto-secure, we only want it to be
+ * fast and not suck too much. This one is pretty fast and did 0 collisions
+ * in wenglish's dictionary.
+ */
+static inline uint64_t DictHash( const char *psz_string, int hashsize )
+{
+    uint64_t i_hash = 0;
+    if( psz_string )
+    {
+        while( *psz_string )
+        {
+            i_hash += *psz_string++;
+            i_hash += i_hash << 10;
+            i_hash ^= i_hash >> 8;
+        }
+    }
+    return i_hash % hashsize;
+}
+
+typedef struct vlc_dictionary_entry_t
+{
+    char *   psz_key;
+    void *   p_value;
+    struct vlc_dictionary_entry_t * p_next;
+} vlc_dictionary_entry_t;
+
+typedef struct vlc_dictionary_t
+{
+    int i_size;
+    vlc_dictionary_entry_t ** p_entries;
+} vlc_dictionary_t;
+
+static void * const kVLCDictionaryNotFound = NULL;
+
+static inline void vlc_dictionary_init( vlc_dictionary_t * p_dict, int i_size )
+{
+    p_dict->p_entries = NULL;
+
+    if( i_size > 0 )
+    {
+        p_dict->p_entries = (vlc_dictionary_entry_t **)calloc( i_size, sizeof(*p_dict->p_entries) );
+        if( !p_dict->p_entries )
+            i_size = 0;
+    }
+    p_dict->i_size = i_size;
+}
+
+static inline void vlc_dictionary_clear( vlc_dictionary_t * p_dict,
+                                         void ( * pf_free )( void * p_data, void * p_obj ),
+                                         void * p_obj )
+{
+    if( p_dict->p_entries )
+    {
+        for( int i = 0; i < p_dict->i_size; i++ )
+        {
+            vlc_dictionary_entry_t * p_current, * p_next;
+            p_current = p_dict->p_entries[i];
+            while( p_current )
+            {
+                p_next = p_current->p_next;
+                if( pf_free != NULL )
+                    ( * pf_free )( p_current->p_value, p_obj );
+                free( p_current->psz_key );
+                free( p_current );
+                p_current = p_next;
+            }
+        }
+        free( p_dict->p_entries );
+        p_dict->p_entries = NULL;
+    }
+    p_dict->i_size = 0;
+}
+
+static inline int
+vlc_dictionary_has_key( const vlc_dictionary_t * p_dict, const char * psz_key )
+{
+    if( !p_dict->p_entries )
+        return 0;
+
+    int i_pos = DictHash( psz_key, p_dict->i_size );
+    return p_dict->p_entries[i_pos] != NULL;
+}
+
+static inline void *
+vlc_dictionary_value_for_key( const vlc_dictionary_t * p_dict, const char * psz_key )
+{
+    if( !p_dict->p_entries )
+        return kVLCDictionaryNotFound;
+
+    int i_pos = DictHash( psz_key, p_dict->i_size );
+    vlc_dictionary_entry_t * p_entry = p_dict->p_entries[i_pos];
+
+    if( !p_entry )
+        return kVLCDictionaryNotFound;
+
+    /* Make sure we return the right item. (Hash collision) */
+    do {
+        if( !strcmp( psz_key, p_entry->psz_key ) )
+            return p_entry->p_value;
+        p_entry = p_entry->p_next;
+    } while( p_entry );
+
+    return kVLCDictionaryNotFound;
+}
+
+static inline int
+vlc_dictionary_keys_count( const vlc_dictionary_t * p_dict )
+{
+    vlc_dictionary_entry_t * p_entry;
+    int i, count = 0;
+
+    if( !p_dict->p_entries )
+        return 0;
+
+    for( i = 0; i < p_dict->i_size; i++ )
+    {
+        for( p_entry = p_dict->p_entries[i]; p_entry; p_entry = p_entry->p_next ) count++;
+    }
+    return count;
+}
+
+static inline char **
+vlc_dictionary_all_keys( const vlc_dictionary_t * p_dict )
+{
+    vlc_dictionary_entry_t * p_entry;
+    char ** ppsz_ret;
+    int i, count = vlc_dictionary_keys_count( p_dict );
+
+    ppsz_ret = (char**)malloc(sizeof(char *) * (count + 1));
+
+    count = 0;
+    for( i = 0; i < p_dict->i_size; i++ )
+    {
+        for( p_entry = p_dict->p_entries[i]; p_entry; p_entry = p_entry->p_next )
+            ppsz_ret[count++] = strdup( p_entry->psz_key );
+    }
+    ppsz_ret[count] = NULL;
+    return ppsz_ret;
+}
+
+static inline void
+__vlc_dictionary_insert( vlc_dictionary_t * p_dict, const char * psz_key,
+                         void * p_value, bool rebuild )
+{
+    if( !p_dict->p_entries )
+        vlc_dictionary_init( p_dict, 1 );
+
+    int i_pos = DictHash( psz_key, p_dict->i_size );
+    vlc_dictionary_entry_t * p_entry;
+
+    p_entry = (vlc_dictionary_entry_t *)malloc(sizeof(*p_entry));
+    p_entry->psz_key = strdup( psz_key );
+    p_entry->p_value = p_value;
+    p_entry->p_next = p_dict->p_entries[i_pos];
+    p_dict->p_entries[i_pos] = p_entry;
+    if( rebuild )
+    {
+        /* Count how many items there was */
+        int count;
+        for( count = 1; p_entry->p_next; count++ )
+            p_entry = p_entry->p_next;
+        if( count > 3 ) /* XXX: this need tuning */
+        {
+            /* Here it starts to be not good, rebuild a bigger dictionary */
+            struct vlc_dictionary_t new_dict;
+            int i_new_size = ( (p_dict->i_size+2) * 3) / 2; /* XXX: this need tuning */
+            int i;
+            vlc_dictionary_init( &new_dict, i_new_size );
+            for( i = 0; i < p_dict->i_size; i++ )
+            {
+                p_entry = p_dict->p_entries[i];
+                while( p_entry )
+                {
+                    __vlc_dictionary_insert( &new_dict, p_entry->psz_key,
+                                             p_entry->p_value,
+                                             false /* To avoid multiple rebuild loop */);
+                    p_entry = p_entry->p_next;
+                }
+            }
+
+            vlc_dictionary_clear( p_dict, NULL, NULL );
+            p_dict->i_size = new_dict.i_size;
+            p_dict->p_entries = new_dict.p_entries;
+        }
+    }
+}
+
+static inline void
+vlc_dictionary_insert( vlc_dictionary_t * p_dict, const char * psz_key, void * p_value )
+{
+    __vlc_dictionary_insert( p_dict, psz_key, p_value, true );
+}
+
+static inline void
+vlc_dictionary_remove_value_for_key( const vlc_dictionary_t * p_dict, const char * psz_key,
+                                     void ( * pf_free )( void * p_data, void * p_obj ),
+                                     void * p_obj )
+{
+    if( !p_dict->p_entries )
+        return;
+
+    int i_pos = DictHash( psz_key, p_dict->i_size );
+    vlc_dictionary_entry_t * p_entry = p_dict->p_entries[i_pos];
+    vlc_dictionary_entry_t * p_prev;
+
+    if( !p_entry )
+        return; /* Not found, nothing to do */
+
+    /* Hash collision */
+    p_prev = NULL;
+    do {
+        if( !strcmp( psz_key, p_entry->psz_key ) )
+        {
+            if( pf_free != NULL )
+                ( * pf_free )( p_entry->p_value, p_obj );
+            if( !p_prev )
+                p_dict->p_entries[i_pos] = p_entry->p_next;
+            else
+                p_prev->p_next = p_entry->p_next;
+            free( p_entry->psz_key );
+            free( p_entry );
+            return;
+        }
+        p_prev = p_entry;
+        p_entry = p_entry->p_next;
+    } while( p_entry );
+
+    /* No key was found */
+}
+
+#ifdef __cplusplus
+// C++ helpers
+template <typename T>
+void vlc_delete_all( T &container )
+{
+    typename T::iterator it = container.begin();
+    while ( it != container.end() )
+    {
+        delete *it;
+        ++it;
+    }
+    container.clear();
+}
+
+#endif
+
+#endif

=== added file 'DivCity/DivCity/vlc/plugins/vlc_art_finder.h'
--- DivCity/DivCity/vlc/plugins/vlc_art_finder.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_art_finder.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,30 @@
+/*****************************************************************************
+ * vlc_art_finder.h
+ *****************************************************************************
+ * Copyright (C) 2009 RÃ©mi Denis-Courmont
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_ART_FINDER_H
+#define VLC_ART_FINDER_H 1
+
+typedef struct art_finder_t
+{
+    VLC_COMMON_MEMBERS
+    input_item_t *p_item;
+} art_finder_t;
+
+#endif

=== added file 'DivCity/DivCity/vlc/plugins/vlc_atomic.h'
--- DivCity/DivCity/vlc/plugins/vlc_atomic.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_atomic.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,73 @@
+/*****************************************************************************
+ * vlc_atomic.h:
+ *****************************************************************************
+ * Copyright (C) 2010 RÃ©mi Denis-Courmont
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_ATOMIC_H
+# define VLC_ATOMIC_H
+
+/**
+ * \file
+ * Atomic operations do not require locking, but they are not very powerful.
+ */
+
+/** Static initializer for \ref vlc_atomic_t */
+# define VLC_ATOMIC_INIT(val) { (val) }
+
+/* All functions return the atom value _after_ the operation. */
+
+VLC_API uintptr_t vlc_atomic_get(const vlc_atomic_t *);
+VLC_API uintptr_t vlc_atomic_set(vlc_atomic_t *, uintptr_t);
+VLC_API uintptr_t vlc_atomic_add(vlc_atomic_t *, uintptr_t);
+
+static inline uintptr_t vlc_atomic_sub (vlc_atomic_t *atom, uintptr_t v)
+{
+    return vlc_atomic_add (atom, -v);
+}
+
+static inline uintptr_t vlc_atomic_inc (vlc_atomic_t *atom)
+{
+    return vlc_atomic_add (atom, 1);
+}
+
+static inline uintptr_t vlc_atomic_dec (vlc_atomic_t *atom)
+{
+    return vlc_atomic_sub (atom, 1);
+}
+
+VLC_API uintptr_t vlc_atomic_swap(vlc_atomic_t *, uintptr_t);
+VLC_API uintptr_t vlc_atomic_compare_swap(vlc_atomic_t *, uintptr_t, uintptr_t);
+
+/** Helper to retrieve a single precision from an atom. */
+static inline float vlc_atomic_getf(const vlc_atomic_t *atom)
+{
+    union { float f; uintptr_t i; } u;
+    u.i = vlc_atomic_get(atom);
+    return u.f;
+}
+
+/** Helper to store a single precision into an atom. */
+static inline float vlc_atomic_setf(vlc_atomic_t *atom, float f)
+{
+    union { float f; uintptr_t i; } u;
+    u.f = f;
+    vlc_atomic_set(atom, u.i);
+    return f;
+}
+
+#endif

=== added file 'DivCity/DivCity/vlc/plugins/vlc_avcodec.h'
--- DivCity/DivCity/vlc/plugins/vlc_avcodec.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_avcodec.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,34 @@
+/*****************************************************************************
+ * vlc_avcodec.h: VLC thread support for FFMPEG/libavcodec
+ *****************************************************************************
+ * Copyright (C) 2009-2010 RÃ©mi Denis-Courmont
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_AVCODEC_H
+# define VLC_AVCODEC_H 1
+
+static inline void vlc_avcodec_lock (void)
+{
+    vlc_global_lock (VLC_AVCODEC_MUTEX);
+}
+
+static inline void vlc_avcodec_unlock (void)
+{
+    vlc_global_unlock (VLC_AVCODEC_MUTEX);
+}
+
+#endif

=== added file 'DivCity/DivCity/vlc/plugins/vlc_bits.h'
--- DivCity/DivCity/vlc/plugins/vlc_bits.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_bits.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,197 @@
+/*****************************************************************************
+ * bits.h : Bit handling helpers
+ *****************************************************************************
+ * Copyright (C) 2003 VLC authors and VideoLAN
+ * $Id: cac52e6cb7281bbac26024cad3fcad1030b3c778 $
+ *
+ * Authors: Laurent Aimar <fenrir@via.ecp.fr>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_BITS_H
+#define VLC_BITS_H 1
+
+/**
+ * \file
+ * This file defines functions, structures for handling streams of bits in vlc
+ */
+
+typedef struct bs_s
+{
+    uint8_t *p_start;
+    uint8_t *p;
+    uint8_t *p_end;
+
+    ssize_t  i_left;    /* i_count number of available bits */
+} bs_t;
+
+static inline void bs_init( bs_t *s, const void *p_data, size_t i_data )
+{
+    s->p_start = (void *)p_data;
+    s->p       = s->p_start;
+    s->p_end   = s->p_start + i_data;
+    s->i_left  = 8;
+}
+
+static inline int bs_pos( const bs_t *s )
+{
+    return( 8 * ( s->p - s->p_start ) + 8 - s->i_left );
+}
+
+static inline int bs_eof( const bs_t *s )
+{
+    return( s->p >= s->p_end ? 1: 0 );
+}
+
+static inline uint32_t bs_read( bs_t *s, int i_count )
+{
+     static const uint32_t i_mask[33] =
+     {  0x00,
+        0x01,      0x03,      0x07,      0x0f,
+        0x1f,      0x3f,      0x7f,      0xff,
+        0x1ff,     0x3ff,     0x7ff,     0xfff,
+        0x1fff,    0x3fff,    0x7fff,    0xffff,
+        0x1ffff,   0x3ffff,   0x7ffff,   0xfffff,
+        0x1fffff,  0x3fffff,  0x7fffff,  0xffffff,
+        0x1ffffff, 0x3ffffff, 0x7ffffff, 0xfffffff,
+        0x1fffffff,0x3fffffff,0x7fffffff,0xffffffff};
+    int      i_shr;
+    uint32_t i_result = 0;
+
+    while( i_count > 0 )
+    {
+        if( s->p >= s->p_end )
+        {
+            break;
+        }
+
+        if( ( i_shr = s->i_left - i_count ) >= 0 )
+        {
+            /* more in the buffer than requested */
+            i_result |= ( *s->p >> i_shr )&i_mask[i_count];
+            s->i_left -= i_count;
+            if( s->i_left == 0 )
+            {
+                s->p++;
+                s->i_left = 8;
+            }
+            return( i_result );
+        }
+        else
+        {
+            /* less in the buffer than requested */
+           i_result |= (*s->p&i_mask[s->i_left]) << -i_shr;
+           i_count  -= s->i_left;
+           s->p++;
+           s->i_left = 8;
+        }
+    }
+
+    return( i_result );
+}
+
+static inline uint32_t bs_read1( bs_t *s )
+{
+    if( s->p < s->p_end )
+    {
+        unsigned int i_result;
+
+        s->i_left--;
+        i_result = ( *s->p >> s->i_left )&0x01;
+        if( s->i_left == 0 )
+        {
+            s->p++;
+            s->i_left = 8;
+        }
+        return i_result;
+    }
+
+    return 0;
+}
+
+static inline uint32_t bs_show( bs_t *s, int i_count )
+{
+    bs_t     s_tmp = *s;
+    return bs_read( &s_tmp, i_count );
+}
+
+static inline void bs_skip( bs_t *s, ssize_t i_count )
+{
+    s->i_left -= i_count;
+
+    if( s->i_left <= 0 )
+    {
+        const int i_bytes = ( -s->i_left + 8 ) / 8;
+
+        s->p += i_bytes;
+        s->i_left += 8 * i_bytes;
+    }
+}
+
+static inline void bs_write( bs_t *s, int i_count, uint32_t i_bits )
+{
+    while( i_count > 0 )
+    {
+        if( s->p >= s->p_end )
+        {
+            break;
+        }
+
+        i_count--;
+
+        if( ( i_bits >> i_count )&0x01 )
+        {
+            *s->p |= 1 << ( s->i_left - 1 );
+        }
+        else
+        {
+            *s->p &= ~( 1 << ( s->i_left - 1 ) );
+        }
+        s->i_left--;
+        if( s->i_left == 0 )
+        {
+            s->p++;
+            s->i_left = 8;
+        }
+    }
+}
+
+static inline void bs_align( bs_t *s )
+{
+    if( s->i_left != 8 )
+    {
+        s->i_left = 8;
+        s->p++;
+    }
+}
+
+static inline void bs_align_0( bs_t *s )
+{
+    if( s->i_left != 8 )
+    {
+        bs_write( s, s->i_left, 0 );
+    }
+}
+
+static inline void bs_align_1( bs_t *s )
+{
+    while( s->i_left != 8 )
+    {
+        bs_write( s, 1, 1 );
+    }
+}
+
+#endif

=== added file 'DivCity/DivCity/vlc/plugins/vlc_block.h'
--- DivCity/DivCity/vlc/plugins/vlc_block.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_block.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,318 @@
+/*****************************************************************************
+ * vlc_block.h: Data blocks management functions
+ *****************************************************************************
+ * Copyright (C) 2003 VLC authors and VideoLAN
+ * $Id: 3fed8a33eb5789690847013af2d8da9d2dea853f $
+ *
+ * Authors: Laurent Aimar <fenrir@via.ecp.fr>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_BLOCK_H
+#define VLC_BLOCK_H 1
+
+/**
+ * \file
+ * This file implements functions and structures to handle blocks of data in vlc
+ *
+ */
+
+#include <sys/types.h>  /* for ssize_t */
+
+/****************************************************************************
+ * block:
+ ****************************************************************************
+ * - block_sys_t is opaque and thus block_t->p_sys is PRIVATE
+ * - i_flags may not always be set (ie could be 0, even for a key frame
+ *      it depends where you receive the buffer (before/after a packetizer
+ *      and the demux/packetizer implementations.
+ * - i_dts/i_pts could be VLC_TS_INVALID, it means no pts/dts
+ * - i_length: length in microseond of the packet, can be null except in the
+ *      sout where it is mandatory.
+ *
+ * - i_buffer number of valid data pointed by p_buffer
+ *      you can freely decrease it but never increase it yourself
+ *      (use block_Realloc)
+ * - p_buffer: pointer over datas. You should never overwrite it, you can
+ *   only incremment it to skip datas, in others cases use block_Realloc
+ *   (don't duplicate yourself in a bigger buffer, block_Realloc is
+ *   optimised for preheader/postdatas increase)
+ ****************************************************************************/
+typedef struct block_sys_t block_sys_t;
+
+/** The content doesn't follow the last block, or is probably broken */
+#define BLOCK_FLAG_DISCONTINUITY 0x0001
+/** Intra frame */
+#define BLOCK_FLAG_TYPE_I        0x0002
+/** Inter frame with backward reference only */
+#define BLOCK_FLAG_TYPE_P        0x0004
+/** Inter frame with backward and forward reference */
+#define BLOCK_FLAG_TYPE_B        0x0008
+/** For inter frame when you don't know the real type */
+#define BLOCK_FLAG_TYPE_PB       0x0010
+/** Warn that this block is a header one */
+#define BLOCK_FLAG_HEADER        0x0020
+/** This is the last block of the frame */
+#define BLOCK_FLAG_END_OF_FRAME  0x0040
+/** This is not a key frame for bitrate shaping */
+#define BLOCK_FLAG_NO_KEYFRAME   0x0080
+/** This block contains the last part of a sequence  */
+#define BLOCK_FLAG_END_OF_SEQUENCE 0x0100
+/** This block contains a clock reference */
+#define BLOCK_FLAG_CLOCK         0x0200
+/** This block is scrambled */
+#define BLOCK_FLAG_SCRAMBLED     0x0400
+/** This block has to be decoded but not be displayed */
+#define BLOCK_FLAG_PREROLL       0x0800
+/** This block is corrupted and/or there is data loss  */
+#define BLOCK_FLAG_CORRUPTED     0x1000
+/** This block contains an interlaced picture with top field first */
+#define BLOCK_FLAG_TOP_FIELD_FIRST 0x2000
+/** This block contains an interlaced picture with bottom field first */
+#define BLOCK_FLAG_BOTTOM_FIELD_FIRST 0x4000
+
+/** This block contains an interlaced picture */
+#define BLOCK_FLAG_INTERLACED_MASK \
+    (BLOCK_FLAG_TOP_FIELD_FIRST|BLOCK_FLAG_BOTTOM_FIELD_FIRST)
+
+#define BLOCK_FLAG_TYPE_MASK \
+    (BLOCK_FLAG_TYPE_I|BLOCK_FLAG_TYPE_P|BLOCK_FLAG_TYPE_B|BLOCK_FLAG_TYPE_PB)
+
+/* These are for input core private usage only */
+#define BLOCK_FLAG_CORE_PRIVATE_MASK  0x00ff0000
+#define BLOCK_FLAG_CORE_PRIVATE_SHIFT 16
+
+/* These are for module private usage only */
+#define BLOCK_FLAG_PRIVATE_MASK  0xff000000
+#define BLOCK_FLAG_PRIVATE_SHIFT 24
+
+typedef void (*block_free_t) (block_t *);
+
+struct block_t
+{
+    block_t     *p_next;
+
+    uint8_t     *p_buffer;
+    size_t      i_buffer;
+
+    uint32_t    i_flags;
+    unsigned    i_nb_samples; /* Used for audio */
+
+    mtime_t     i_pts;
+    mtime_t     i_dts;
+    mtime_t     i_length;
+
+    /* Rudimentary support for overloading block (de)allocation. */
+    block_free_t pf_release;
+};
+
+/****************************************************************************
+ * Blocks functions:
+ ****************************************************************************
+ * - block_Alloc : create a new block with the requested size ( >= 0 ), return
+ *      NULL for failure.
+ * - block_Release : release a block allocated with block_Alloc.
+ * - block_Realloc : realloc a block,
+ *      i_pre: how many bytes to insert before body if > 0, else how many
+ *      bytes of body to skip (the latter can be done without using
+ *      block_Realloc i_buffer -= -i_pre, p_buffer += -i_pre as i_pre < 0)
+ *      i_body (>= 0): the final size of the body (decreasing it can directly
+ *      be done with i_buffer = i_body).
+ *      with preheader and or body (increase
+ *      and decrease are supported). Use it as it is optimised.
+ * - block_Duplicate : create a copy of a block.
+ ****************************************************************************/
+VLC_API void block_Init( block_t *, void *, size_t );
+VLC_API block_t * block_Alloc( size_t ) VLC_USED;
+VLC_API block_t * block_Realloc( block_t *, ssize_t i_pre, size_t i_body ) VLC_USED;
+
+#define block_New( dummy, size ) block_Alloc(size)
+
+VLC_USED
+static inline block_t *block_Duplicate( block_t *p_block )
+{
+    block_t *p_dup = block_Alloc( p_block->i_buffer );
+    if( p_dup == NULL )
+        return NULL;
+
+    p_dup->i_flags   = p_block->i_flags;
+    p_dup->i_nb_samples = p_block->i_nb_samples;
+    p_dup->i_dts     = p_block->i_dts;
+    p_dup->i_pts     = p_block->i_pts;
+    p_dup->i_length  = p_block->i_length;
+    memcpy( p_dup->p_buffer, p_block->p_buffer, p_block->i_buffer );
+
+    return p_dup;
+}
+
+static inline void block_Release( block_t *p_block )
+{
+    p_block->pf_release( p_block );
+}
+
+VLC_API block_t * block_heap_Alloc(void *, void *, size_t) VLC_USED;
+VLC_API block_t * block_mmap_Alloc(void *addr, size_t length) VLC_USED;
+VLC_API block_t * block_File(int fd) VLC_USED;
+
+static inline void block_Cleanup (void *block)
+{
+    block_Release ((block_t *)block);
+}
+#define block_cleanup_push( block ) vlc_cleanup_push (block_Cleanup, block)
+
+/****************************************************************************
+ * Chains of blocks functions helper
+ ****************************************************************************
+ * - block_ChainAppend : append a block to the last block of a chain. Try to
+ *      avoid using with a lot of data as it's really slow, prefer
+ *      block_ChainLastAppend, p_block can be NULL
+ * - block_ChainLastAppend : use a pointer over a pointer to the next blocks,
+ *      and update it.
+ * - block_ChainRelease : release a chain of block
+ * - block_ChainExtract : extract data from a chain, return real bytes counts
+ * - block_ChainGather : gather a chain, free it and return one block.
+ ****************************************************************************/
+static inline void block_ChainAppend( block_t **pp_list, block_t *p_block )
+{
+    if( *pp_list == NULL )
+    {
+        *pp_list = p_block;
+    }
+    else
+    {
+        block_t *p = *pp_list;
+
+        while( p->p_next ) p = p->p_next;
+        p->p_next = p_block;
+    }
+}
+
+static inline void block_ChainLastAppend( block_t ***ppp_last, block_t *p_block )
+{
+    block_t *p_last = p_block;
+
+    **ppp_last = p_block;
+
+    while( p_last->p_next ) p_last = p_last->p_next;
+    *ppp_last = &p_last->p_next;
+}
+
+static inline void block_ChainRelease( block_t *p_block )
+{
+    while( p_block )
+    {
+        block_t *p_next = p_block->p_next;
+        block_Release( p_block );
+        p_block = p_next;
+    }
+}
+
+static size_t block_ChainExtract( block_t *p_list, void *p_data, size_t i_max )
+{
+    size_t  i_total = 0;
+    uint8_t *p = (uint8_t*)p_data;
+
+    while( p_list && i_max )
+    {
+        size_t i_copy = __MIN( i_max, p_list->i_buffer );
+        memcpy( p, p_list->p_buffer, i_copy );
+        i_max   -= i_copy;
+        i_total += i_copy;
+        p       += i_copy;
+
+        p_list = p_list->p_next;
+    }
+    return i_total;
+}
+
+static inline void block_ChainProperties( block_t *p_list, int *pi_count, size_t *pi_size, mtime_t *pi_length )
+{
+    size_t i_size = 0;
+    mtime_t i_length = 0;
+    int i_count = 0;
+
+    while( p_list )
+    {
+        i_size += p_list->i_buffer;
+        i_length += p_list->i_length;
+        i_count++;
+
+        p_list = p_list->p_next;
+    }
+
+    if( pi_size )
+        *pi_size = i_size;
+    if( pi_length )
+        *pi_length = i_length;
+    if( pi_count )
+        *pi_count = i_count;
+}
+
+static inline block_t *block_ChainGather( block_t *p_list )
+{
+    size_t  i_total = 0;
+    mtime_t i_length = 0;
+    block_t *g;
+
+    if( p_list->p_next == NULL )
+        return p_list;  /* Already gathered */
+
+    block_ChainProperties( p_list, NULL, &i_total, &i_length );
+
+    g = block_Alloc( i_total );
+    block_ChainExtract( p_list, g->p_buffer, g->i_buffer );
+
+    g->i_flags = p_list->i_flags;
+    g->i_pts   = p_list->i_pts;
+    g->i_dts   = p_list->i_dts;
+    g->i_length = i_length;
+
+    /* free p_list */
+    block_ChainRelease( p_list );
+    return g;
+}
+
+/****************************************************************************
+ * Fifos of blocks.
+ ****************************************************************************
+ * - block_FifoNew : create and init a new fifo
+ * - block_FifoRelease : destroy a fifo and free all blocks in it.
+ * - block_FifoPace : wait for a fifo to drain to a specified number of packets or total data size
+ * - block_FifoEmpty : free all blocks in a fifo
+ * - block_FifoPut : put a block
+ * - block_FifoGet : get a packet from the fifo (and wait if it is empty)
+ * - block_FifoShow : show the first packet of the fifo (and wait if
+ *      needed), be carefull, you can use it ONLY if you are sure to be the
+ *      only one getting data from the fifo.
+ * - block_FifoCount : how many packets are waiting in the fifo
+ * - block_FifoWake : wake ups a thread with block_FifoGet() = NULL
+ *   (this is used to wakeup a thread when there is no data to queue)
+ *
+ * block_FifoGet and block_FifoShow are cancellation points.
+ ****************************************************************************/
+
+VLC_API block_fifo_t * block_FifoNew( void ) VLC_USED;
+VLC_API void block_FifoRelease( block_fifo_t * );
+VLC_API void block_FifoPace( block_fifo_t *fifo, size_t max_depth, size_t max_size );
+VLC_API void block_FifoEmpty( block_fifo_t * );
+VLC_API size_t block_FifoPut( block_fifo_t *, block_t * );
+VLC_API void block_FifoWake( block_fifo_t * );
+VLC_API block_t * block_FifoGet( block_fifo_t * ) VLC_USED;
+VLC_API block_t * block_FifoShow( block_fifo_t * );
+size_t block_FifoSize( const block_fifo_t *p_fifo ) VLC_USED;
+VLC_API size_t block_FifoCount( const block_fifo_t *p_fifo ) VLC_USED;
+
+#endif /* VLC_BLOCK_H */

=== added file 'DivCity/DivCity/vlc/plugins/vlc_block_helper.h'
--- DivCity/DivCity/vlc/plugins/vlc_block_helper.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_block_helper.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,520 @@
+/*****************************************************************************
+ * vlc_block_helper.h: Helper functions for data blocks management.
+ *****************************************************************************
+ * Copyright (C) 2003 VLC authors and VideoLAN
+ * $Id: 903a0f0857a8fcac12b2863d6a0c46b267d473a1 $
+ *
+ * Authors: Gildas Bazin <gbazin@netcourrier.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_BLOCK_HELPER_H
+#define VLC_BLOCK_HELPER_H 1
+
+#include <vlc_block.h>
+
+typedef struct block_bytestream_t
+{
+    block_t *p_chain;  /**< byte stream head block */
+    block_t *p_block;  /**< byte stream read pointer block */
+    size_t   i_offset; /**< byte stream read pointer offset within block */
+    /* TODO? add tail pointer for faster push? */
+} block_bytestream_t;
+
+/*****************************************************************************
+ * block_bytestream_t management
+ *****************************************************************************/
+static inline void block_BytestreamInit( block_bytestream_t *p_bytestream )
+{
+    p_bytestream->p_chain = p_bytestream->p_block = NULL;
+    p_bytestream->i_offset = 0;
+}
+
+static inline void block_BytestreamRelease( block_bytestream_t *p_bytestream )
+{
+    for( block_t *block = p_bytestream->p_chain; block != NULL; )
+    {
+        block_t *p_next = block->p_next;
+
+        block_Release( block );
+        block = p_next;
+    }
+}
+
+/**
+ * It flush all data (read and unread) from a block_bytestream_t.
+ */
+static inline void block_BytestreamEmpty( block_bytestream_t *p_bytestream )
+{
+    block_BytestreamRelease( p_bytestream );
+    block_BytestreamInit( p_bytestream );
+}
+
+/**
+ * It flushes all already read data from a block_bytestream_t.
+ */
+static inline void block_BytestreamFlush( block_bytestream_t *p_bytestream )
+{
+    block_t *block = p_bytestream->p_chain;
+
+    while( block != p_bytestream->p_block )
+    {
+        block_t *p_next = block->p_next;
+
+        block_Release( block );
+        block = p_next;
+    }
+
+    while( block != NULL && block->i_buffer == p_bytestream->i_offset )
+    {
+        block_t *p_next = block->p_next;
+
+        block_Release( block );
+        block = p_next;
+        p_bytestream->i_offset = 0;
+    }
+
+    p_bytestream->p_chain = p_bytestream->p_block = block;
+}
+
+static inline void block_BytestreamPush( block_bytestream_t *p_bytestream,
+                                         block_t *p_block )
+{
+    block_ChainAppend( &p_bytestream->p_chain, p_block );
+    if( !p_bytestream->p_block ) p_bytestream->p_block = p_block;
+}
+
+VLC_USED
+static inline block_t *block_BytestreamPop( block_bytestream_t *p_bytestream )
+{
+    block_t *p_block;
+
+    block_BytestreamFlush( p_bytestream );
+
+    p_block = p_bytestream->p_block;
+    if( p_block == NULL )
+    {
+        return NULL;
+    }
+    else if( !p_block->p_next )
+    {
+        p_block->p_buffer += p_bytestream->i_offset;
+        p_block->i_buffer -= p_bytestream->i_offset;
+        p_bytestream->i_offset = 0;
+        p_bytestream->p_chain = p_bytestream->p_block = NULL;
+        return p_block;
+    }
+
+    while( p_block->p_next && p_block->p_next->p_next )
+        p_block = p_block->p_next;
+
+    {
+        block_t *p_block_old = p_block;
+        p_block = p_block->p_next;
+        p_block_old->p_next = NULL;
+    }
+
+    return p_block;
+}
+
+static inline int block_SkipByte( block_bytestream_t *p_bytestream )
+{
+    /* Most common case first */
+    if( p_bytestream->p_block->i_buffer - p_bytestream->i_offset )
+    {
+        p_bytestream->i_offset++;
+        return VLC_SUCCESS;
+    }
+    else
+    {
+        block_t *p_block;
+
+        /* Less common case which is also slower */
+        for( p_block = p_bytestream->p_block->p_next;
+             p_block != NULL; p_block = p_block->p_next )
+        {
+            if( p_block->i_buffer )
+            {
+                p_bytestream->i_offset = 1;
+                p_bytestream->p_block = p_block;
+                return VLC_SUCCESS;
+            }
+        }
+    }
+
+    /* Not enough data, bail out */
+    return VLC_EGENERIC;
+}
+
+static inline int block_PeekByte( block_bytestream_t *p_bytestream,
+                                  uint8_t *p_data )
+{
+    /* Most common case first */
+    if( p_bytestream->p_block->i_buffer - p_bytestream->i_offset )
+    {
+        *p_data = p_bytestream->p_block->p_buffer[p_bytestream->i_offset];
+        return VLC_SUCCESS;
+    }
+    else
+    {
+        block_t *p_block;
+
+        /* Less common case which is also slower */
+        for( p_block = p_bytestream->p_block->p_next;
+             p_block != NULL; p_block = p_block->p_next )
+        {
+            if( p_block->i_buffer )
+            {
+                *p_data = p_block->p_buffer[0];
+                return VLC_SUCCESS;
+            }
+        }
+    }
+
+    /* Not enough data, bail out */
+    return VLC_EGENERIC;
+}
+
+static inline int block_GetByte( block_bytestream_t *p_bytestream,
+                                 uint8_t *p_data )
+{
+    /* Most common case first */
+    if( p_bytestream->p_block->i_buffer - p_bytestream->i_offset )
+    {
+        *p_data = p_bytestream->p_block->p_buffer[p_bytestream->i_offset];
+        p_bytestream->i_offset++;
+        return VLC_SUCCESS;
+    }
+    else
+    {
+        block_t *p_block;
+
+        /* Less common case which is also slower */
+        for( p_block = p_bytestream->p_block->p_next;
+             p_block != NULL; p_block = p_block->p_next )
+        {
+            if( p_block->i_buffer )
+            {
+                *p_data = p_block->p_buffer[0];
+                p_bytestream->i_offset = 1;
+                p_bytestream->p_block = p_block;
+                return VLC_SUCCESS;
+            }
+        }
+    }
+
+    /* Not enough data, bail out */
+    return VLC_EGENERIC;
+}
+
+static inline int block_WaitBytes( block_bytestream_t *p_bytestream,
+                                   size_t i_data )
+{
+    block_t *p_block;
+    size_t i_offset, i_copy, i_size;
+
+    /* Check we have that much data */
+    i_offset = p_bytestream->i_offset;
+    i_size = i_data;
+    i_copy = 0;
+    for( p_block = p_bytestream->p_block;
+         p_block != NULL; p_block = p_block->p_next )
+    {
+        i_copy = __MIN( i_size, p_block->i_buffer - i_offset );
+        i_size -= i_copy;
+        i_offset = 0;
+
+        if( !i_size ) break;
+    }
+
+    if( i_size )
+    {
+        /* Not enough data, bail out */
+        return VLC_EGENERIC;
+    }
+    return VLC_SUCCESS;
+}
+
+static inline int block_SkipBytes( block_bytestream_t *p_bytestream,
+                                   size_t i_data )
+{
+    block_t *p_block;
+    size_t i_offset, i_copy;
+
+    /* Check we have that much data */
+    i_offset = p_bytestream->i_offset;
+    i_copy = 0;
+    for( p_block = p_bytestream->p_block;
+         p_block != NULL; p_block = p_block->p_next )
+    {
+        i_copy = __MIN( i_data, p_block->i_buffer - i_offset );
+        i_data -= i_copy;
+
+        if( !i_data ) break;
+
+        i_offset = 0;
+    }
+
+    if( i_data )
+    {
+        /* Not enough data, bail out */
+        return VLC_EGENERIC;
+    }
+
+    p_bytestream->p_block = p_block;
+    p_bytestream->i_offset = i_offset + i_copy;
+    return VLC_SUCCESS;
+}
+
+static inline int block_PeekBytes( block_bytestream_t *p_bytestream,
+                                   uint8_t *p_data, size_t i_data )
+{
+    block_t *p_block;
+    size_t i_offset, i_copy, i_size;
+
+    /* Check we have that much data */
+    i_offset = p_bytestream->i_offset;
+    i_size = i_data;
+    i_copy = 0;
+    for( p_block = p_bytestream->p_block;
+         p_block != NULL; p_block = p_block->p_next )
+    {
+        i_copy = __MIN( i_size, p_block->i_buffer - i_offset );
+        i_size -= i_copy;
+        i_offset = 0;
+
+        if( !i_size ) break;
+    }
+
+    if( i_size )
+    {
+        /* Not enough data, bail out */
+        return VLC_EGENERIC;
+    }
+
+    /* Copy the data */
+    i_offset = p_bytestream->i_offset;
+    i_size = i_data;
+    i_copy = 0;
+    for( p_block = p_bytestream->p_block;
+         p_block != NULL; p_block = p_block->p_next )
+    {
+        i_copy = __MIN( i_size, p_block->i_buffer - i_offset );
+        i_size -= i_copy;
+
+        if( i_copy )
+        {
+            memcpy( p_data, p_block->p_buffer + i_offset, i_copy );
+            p_data += i_copy;
+        }
+
+        i_offset = 0;
+
+        if( !i_size ) break;
+    }
+
+    return VLC_SUCCESS;
+}
+
+static inline int block_GetBytes( block_bytestream_t *p_bytestream,
+                                  uint8_t *p_data, size_t i_data )
+{
+    block_t *p_block;
+    size_t i_offset, i_copy, i_size;
+
+    /* Check we have that much data */
+    i_offset = p_bytestream->i_offset;
+    i_size = i_data;
+    i_copy = 0;
+    for( p_block = p_bytestream->p_block;
+         p_block != NULL; p_block = p_block->p_next )
+    {
+        i_copy = __MIN( i_size, p_block->i_buffer - i_offset );
+        i_size -= i_copy;
+        i_offset = 0;
+
+        if( !i_size ) break;
+    }
+
+    if( i_size )
+    {
+        /* Not enough data, bail out */
+        return VLC_EGENERIC;
+    }
+
+    /* Copy the data */
+    i_offset = p_bytestream->i_offset;
+    i_size = i_data;
+    i_copy = 0;
+    for( p_block = p_bytestream->p_block;
+         p_block != NULL; p_block = p_block->p_next )
+    {
+        i_copy = __MIN( i_size, p_block->i_buffer - i_offset );
+        i_size -= i_copy;
+
+        if( i_copy )
+        {
+            memcpy( p_data, p_block->p_buffer + i_offset, i_copy );
+            p_data += i_copy;
+        }
+
+        if( !i_size ) break;
+
+        i_offset = 0;
+    }
+
+    /* No buffer given, just skip the data */
+    p_bytestream->p_block = p_block;
+    p_bytestream->i_offset = i_offset + i_copy;
+
+    return VLC_SUCCESS;
+}
+
+static inline int block_PeekOffsetBytes( block_bytestream_t *p_bytestream,
+    size_t i_peek_offset, uint8_t *p_data, size_t i_data )
+{
+    block_t *p_block;
+    size_t i_offset, i_copy, i_size;
+
+    /* Check we have that much data */
+    i_offset = p_bytestream->i_offset;
+    i_size = i_data + i_peek_offset;
+    i_copy = 0;
+    for( p_block = p_bytestream->p_block;
+         p_block != NULL; p_block = p_block->p_next )
+    {
+        i_copy = __MIN( i_size, p_block->i_buffer - i_offset );
+        i_size -= i_copy;
+        i_offset = 0;
+
+        if( !i_size ) break;
+    }
+
+    if( i_size )
+    {
+        /* Not enough data, bail out */
+        return VLC_EGENERIC;
+    }
+
+    /* Find the right place */
+    i_offset = p_bytestream->i_offset;
+    i_size = i_peek_offset;
+    i_copy = 0;
+    for( p_block = p_bytestream->p_block;
+         p_block != NULL; p_block = p_block->p_next )
+    {
+        i_copy = __MIN( i_size, p_block->i_buffer - i_offset );
+        i_size -= i_copy;
+
+        if( !i_size ) break;
+
+        i_offset = 0;
+    }
+
+    /* Copy the data */
+    i_offset += i_copy;
+    i_size = i_data;
+    i_copy = 0;
+    for( ; p_block != NULL; p_block = p_block->p_next )
+    {
+        i_copy = __MIN( i_size, p_block->i_buffer - i_offset );
+        i_size -= i_copy;
+
+        if( i_copy )
+        {
+            memcpy( p_data, p_block->p_buffer + i_offset, i_copy );
+            p_data += i_copy;
+        }
+
+        i_offset = 0;
+
+        if( !i_size ) break;
+    }
+
+    return VLC_SUCCESS;
+}
+
+static inline int block_FindStartcodeFromOffset(
+    block_bytestream_t *p_bytestream, size_t *pi_offset,
+    const uint8_t *p_startcode, int i_startcode_length )
+{
+    block_t *p_block, *p_block_backup = 0;
+    int i_size = 0;
+    size_t i_offset, i_offset_backup = 0;
+    int i_caller_offset_backup = 0, i_match;
+
+    /* Find the right place */
+    i_size = *pi_offset + p_bytestream->i_offset;
+    for( p_block = p_bytestream->p_block;
+         p_block != NULL; p_block = p_block->p_next )
+    {
+        i_size -= p_block->i_buffer;
+        if( i_size < 0 ) break;
+    }
+
+    if( i_size >= 0 )
+    {
+        /* Not enough data, bail out */
+        return VLC_EGENERIC;
+    }
+
+    /* Begin the search.
+     * We first look for an occurrence of the 1st startcode byte and
+     * if found, we do a more thorough check. */
+    i_size += p_block->i_buffer;
+    *pi_offset -= i_size;
+    i_match = 0;
+    for( ; p_block != NULL; p_block = p_block->p_next )
+    {
+        for( i_offset = i_size; i_offset < p_block->i_buffer; i_offset++ )
+        {
+            if( p_block->p_buffer[i_offset] == p_startcode[i_match] )
+            {
+                if( !i_match )
+                {
+                    p_block_backup = p_block;
+                    i_offset_backup = i_offset;
+                    i_caller_offset_backup = *pi_offset;
+                }
+
+                if( i_match + 1 == i_startcode_length )
+                {
+                    /* We have it */
+                    *pi_offset += i_offset - i_match;
+                    return VLC_SUCCESS;
+                }
+
+                i_match++;
+            }
+            else if ( i_match )
+            {
+                /* False positive */
+                p_block = p_block_backup;
+                i_offset = i_offset_backup;
+                *pi_offset = i_caller_offset_backup;
+                i_match = 0;
+            }
+
+        }
+        i_size = 0;
+        *pi_offset += i_offset;
+    }
+
+    *pi_offset -= i_match;
+    return VLC_EGENERIC;
+}
+
+#endif /* VLC_BLOCK_HELPER_H */

=== added file 'DivCity/DivCity/vlc/plugins/vlc_charset.h'
--- DivCity/DivCity/vlc/plugins/vlc_charset.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_charset.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,120 @@
+/*****************************************************************************
+ * charset.h: Unicode UTF-8 wrappers function
+ *****************************************************************************
+ * Copyright (C) 2003-2005 VLC authors and VideoLAN
+ * Copyright Â© 2005-2010 RÃ©mi Denis-Courmont
+ * $Id: cd4d40725344eda07f51dd16f11aeadc351141e8 $
+ *
+ * Author: RÃ©mi Denis-Courmont <rem # videolan,org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_CHARSET_H
+#define VLC_CHARSET_H 1
+
+/**
+ * \file
+ * This files handles locale conversions in vlc
+ */
+
+/* iconv wrappers (defined in src/extras/libc.c) */
+typedef void *vlc_iconv_t;
+VLC_API vlc_iconv_t vlc_iconv_open( const char *, const char * ) VLC_USED;
+VLC_API size_t vlc_iconv( vlc_iconv_t, const char **, size_t *, char **, size_t * ) VLC_USED;
+VLC_API int vlc_iconv_close( vlc_iconv_t );
+
+#include <stdarg.h>
+
+VLC_API void LocaleFree( const char * );
+VLC_API char * FromLocale( const char * ) VLC_USED;
+VLC_API char * FromLocaleDup( const char * ) VLC_USED;
+VLC_API char * ToLocale( const char * ) VLC_USED;
+VLC_API char * ToLocaleDup( const char * ) VLC_USED;
+
+VLC_API int utf8_vfprintf( FILE *stream, const char *fmt, va_list ap );
+VLC_API int utf8_fprintf( FILE *, const char *, ... ) VLC_FORMAT( 2, 3 );
+VLC_API char * vlc_strcasestr(const char *, const char *) VLC_USED;
+
+VLC_API char * EnsureUTF8( char * );
+VLC_API const char * IsUTF8( const char * ) VLC_USED;
+
+#ifdef WIN32
+VLC_USED
+static inline char *FromWide (const wchar_t *wide)
+{
+    size_t len = WideCharToMultiByte (CP_UTF8, 0, wide, -1, NULL, 0, NULL, NULL);
+    if (len == 0)
+        return NULL;
+
+    char *out = (char *)malloc (len);
+
+    if (likely(out))
+        WideCharToMultiByte (CP_UTF8, 0, wide, -1, out, len, NULL, NULL);
+    return out;
+}
+
+VLC_USED
+static inline wchar_t *ToWide (const char *utf8)
+{
+    int len = MultiByteToWideChar (CP_UTF8, 0, utf8, -1, NULL, 0);
+    if (len == 0)
+        return NULL;
+
+    wchar_t *out = (wchar_t *)malloc (len * sizeof (wchar_t));
+
+    if (likely(out))
+        MultiByteToWideChar (CP_UTF8, 0, utf8, -1, out, len);
+    return out;
+}
+#endif
+
+/**
+ * Converts a nul-terminated string from ISO-8859-1 to UTF-8.
+ */
+static inline char *FromLatin1 (const char *latin)
+{
+    char *str = (char *)malloc (2 * strlen (latin) + 1), *utf8 = str;
+    unsigned char c;
+
+    if (str == NULL)
+        return NULL;
+
+    while ((c = *(latin++)) != '\0')
+    {
+         if (c >= 0x80)
+         {
+             *(utf8++) = 0xC0 | (c >> 6);
+             *(utf8++) = 0x80 | (c & 0x3F);
+         }
+         else
+             *(utf8++) = c;
+    }
+    *(utf8++) = '\0';
+
+    utf8 = (char *)realloc (str, utf8 - str);
+    return utf8 ? utf8 : str;
+}
+
+VLC_API char * FromCharset( const char *charset, const void *data, size_t data_size ) VLC_USED;
+VLC_API void * ToCharset( const char *charset, const char *in, size_t *outsize ) VLC_USED;
+
+VLC_API double us_strtod( const char *, char ** ) VLC_USED;
+VLC_API float us_strtof( const char *, char ** ) VLC_USED;
+VLC_API double us_atof( const char * ) VLC_USED;
+VLC_API int us_vasprintf( char **, const char *, va_list );
+VLC_API int us_asprintf( char **, const char *, ... ) VLC_USED;
+
+#endif

=== added file 'DivCity/DivCity/vlc/plugins/vlc_codec.h'
--- DivCity/DivCity/vlc/plugins/vlc_codec.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_codec.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,246 @@
+/*****************************************************************************
+ * vlc_codec.h: Definition of the decoder and encoder structures
+ *****************************************************************************
+ * Copyright (C) 1999-2003 VLC authors and VideoLAN
+ * $Id: beac8fd83d01576098e0fde46deb093ef75ba63d $
+ *
+ * Authors: Gildas Bazin <gbazin@netcourrier.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_CODEC_H
+#define VLC_CODEC_H 1
+
+#include <vlc_block.h>
+#include <vlc_es.h>
+#include <vlc_picture.h>
+#include <vlc_subpicture.h>
+
+/**
+ * \file
+ * This file defines the structure and types used by decoders and encoders
+ */
+
+typedef struct decoder_owner_sys_t decoder_owner_sys_t;
+
+/**
+ * \defgroup decoder Decoder
+ *
+ * The structure describing a decoder
+ *
+ * @{
+ */
+
+/*
+ * BIG FAT WARNING : the code relies in the first 4 members of filter_t
+ * and decoder_t to be the same, so if you have anything to add, do it
+ * at the end of the structure.
+ */
+struct decoder_t
+{
+    VLC_COMMON_MEMBERS
+
+    /* Module properties */
+    module_t *          p_module;
+    decoder_sys_t *     p_sys;
+
+    /* Input format ie from demuxer (XXX: a lot of field could be invalid) */
+    es_format_t         fmt_in;
+
+    /* Output format of decoder/packetizer */
+    es_format_t         fmt_out;
+
+    /* Some decoders only accept packetized data (ie. not truncated) */
+    bool                b_need_packetized;
+
+    /* Tell the decoder if it is allowed to drop frames */
+    bool                b_pace_control;
+
+    /* */
+    picture_t *         ( * pf_decode_video )( decoder_t *, block_t ** );
+    aout_buffer_t *     ( * pf_decode_audio )( decoder_t *, block_t ** );
+    subpicture_t *      ( * pf_decode_sub)   ( decoder_t *, block_t ** );
+    block_t *           ( * pf_packetize )   ( decoder_t *, block_t ** );
+
+    /* Closed Caption (CEA 608/708) extraction.
+     * If set, it *may* be called after pf_decode_video/pf_packetize
+     * returned data. It should return CC for the pictures returned by the
+     * last pf_packetize/pf_decode_video call only,
+     * pb_present will be used to known which cc channel are present (but
+     * globaly, not necessary for the current packet */
+    block_t *           ( * pf_get_cc )      ( decoder_t *, bool pb_present[4] );
+
+    /* Meta data at codec level
+     *  The decoder owner set it back to NULL once it has retreived what it needs.
+     *  The decoder owner is responsible of its release except when you overwrite it.
+     */
+    vlc_meta_t          *p_description;
+
+    /*
+     * Owner fields
+     * XXX You MUST not use them directly.
+     */
+
+    /* Video output callbacks
+     * XXX use decoder_NewPicture/decoder_DeletePicture
+     * and decoder_LinkPicture/decoder_UnlinkPicture */
+    picture_t      *(*pf_vout_buffer_new)( decoder_t * );
+    void            (*pf_vout_buffer_del)( decoder_t *, picture_t * );
+    void            (*pf_picture_link)   ( decoder_t *, picture_t * );
+    void            (*pf_picture_unlink) ( decoder_t *, picture_t * );
+
+    /**
+     * Number of extra (ie in addition to the DPB) picture buffers
+     * needed for decoding.
+     */
+    int             i_extra_picture_buffers;
+
+    /* Audio output callbacks
+     * XXX use decoder_NewAudioBuffer/decoder_DeleteAudioBuffer */
+    aout_buffer_t  *(*pf_aout_buffer_new)( decoder_t *, int );
+
+    /* SPU output callbacks
+     * XXX use decoder_NewSubpicture and decoder_DeleteSubpicture */
+    subpicture_t   *(*pf_spu_buffer_new)( decoder_t *, const subpicture_updater_t * );
+    void            (*pf_spu_buffer_del)( decoder_t *, subpicture_t * );
+
+    /* Input attachments
+     * XXX use decoder_GetInputAttachments */
+    int             (*pf_get_attachments)( decoder_t *p_dec, input_attachment_t ***ppp_attachment, int *pi_attachment );
+
+    /* Display date
+     * XXX use decoder_GetDisplayDate */
+    mtime_t         (*pf_get_display_date)( decoder_t *, mtime_t );
+
+    /* Display rate
+     * XXX use decoder_GetDisplayRate */
+    int             (*pf_get_display_rate)( decoder_t * );
+
+    /* Private structure for the owner of the decoder */
+    decoder_owner_sys_t *p_owner;
+
+    bool                b_error;
+};
+
+/**
+ * @}
+ */
+
+/**
+ * \defgroup encoder Encoder
+ *
+ * The structure describing a Encoder
+ *
+ * @{
+ */
+
+struct encoder_t
+{
+    VLC_COMMON_MEMBERS
+
+    /* Module properties */
+    module_t *          p_module;
+    encoder_sys_t *     p_sys;
+
+    /* Properties of the input data fed to the encoder */
+    es_format_t         fmt_in;
+
+    /* Properties of the output of the encoder */
+    es_format_t         fmt_out;
+
+    block_t *           ( * pf_encode_video )( encoder_t *, picture_t * );
+    block_t *           ( * pf_encode_audio )( encoder_t *, aout_buffer_t * );
+    block_t *           ( * pf_encode_sub )( encoder_t *, subpicture_t * );
+
+    /* Common encoder options */
+    int i_threads;               /* Number of threads to use during encoding */
+    int i_iframes;               /* One I frame per i_iframes */
+    int i_bframes;               /* One B frame per i_bframes */
+    int i_tolerance;             /* Bitrate tolerance */
+
+    /* Encoder config */
+    config_chain_t *p_cfg;
+};
+
+/**
+ * @}
+ */
+
+
+/**
+ * This function will return a new picture usable by a decoder as an output
+ * buffer. You have to release it using decoder_DeletePicture or by returning
+ * it to the caller as a pf_decode_video return value.
+ */
+VLC_API picture_t * decoder_NewPicture( decoder_t * ) VLC_USED;
+
+/**
+ * This function will release a picture create by decoder_NewPicture.
+ */
+VLC_API void decoder_DeletePicture( decoder_t *, picture_t *p_picture );
+
+/**
+ * This function will increase the picture reference count.
+ * (picture_Hold is not usable.)
+ */
+VLC_API void decoder_LinkPicture( decoder_t *, picture_t * );
+
+/**
+ * This function will decrease the picture reference count.
+ * (picture_Release is not usable.)
+ */
+VLC_API void decoder_UnlinkPicture( decoder_t *, picture_t * );
+
+/**
+ * This function will return a new audio buffer usable by a decoder as an
+ * output buffer. You have to release it using decoder_DeleteAudioBuffer
+ * or by returning it to the caller as a pf_decode_audio return value.
+ */
+VLC_API aout_buffer_t * decoder_NewAudioBuffer( decoder_t *, int i_size ) VLC_USED;
+
+/**
+ * This function will return a new subpicture usable by a decoder as an output
+ * buffer. You have to release it using decoder_DeleteSubpicture or by returning
+ * it to the caller as a pf_decode_sub return value.
+ */
+VLC_API subpicture_t * decoder_NewSubpicture( decoder_t *, const subpicture_updater_t * ) VLC_USED;
+
+/**
+ * This function will release a subpicture created by decoder_NewSubicture.
+ */
+VLC_API void decoder_DeleteSubpicture( decoder_t *, subpicture_t *p_subpicture );
+
+/**
+ * This function gives all input attachments at once.
+ *
+ * You MUST release the returned values
+ */
+VLC_API int decoder_GetInputAttachments( decoder_t *, input_attachment_t ***ppp_attachment, int *pi_attachment );
+
+/**
+ * This function converts a decoder timestamp into a display date comparable
+ * to mdate().
+ * You MUST use it *only* for gathering statistics about speed.
+ */
+VLC_API mtime_t decoder_GetDisplayDate( decoder_t *, mtime_t ) VLC_USED;
+
+/**
+ * This function returns the current input rate.
+ * You MUST use it *only* for gathering statistics about speed.
+ */
+VLC_API int decoder_GetDisplayRate( decoder_t * ) VLC_USED;
+
+#endif /* _VLC_CODEC_H */

=== added file 'DivCity/DivCity/vlc/plugins/vlc_common.h'
--- DivCity/DivCity/vlc/plugins/vlc_common.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_common.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,1029 @@
+/*****************************************************************************
+ * common.h: common definitions
+ * Collection of useful common types and macros definitions
+ *****************************************************************************
+ * Copyright (C) 1998-2011 VLC authors and VideoLAN
+ *
+ * Authors: Samuel Hocevar <sam@via.ecp.fr>
+ *          Vincent Seguin <seguin@via.ecp.fr>
+ *          Gildas Bazin <gbazin@videolan.org>
+ *          RÃ©mi Denis-Courmont
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+/**
+ * \file
+ * This file is a collection of common definitions and types
+ */
+
+#ifndef VLC_COMMON_H
+# define VLC_COMMON_H 1
+
+/*****************************************************************************
+ * Required vlc headers
+ *****************************************************************************/
+#if defined( _MSC_VER )
+#   pragma warning( disable : 4244 )
+#endif
+
+#include "vlc_config.h"
+
+/*****************************************************************************
+ * Required system headers
+ *****************************************************************************/
+#include <stdlib.h>
+#include <stdarg.h>
+
+#include <string.h>
+#include <stdio.h>
+#include <inttypes.h>
+#include <stddef.h>
+
+#ifndef __cplusplus
+# include <stdbool.h>
+#endif
+
+/* Helper for GCC version checks */
+#ifdef __GNUC__
+# define VLC_GCC_VERSION(maj,min) \
+    ((__GNUC__ > (maj)) || (__GNUC__ == (maj) && __GNUC_MINOR__ >= (min)))
+#else
+# define VLC_GCC_VERSION(maj,min) (0)
+#endif
+
+/* Try to fix format strings for all versions of mingw and mingw64 */
+#if defined( _WIN32 ) && defined( __USE_MINGW_ANSI_STDIO )
+ #undef PRId64
+ #define PRId64 "lld"
+ #undef PRIi64
+ #define PRIi64 "lli"
+ #undef PRIu64
+ #define PRIu64 "llu"
+ #undef PRIo64
+ #define PRIo64 "llo"
+ #undef PRIx64
+ #define PRIx64 "llx"
+ #define snprintf __mingw_snprintf
+ #define vsnprintf __mingw_vsnprintf
+#endif
+
+/* Function attributes for compiler warnings */
+#ifdef __GNUC__
+# define VLC_DEPRECATED __attribute__((deprecated))
+
+# if defined( _WIN32 ) && VLC_GCC_VERSION(4,4)
+#  define VLC_FORMAT(x,y) __attribute__ ((format(gnu_printf,x,y)))
+# else
+#  define VLC_FORMAT(x,y) __attribute__ ((format(printf,x,y)))
+# endif
+# define VLC_FORMAT_ARG(x) __attribute__ ((format_arg(x)))
+
+# define VLC_MALLOC __attribute__ ((malloc))
+# define VLC_NORETURN __attribute__ ((noreturn))
+
+# if VLC_GCC_VERSION(3,4)
+#  define VLC_USED __attribute__ ((warn_unused_result))
+# else
+#  define VLC_USED
+# endif
+
+#else
+# define VLC_DEPRECATED
+# define VLC_FORMAT(x,y)
+# define VLC_FORMAT_ARG(x)
+# define VLC_MALLOC
+# define VLC_NORETURN
+# define VLC_USED
+#endif
+
+
+/* Branch prediction */
+#ifdef __GNUC__
+#   define likely(p)   __builtin_expect(!!(p), 1)
+#   define unlikely(p) __builtin_expect(!!(p), 0)
+#else
+#   define likely(p)   (!!(p))
+#   define unlikely(p) (!!(p))
+#endif
+
+/* Linkage */
+#ifdef __cplusplus
+# define VLC_EXTERN extern "C"
+#else
+# define VLC_EXTERN
+#endif
+
+#if defined (WIN32) && defined (DLL_EXPORT)
+# define VLC_EXPORT __declspec(dllexport)
+#elif VLC_GCC_VERSION(4,0)
+# define VLC_EXPORT __attribute__((visibility("default")))
+#else
+# define VLC_EXPORT
+#endif
+
+#define VLC_API VLC_EXTERN VLC_EXPORT
+
+
+/*****************************************************************************
+ * Basic types definitions
+ *****************************************************************************/
+#if defined( WIN32 ) || defined( UNDER_CE )
+#   include <malloc.h>
+#   ifndef PATH_MAX
+#       define PATH_MAX MAX_PATH
+#   endif
+#endif
+
+#ifdef __SYMBIAN32__
+ #include <sys/syslimits.h>
+#endif
+
+/* Counter for statistics and profiling */
+typedef unsigned long       count_t;
+
+/* Audio volume */
+typedef uint16_t            audio_volume_t;
+
+/**
+ * High precision date or time interval
+ *
+ * Store a high precision date or time interval. The maximum precision is the
+ * microsecond, and a 64 bits integer is used to avoid overflows (maximum
+ * time interval is then 292271 years, which should be long enough for any
+ * video). Dates are stored as microseconds since a common date (usually the
+ * epoch). Note that date and time intervals can be manipulated using regular
+ * arithmetic operators, and that no special functions are required.
+ */
+typedef int64_t mtime_t;
+
+/**
+ * The vlc_fourcc_t type.
+ *
+ * See http://www.webartz.com/fourcc/ for a very detailed list.
+ */
+typedef uint32_t vlc_fourcc_t;
+
+#ifdef WORDS_BIGENDIAN
+#   define VLC_FOURCC( a, b, c, d ) \
+        ( ((uint32_t)d) | ( ((uint32_t)c) << 8 ) \
+           | ( ((uint32_t)b) << 16 ) | ( ((uint32_t)a) << 24 ) )
+#   define VLC_TWOCC( a, b ) \
+        ( (uint16_t)(b) | ( (uint16_t)(a) << 8 ) )
+
+#else
+#   define VLC_FOURCC( a, b, c, d ) \
+        ( ((uint32_t)a) | ( ((uint32_t)b) << 8 ) \
+           | ( ((uint32_t)c) << 16 ) | ( ((uint32_t)d) << 24 ) )
+#   define VLC_TWOCC( a, b ) \
+        ( (uint16_t)(a) | ( (uint16_t)(b) << 8 ) )
+
+#endif
+
+/**
+ * Translate a vlc_fourcc into its string representation. This function
+ * assumes there is enough room in psz_fourcc to store 4 characters in.
+ *
+ * \param fcc a vlc_fourcc_t
+ * \param psz_fourcc string to store string representation of vlc_fourcc in
+ */
+static inline void vlc_fourcc_to_char( vlc_fourcc_t fcc, char *psz_fourcc )
+{
+    memcpy( psz_fourcc, &fcc, 4 );
+}
+
+#define vlc_fourcc_to_char( a, b ) \
+        vlc_fourcc_to_char( (vlc_fourcc_t)(a), (char *)(b) )
+
+/*****************************************************************************
+ * Classes declaration
+ *****************************************************************************/
+
+/* Internal types */
+typedef struct vlc_list_t vlc_list_t;
+typedef struct vlc_object_t vlc_object_t;
+typedef struct libvlc_int_t libvlc_int_t;
+typedef struct date_t date_t;
+
+/* Playlist */
+
+/* FIXME */
+/**
+ * Playlist commands
+ */
+typedef enum {
+    PLAYLIST_PLAY,      /**< No arg.                            res=can fail*/
+    PLAYLIST_VIEWPLAY,  /**< arg1= playlist_item_t*,*/
+                        /**  arg2 = playlist_item_t*          , res=can fail */
+    PLAYLIST_PAUSE,     /**< No arg                             res=can fail*/
+    PLAYLIST_STOP,      /**< No arg                             res=can fail*/
+    PLAYLIST_SKIP,      /**< arg1=int,                          res=can fail*/
+} playlist_command_t;
+
+
+typedef struct playlist_t playlist_t;
+typedef struct playlist_item_t playlist_item_t;
+typedef struct playlist_view_t playlist_view_t;
+typedef struct services_discovery_t services_discovery_t;
+typedef struct services_discovery_sys_t services_discovery_sys_t;
+typedef struct playlist_add_t playlist_add_t;
+
+/* Modules */
+typedef struct module_t module_t;
+typedef struct module_config_t module_config_t;
+
+typedef struct config_category_t config_category_t;
+
+/* Input */
+typedef struct input_thread_t input_thread_t;
+typedef struct input_item_t input_item_t;
+typedef struct input_item_node_t input_item_node_t;
+typedef struct access_t access_t;
+typedef struct access_sys_t access_sys_t;
+typedef struct stream_t     stream_t;
+typedef struct stream_sys_t stream_sys_t;
+typedef struct demux_t  demux_t;
+typedef struct demux_sys_t demux_sys_t;
+typedef struct es_out_t     es_out_t;
+typedef struct es_out_id_t  es_out_id_t;
+typedef struct es_out_sys_t es_out_sys_t;
+typedef struct seekpoint_t seekpoint_t;
+typedef struct info_t info_t;
+typedef struct info_category_t info_category_t;
+typedef struct input_attachment_t input_attachment_t;
+
+/* Format */
+typedef struct audio_format_t audio_format_t;
+typedef struct video_format_t video_format_t;
+typedef struct subs_format_t subs_format_t;
+typedef struct es_format_t es_format_t;
+typedef struct video_palette_t video_palette_t;
+
+/* Audio */
+typedef struct audio_output audio_output_t;
+typedef struct aout_sys_t aout_sys_t;
+typedef struct aout_fifo_t aout_fifo_t;
+typedef struct aout_input_t aout_input_t;
+typedef struct block_t aout_buffer_t;
+typedef audio_format_t audio_sample_format_t;
+
+/* Video */
+typedef struct vout_thread_t vout_thread_t;
+
+typedef video_format_t video_frame_format_t;
+typedef struct picture_t picture_t;
+typedef struct picture_sys_t picture_sys_t;
+
+/* Subpictures */
+typedef struct spu_t spu_t;
+typedef struct subpicture_t subpicture_t;
+typedef struct subpicture_sys_t subpicture_sys_t;
+typedef struct subpicture_region_t subpicture_region_t;
+
+typedef struct image_handler_t image_handler_t;
+
+/* Stream output */
+typedef struct sout_instance_t sout_instance_t;
+typedef struct sout_instance_sys_t sout_instance_sys_t;
+
+typedef struct sout_input_t sout_input_t;
+typedef struct sout_packetizer_input_t sout_packetizer_input_t;
+
+typedef struct sout_access_out_t sout_access_out_t;
+typedef struct sout_access_out_sys_t   sout_access_out_sys_t;
+
+typedef struct sout_mux_t sout_mux_t;
+typedef struct sout_mux_sys_t sout_mux_sys_t;
+
+typedef struct sout_stream_t    sout_stream_t;
+typedef struct sout_stream_sys_t sout_stream_sys_t;
+
+typedef struct config_chain_t       config_chain_t;
+typedef struct session_descriptor_t session_descriptor_t;
+
+/* Decoders */
+typedef struct decoder_t         decoder_t;
+typedef struct decoder_sys_t     decoder_sys_t;
+typedef struct decoder_synchro_t decoder_synchro_t;
+
+/* Encoders */
+typedef struct encoder_t      encoder_t;
+typedef struct encoder_sys_t  encoder_sys_t;
+
+/* Filters */
+typedef struct filter_t filter_t;
+typedef struct filter_sys_t filter_sys_t;
+
+/* Network */
+typedef struct virtual_socket_t v_socket_t;
+typedef struct vlc_acl_t vlc_acl_t;
+typedef struct vlc_url_t vlc_url_t;
+
+/* Misc */
+typedef struct iso639_lang_t iso639_lang_t;
+
+/* block */
+typedef struct block_t      block_t;
+typedef struct block_fifo_t block_fifo_t;
+
+/* httpd */
+typedef struct httpd_t          httpd_t;
+typedef struct httpd_host_t     httpd_host_t;
+typedef struct httpd_url_t      httpd_url_t;
+typedef struct httpd_client_t   httpd_client_t;
+typedef struct httpd_callback_sys_t httpd_callback_sys_t;
+typedef struct httpd_message_t  httpd_message_t;
+typedef int    (*httpd_callback_t)( httpd_callback_sys_t *, httpd_client_t *, httpd_message_t *answer, const httpd_message_t *query );
+typedef struct httpd_file_t     httpd_file_t;
+typedef struct httpd_file_sys_t httpd_file_sys_t;
+typedef int (*httpd_file_callback_t)( httpd_file_sys_t *, httpd_file_t *, uint8_t *psz_request, uint8_t **pp_data, int *pi_data );
+typedef struct httpd_handler_t  httpd_handler_t;
+typedef struct httpd_handler_sys_t httpd_handler_sys_t;
+typedef int (*httpd_handler_callback_t)( httpd_handler_sys_t *, httpd_handler_t *, char *psz_url, uint8_t *psz_request, int i_type, uint8_t *p_in, int i_in, char *psz_remote_addr, char *psz_remote_host, uint8_t **pp_data, int *pi_data );
+typedef struct httpd_redirect_t httpd_redirect_t;
+typedef struct httpd_stream_t httpd_stream_t;
+
+/* Hashing */
+typedef struct md5_s md5_t;
+
+/* XML */
+typedef struct xml_t xml_t;
+typedef struct xml_sys_t xml_sys_t;
+typedef struct xml_reader_t xml_reader_t;
+typedef struct xml_reader_sys_t xml_reader_sys_t;
+
+/* vod server */
+typedef struct vod_t     vod_t;
+typedef struct vod_sys_t vod_sys_t;
+typedef struct vod_media_t vod_media_t;
+
+/* osdmenu */
+typedef struct osd_menu_t   osd_menu_t;
+typedef struct osd_state_t  osd_state_t;
+typedef struct osd_event_t  osd_event_t;
+typedef struct osd_button_t osd_button_t;
+typedef struct osd_menu_state_t osd_menu_state_t;
+
+/* VLM */
+typedef struct vlm_t         vlm_t;
+typedef struct vlm_message_t vlm_message_t;
+
+/* misc */
+typedef struct vlc_meta_t    vlc_meta_t;
+
+/* Stats */
+typedef struct counter_t     counter_t;
+typedef struct counter_sample_t counter_sample_t;
+typedef struct stats_handler_t stats_handler_t;
+typedef struct input_stats_t input_stats_t;
+
+/* Update */
+typedef struct update_t update_t;
+typedef struct update_iterator_t update_iterator_t;
+
+/* Meta engine */
+typedef struct meta_engine_t meta_engine_t;
+
+/* stat/lstat/fstat */
+#ifdef WIN32
+# include <sys/stat.h>
+
+# ifndef UNDER_CE
+struct _stati64;
+#  define stat _stati64
+#  define fstat _fstati64
+#endif
+
+/* You should otherwise use vlc_stat and vlc_lstat. */
+#else
+struct stat;
+#endif
+
+/**
+ * VLC value structure
+ */
+typedef union
+{
+    int64_t         i_int;
+    bool            b_bool;
+    float           f_float;
+    char *          psz_string;
+    void *          p_address;
+    vlc_object_t *  p_object;
+    vlc_list_t *    p_list;
+    mtime_t         i_time;
+    struct { int32_t x; int32_t y; } coords;
+
+} vlc_value_t;
+
+/**
+ * VLC list structure
+ */
+struct vlc_list_t
+{
+    int             i_count;
+    vlc_value_t *   p_values;
+    int *           pi_types;
+
+};
+
+/*****************************************************************************
+ * Error values (shouldn't be exposed)
+ *****************************************************************************/
+#define VLC_SUCCESS         -0                                   /* No error */
+#define VLC_ENOMEM          -1                          /* Not enough memory */
+#define VLC_ETIMEOUT        -3                                    /* Timeout */
+
+#define VLC_ENOMOD         -10                           /* Module not found */
+
+#define VLC_ENOOBJ         -20                           /* Object not found */
+
+#define VLC_ENOVAR         -30                         /* Variable not found */
+#define VLC_EBADVAR        -31                         /* Bad variable value */
+
+#define VLC_ENOITEM        -40                           /**< Item not found */
+
+#define VLC_EEXIT         -255                             /* Program exited */
+#define VLC_EEXITSUCCESS  -999                /* Program exited successfully */
+#define VLC_EGENERIC      -666                              /* Generic error */
+
+/*****************************************************************************
+ * Variable callbacks
+ *****************************************************************************/
+typedef int ( * vlc_callback_t ) ( vlc_object_t *,      /* variable's object */
+                                   char const *,            /* variable name */
+                                   vlc_value_t,                 /* old value */
+                                   vlc_value_t,                 /* new value */
+                                   void * );                /* callback data */
+
+/*****************************************************************************
+ * OS-specific headers and thread types
+ *****************************************************************************/
+#if defined( WIN32 ) || defined( UNDER_CE )
+/* WIN32_LEAN_AND_MEAN is needed to be able to include winsock2.h because else,
+ * windows.h will also include winsock.h and declarations will conflict */
+# define WIN32_LEAN_AND_MEAN
+# include <windows.h>
+#endif
+
+#ifdef __OS2__
+#   define OS2EMX_PLAIN_CHAR
+#   define INCL_BASE
+#   define INCL_PM
+#   include <os2.h>
+#endif
+
+#include "vlc_mtime.h"
+#include "vlc_threads.h"
+
+/**
+ * Memory storage space for an atom. Never access it directly.
+ */
+typedef union
+{
+    volatile uintptr_t u;
+    volatile intptr_t  s;
+} vlc_atomic_t;
+
+/*****************************************************************************
+ * Common structure members
+ *****************************************************************************/
+
+/* VLC_COMMON_MEMBERS : members common to all basic vlc objects */
+#define VLC_COMMON_MEMBERS                                                  \
+/** \name VLC_COMMON_MEMBERS                                                \
+ * these members are common for all vlc objects                             \
+ */                                                                         \
+/**@{*/                                                                     \
+    const char *psz_object_type;                                            \
+                                                                            \
+    /* Messages header */                                                   \
+    char *psz_header;                                                       \
+    int  i_flags;                                                           \
+                                                                            \
+    /* Object properties */                                                 \
+    volatile bool b_die;                   /**< set by the outside */ \
+    bool b_force;      /**< set by the outside (eg. module_need()) */ \
+                                                                            \
+    /* Stuff related to the libvlc structure */                             \
+    libvlc_int_t *p_libvlc;                  /**< (root of all evil) - 1 */ \
+                                                                            \
+    vlc_object_t *  p_parent;                            /**< our parent */ \
+                                                                            \
+/**@}*/                                                                     \
+
+/* VLC_OBJECT: attempt at doing a clever cast */
+#if VLC_GCC_VERSION(4,0)
+# ifndef __cplusplus
+#  define VLC_OBJECT( x ) \
+    __builtin_choose_expr( \
+        __builtin_offsetof(__typeof__(*(x)), psz_object_type), \
+        (void)0 /* screw you */, \
+        (vlc_object_t *)(x))
+# else
+#  define VLC_OBJECT( x ) \
+    ((vlc_object_t *)(x) \
+      + 0 * __builtin_offsetof(__typeof__(*(x)), psz_object_type))
+# endif
+#else
+# define VLC_OBJECT( x ) ((vlc_object_t *)(x))
+#endif
+
+typedef struct gc_object_t
+{
+    vlc_atomic_t    refs;
+    void          (*pf_destructor) (struct gc_object_t *);
+} gc_object_t;
+
+/**
+ * These members are common to all objects that wish to be garbage-collected.
+ */
+#define VLC_GC_MEMBERS gc_object_t vlc_gc_data;
+
+VLC_API void * vlc_gc_init(gc_object_t *, void (*)(gc_object_t *));
+VLC_API void * vlc_hold(gc_object_t *);
+VLC_API void vlc_release(gc_object_t *);
+
+#define vlc_gc_init( a,b ) vlc_gc_init( &(a)->vlc_gc_data, (b) )
+#define vlc_gc_incref( a ) vlc_hold( &(a)->vlc_gc_data )
+#define vlc_gc_decref( a ) vlc_release( &(a)->vlc_gc_data )
+#define vlc_priv( gc, t ) ((t *)(((char *)(gc)) - offsetof(t, vlc_gc_data)))
+
+/*****************************************************************************
+ * Macros and inline functions
+ *****************************************************************************/
+
+/* CEIL: division with round to nearest greater integer */
+#define CEIL(n, d)  ( ((n) / (d)) + ( ((n) % (d)) ? 1 : 0) )
+
+/* PAD: PAD(n, d) = CEIL(n ,d) * d */
+#define PAD(n, d)   ( ((n) % (d)) ? ((((n) / (d)) + 1) * (d)) : (n) )
+
+/* __MAX and __MIN: self explanatory */
+#ifndef __MAX
+#   define __MAX(a, b)   ( ((a) > (b)) ? (a) : (b) )
+#endif
+#ifndef __MIN
+#   define __MIN(a, b)   ( ((a) < (b)) ? (a) : (b) )
+#endif
+
+/* clip v in [min, max] */
+#define VLC_CLIP(v, min, max)    __MIN(__MAX((v), (min)), (max))
+
+VLC_USED
+static inline int64_t GCD ( int64_t a, int64_t b )
+{
+    while( b )
+    {
+        int64_t c = a % b;
+        a = b;
+        b = c;
+    }
+    return a;
+}
+
+/* function imported from libavutil/common.h */
+VLC_USED
+static inline uint8_t clip_uint8_vlc( int32_t a )
+{
+    if( a&(~255) ) return (-a)>>31;
+    else           return a;
+}
+
+/** Count leading zeroes */
+VLC_USED
+static inline unsigned clz (unsigned x)
+{
+#if VLC_GCC_VERSION(3,4)
+    return __builtin_clz (x);
+#else
+    unsigned i = sizeof (x) * 8;
+
+    while (x)
+    {
+        x = x >> 1;
+        i--;
+    }
+    return i;
+#endif
+}
+
+#define clz8( x ) (clz(x) - ((sizeof(unsigned) - sizeof (uint8_t)) * 8))
+#define clz16( x ) (clz(x) - ((sizeof(unsigned) - sizeof (uint16_t)) * 8))
+/* XXX: this assumes that int is 32-bits or more */
+#define clz32( x ) (clz(x) - ((sizeof(unsigned) - sizeof (uint32_t)) * 8))
+
+/** Bit weight */
+VLC_USED
+static inline unsigned popcount (unsigned x)
+{
+#if VLC_GCC_VERSION(3,4)
+    return __builtin_popcount (x);
+#else
+    unsigned count = 0;
+    while (x)
+    {
+        count += x & 1;
+        x = x >> 1;
+    }
+    return count;
+#endif
+}
+
+#ifdef __OS2__
+#   undef bswap16
+#   undef bswap32
+#   undef bswap64
+#endif
+
+/** Byte swap (16 bits) */
+VLC_USED
+static inline uint16_t bswap16 (uint16_t x)
+{
+    return (x << 8) | (x >> 8);
+}
+
+/** Byte swap (32 bits) */
+VLC_USED
+static inline uint32_t bswap32 (uint32_t x)
+{
+#if VLC_GCC_VERSION(4,3)
+    return __builtin_bswap32 (x);
+#else
+    return ((x & 0x000000FF) << 24)
+         | ((x & 0x0000FF00) <<  8)
+         | ((x & 0x00FF0000) >>  8)
+         | ((x & 0xFF000000) >> 24);
+#endif
+}
+
+/** Byte swap (64 bits) */
+VLC_USED
+static inline uint64_t bswap64 (uint64_t x)
+{
+#if VLC_GCC_VERSION(4,3)
+    return __builtin_bswap64 (x);
+#elif !defined (__cplusplus)
+    return ((x & 0x00000000000000FF) << 56)
+         | ((x & 0x000000000000FF00) << 40)
+         | ((x & 0x0000000000FF0000) << 24)
+         | ((x & 0x00000000FF000000) <<  8)
+         | ((x & 0x000000FF00000000) >>  8)
+         | ((x & 0x0000FF0000000000) >> 24)
+         | ((x & 0x00FF000000000000) >> 40)
+         | ((x & 0xFF00000000000000) >> 56);
+#else
+    return ((x & 0x00000000000000FFLLU) << 56)
+         | ((x & 0x000000000000FF00LLU) << 40)
+         | ((x & 0x0000000000FF0000LLU) << 24)
+         | ((x & 0x00000000FF000000LLU) <<  8)
+         | ((x & 0x000000FF00000000LLU) >>  8)
+         | ((x & 0x0000FF0000000000LLU) >> 24)
+         | ((x & 0x00FF000000000000LLU) >> 40)
+         | ((x & 0xFF00000000000000LLU) >> 56);
+#endif
+}
+
+
+/* Free and set set the variable to NULL */
+#define FREENULL(a) do { free( a ); a = NULL; } while(0)
+
+#define EMPTY_STR(str) (!str || !*str)
+
+VLC_API char const * vlc_error( int ) VLC_USED;
+
+#include <vlc_arrays.h>
+
+/* MSB (big endian)/LSB (little endian) conversions - network order is always
+ * MSB, and should be used for both network communications and files. */
+
+#ifdef WORDS_BIGENDIAN
+# define hton16(i) ((uint16_t)(i))
+# define hton32(i) ((uint32_t)(i))
+# define hton64(i) ((uint64_t)(i))
+#else
+# define hton16(i) bswap16(i)
+# define hton32(i) bswap32(i)
+# define hton64(i) bswap64(i)
+#endif
+#define ntoh16(i) hton16(i)
+#define ntoh32(i) hton32(i)
+#define ntoh64(i) hton64(i)
+
+/** Reads 16 bits in network byte order */
+VLC_USED
+static inline uint16_t U16_AT (const void *p)
+{
+    uint16_t x;
+
+    memcpy (&x, p, sizeof (x));
+    return ntoh16 (x);
+}
+
+/** Reads 32 bits in network byte order */
+VLC_USED
+static inline uint32_t U32_AT (const void *p)
+{
+    uint32_t x;
+
+    memcpy (&x, p, sizeof (x));
+    return ntoh32 (x);
+}
+
+/** Reads 64 bits in network byte order */
+VLC_USED
+static inline uint64_t U64_AT (const void *p)
+{
+    uint64_t x;
+
+    memcpy (&x, p, sizeof (x));
+    return ntoh64 (x);
+}
+
+#define GetWBE(p)  U16_AT(p)
+#define GetDWBE(p) U32_AT(p)
+#define GetQWBE(p) U64_AT(p)
+
+/** Reads 16 bits in little-endian order */
+VLC_USED
+static inline uint16_t GetWLE (const void *p)
+{
+    uint16_t x;
+
+    memcpy (&x, p, sizeof (x));
+#ifdef WORDS_BIGENDIAN
+    x = bswap16 (x);
+#endif
+    return x;
+}
+
+/** Reads 32 bits in little-endian order */
+VLC_USED
+static inline uint32_t GetDWLE (const void *p)
+{
+    uint32_t x;
+
+    memcpy (&x, p, sizeof (x));
+#ifdef WORDS_BIGENDIAN
+    x = bswap32 (x);
+#endif
+    return x;
+}
+
+/** Reads 64 bits in little-endian order */
+VLC_USED
+static inline uint64_t GetQWLE (const void *p)
+{
+    uint64_t x;
+
+    memcpy (&x, p, sizeof (x));
+#ifdef WORDS_BIGENDIAN
+    x = bswap64 (x);
+#endif
+    return x;
+}
+
+/** Writes 16 bits in network byte order */
+static inline void SetWBE (void *p, uint16_t w)
+{
+    w = hton16 (w);
+    memcpy (p, &w, sizeof (w));
+}
+
+/** Writes 32 bits in network byte order */
+static inline void SetDWBE (void *p, uint32_t dw)
+{
+    dw = hton32 (dw);
+    memcpy (p, &dw, sizeof (dw));
+}
+
+/** Writes 64 bits in network byte order */
+static inline void SetQWBE (void *p, uint64_t qw)
+{
+    qw = hton64 (qw);
+    memcpy (p, &qw, sizeof (qw));
+}
+
+/** Writes 16 bits in little endian order */
+static inline void SetWLE (void *p, uint16_t w)
+{
+#ifdef WORDS_BIGENDIAN
+    w = bswap16 (w);
+#endif
+    memcpy (p, &w, sizeof (w));
+}
+
+/** Writes 32 bits in little endian order */
+static inline void SetDWLE (void *p, uint32_t dw)
+{
+#ifdef WORDS_BIGENDIAN
+    dw = bswap32 (dw);
+#endif
+    memcpy (p, &dw, sizeof (dw));
+}
+
+/** Writes 64 bits in little endian order */
+static inline void SetQWLE (void *p, uint64_t qw)
+{
+#ifdef WORDS_BIGENDIAN
+    qw = bswap64 (qw);
+#endif
+    memcpy (p, &qw, sizeof (qw));
+}
+
+/* */
+#define VLC_UNUSED(x) (void)(x)
+
+/* Stuff defined in src/extras/libc.c */
+
+#if defined(WIN32) || defined(UNDER_CE)
+/* win32, cl and icl support */
+#   if defined( _MSC_VER ) || !defined( __MINGW32__ )
+#       define __attribute__(x)
+#       define S_IFBLK         0x3000  /* Block */
+#       define S_ISBLK(m)      (0)
+#       define S_ISCHR(m)      (0)
+#       define S_ISFIFO(m)     (((m)&_S_IFMT) == _S_IFIFO)
+#       define S_ISREG(m)      (((m)&_S_IFMT) == _S_IFREG)
+#   endif
+
+/* several type definitions */
+#   if defined( __MINGW32__ )
+#       if !defined( _OFF_T_ )
+            typedef long long _off_t;
+            typedef _off_t off_t;
+#           define _OFF_T_
+#       else
+#           ifdef off_t
+#               undef off_t
+#           endif
+#           define off_t long long
+#       endif
+#   endif
+
+#   if defined( _MSC_VER )
+#       if !defined( _OFF_T_DEFINED )
+            typedef __int64 off_t;
+#           define _OFF_T_DEFINED
+#       else
+            /* for wx compatibility typedef long off_t; */
+#           define off_t __int64
+#       endif
+#   endif
+
+#   if defined( __BORLANDC__ )
+#       undef off_t
+#       define off_t unsigned __int64
+#   endif
+
+#   ifndef O_NONBLOCK
+#       define O_NONBLOCK 0
+#   endif
+
+#   ifndef alloca
+#       define alloca _alloca
+#   endif
+
+#   include <tchar.h>
+#endif
+
+VLC_API bool vlc_ureduce( unsigned *, unsigned *, uint64_t, uint64_t, uint64_t );
+
+/* Aligned memory allocator */
+#ifdef __APPLE__
+#include <AvailabilityMacros.h>
+#endif
+
+#ifdef WIN32
+# include <malloc.h>
+# define vlc_memalign(align, size) (__mingw_aligned_malloc(size, align))
+# define vlc_free(base)            (__mingw_aligned_free(base))
+#elif defined(__APPLE__) && !defined(MAC_OS_X_VERSION_10_6)
+static inline void *vlc_memalign(size_t align, size_t size)
+{
+    long diff;
+    void *ptr;
+
+    ptr = malloc(size+align);
+    if(!ptr)
+        return ptr;
+    diff = ((-(long)ptr - 1)&(align-1)) + 1;
+    ptr  = (char*)ptr + diff;
+    ((char*)ptr)[-1]= diff;
+    return ptr;
+}
+
+static void vlc_free(void *ptr)
+{
+    if (ptr)
+        free((char*)ptr - ((char*)ptr)[-1]);
+}
+#elif defined(__ANDROID__)
+# define vlc_memalign(align, size) memalign(align, size)
+# define vlc_free(base) free(base)
+#else
+static inline void *vlc_memalign(size_t align, size_t size)
+{
+    void *base;
+    if (unlikely(posix_memalign(&base, align, size)))
+        base = NULL;
+    return base;
+}
+# define vlc_free(base) free(base)
+#endif
+
+VLC_API void vlc_tdestroy( void *, void (*)(void *) );
+
+/* Fast large memory copy and memory set */
+VLC_API void * vlc_memcpy( void *, const void *, size_t );
+#define vlc_memset memset
+
+/*****************************************************************************
+ * I18n stuff
+ *****************************************************************************/
+VLC_API char * vlc_gettext( const char *msgid ) VLC_FORMAT_ARG(1);
+
+#define vlc_pgettext( ctx, id ) \
+        vlc_pgettext_aux( ctx "\004" id, id )
+
+VLC_FORMAT_ARG(2)
+static inline const char *vlc_pgettext_aux( const char *ctx, const char *id )
+{
+    const char *tr = vlc_gettext( ctx );
+    return (tr == ctx) ? id : tr;
+}
+
+/*****************************************************************************
+ * Loosy memory allocation functions. Do not use in new code.
+ *****************************************************************************/
+static inline void *xmalloc (size_t len)
+{
+    void *ptr = malloc (len);
+    if (unlikely (ptr == NULL))
+        abort ();
+    return ptr;
+}
+
+static inline void *xrealloc (void *ptr, size_t len)
+{
+    void *nptr = realloc (ptr, len);
+    if (unlikely (nptr == NULL))
+        abort ();
+    return nptr;
+}
+
+static inline void *xcalloc (size_t n, size_t size)
+{
+    void *ptr = calloc (n, size);
+    if (unlikely (ptr == NULL))
+        abort ();
+    return ptr;
+}
+
+/*****************************************************************************
+ * libvlc features
+ *****************************************************************************/
+VLC_API const char * VLC_CompileBy( void ) VLC_USED;
+VLC_API const char * VLC_CompileHost( void ) VLC_USED;
+VLC_API const char * VLC_Compiler( void ) VLC_USED;
+
+/*****************************************************************************
+ * Additional vlc stuff
+ *****************************************************************************/
+#include "vlc_messages.h"
+#include "vlc_objects.h"
+#include "vlc_variables.h"
+#include "vlc_main.h"
+#include "vlc_configuration.h"
+
+#if defined( WIN32 ) || defined( UNDER_CE ) || defined( __SYMBIAN32__ ) || defined( __OS2__ )
+#   define DIR_SEP_CHAR '\\'
+#   define DIR_SEP "\\"
+#   define PATH_SEP_CHAR ';'
+#   define PATH_SEP ";"
+#else
+#   define DIR_SEP_CHAR '/'
+#   define DIR_SEP "/"
+#   define PATH_SEP_CHAR ':'
+#   define PATH_SEP ":"
+#endif
+
+#define LICENSE_MSG \
+  _("This program comes with NO WARRANTY, to the extent permitted by " \
+    "law.\nYou may redistribute it under the terms of the GNU General " \
+    "Public License;\nsee the file named COPYING for details.\n" \
+    "Written by the VideoLAN team; see the AUTHORS file.\n")
+
+#endif /* !VLC_COMMON_H */

=== added file 'DivCity/DivCity/vlc/plugins/vlc_config.h'
--- DivCity/DivCity/vlc/plugins/vlc_config.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_config.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,133 @@
+/*****************************************************************************
+ * vlc_config.h: limits and configuration
+ * Defines all compilation-time configuration constants and size limits
+ *****************************************************************************
+ * Copyright (C) 1999-2003 VLC authors and VideoLAN
+ *
+ * Authors: Vincent Seguin <seguin@via.ecp.fr>
+ *          Samuel Hocevar <sam@via.ecp.fr>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+/**
+ * \file
+ * This file defines of values used in interface, vout, aout and vlc core functions.
+ */
+
+/* Conventions regarding names of symbols and variables
+ * ----------------------------------------------------
+ *
+ * - Symbols should begin with a prefix indicating in which module they are
+ *   used, such as INTF_, VOUT_ or AOUT_.
+ */
+
+/*****************************************************************************
+ * General configuration
+ *****************************************************************************/
+
+/* All timestamp below or equal to this define are invalid/unset
+ * XXX the numerical value is 0 because of historical reason and will change.*/
+#define VLC_TS_INVALID (0)
+#define VLC_TS_0 (1)
+
+#define CLOCK_FREQ INT64_C(1000000)
+
+/*****************************************************************************
+ * Interface configuration
+ *****************************************************************************/
+
+/* Base delay in micro second for interface sleeps */
+#define INTF_IDLE_SLEEP                 (CLOCK_FREQ/20)
+
+/* Step for changing gamma, and minimum and maximum values */
+#define INTF_GAMMA_STEP                 .1
+#define INTF_GAMMA_LIMIT                3
+
+/*****************************************************************************
+ * Input thread configuration
+ *****************************************************************************/
+
+#define DEFAULT_INPUT_ACTIVITY 1
+#define TRANSCODE_ACTIVITY 10
+
+/* Used in ErrorThread */
+#define INPUT_IDLE_SLEEP                (CLOCK_FREQ/10)
+
+/* Number of read() calls needed until we check the file size through
+ * fstat() */
+#define INPUT_FSTAT_NB_READS            16
+
+/*
+ * General limitations
+ */
+
+/* Duration between the time we receive the data packet, and the time we will
+ * mark it to be presented */
+#define DEFAULT_PTS_DELAY               (3*CLOCK_FREQ/10)
+
+/*****************************************************************************
+ * SPU configuration
+ *****************************************************************************/
+
+/* Buffer must avoid arriving more than SPU_MAX_PREPARE_TIME in advanced to
+ * the SPU */
+#define SPU_MAX_PREPARE_TIME            (CLOCK_FREQ/2)
+
+/*****************************************************************************
+ * Video configuration
+ *****************************************************************************/
+
+/*
+ * Default settings for video output threads
+ */
+
+/* Multiplier value for aspect ratio calculation (2^7 * 3^3 * 5^3) */
+#define VOUT_ASPECT_FACTOR              432000
+
+/* Maximum width of a scaled source picture - this should be relatively high,
+ * since higher stream values will result in no display at all. */
+#define VOUT_MAX_WIDTH                  4096
+
+/* Number of planes in a picture */
+#define VOUT_MAX_PLANES                 5
+
+/*
+ * Time settings
+ */
+
+/* Time to sleep when waiting for a buffer (from vout or the video fifo).
+ * It should be approximately the time needed to perform a complete picture
+ * loop. Since it only happens when the video heap is full, it does not need
+ * to be too low, even if it blocks the decoder. */
+#define VOUT_OUTMEM_SLEEP               (CLOCK_FREQ/50)
+
+/* The default video output window title */
+#define VOUT_TITLE                      "VLC"
+
+/*****************************************************************************
+ * Messages and console interfaces configuration
+ *****************************************************************************/
+
+/* Maximal size of a message to be stored in the mesage queue,
+ * it is needed when vasprintf is not available */
+#define INTF_MAX_MSG_SIZE               512
+
+/* Maximal size of the message queue - in case of overflow, all messages in the
+ * queue are printed, but not sent to the threads */
+#define VLC_MSG_QSIZE                   256
+
+/* Maximal depth of the object tree output by vlc_dumpstructure */
+#define MAX_DUMPSTRUCTURE_DEPTH         100

=== added file 'DivCity/DivCity/vlc/plugins/vlc_config_cat.h'
--- DivCity/DivCity/vlc/plugins/vlc_config_cat.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_config_cat.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,313 @@
+/*****************************************************************************
+ * vlc_config_cat.h : Definition of configuration categories
+ *****************************************************************************
+ * Copyright (C) 2003 VLC authors and VideoLAN
+ * $Id: 9626943a04ec305e675660c8fb4ebdfe79942fa7 $
+ *
+ * Authors: ClÃ©ment Stenac <zorglub@videolan.org>
+ *          Anil Daoud <anil@videolan.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_HELP_H
+#define VLC_HELP_H 1
+
+/*
+ *  First, we need help strings for the General Settings and for the
+ *  Plugins screen
+ */
+#define MAIN_TITLE N_( "VLC preferences" )
+#define MAIN_HELP N_( \
+    "Select \"Advanced Options\" to see all options." )
+
+/* Interface */
+#define INTF_TITLE N_("Interface")
+#define INTF_HELP  N_( "Settings for VLC's interfaces" )
+
+#define INTF_GENERAL_HELP N_( "Main interfaces settings" )
+
+#define INTF_MAIN_TITLE  N_( "Main interfaces" )
+#define INTF_MAIN_HELP N_( "Settings for the main interface" )
+
+#define INTF_CONTROL_TITLE N_( "Control interfaces" )
+#define INTF_CONTROL_HELP N_( "Settings for VLC's control interfaces" )
+
+#define INTF_HOTKEYS_TITLE N_( "Hotkeys settings" )
+#define INTF_HOTKEYS_HELP N_( "Hotkeys settings" )
+
+/* Audio */
+#define AUDIO_TITLE N_( "Audio" )
+#define AUDIO_HELP N_( "Audio settings" )
+
+#define AUDIO_GENERAL_HELP N_("General audio settings")
+
+#define AFILTER_TITLE N_("Filters")
+#define AFILTER_HELP N_( "Audio filters are used to process the audio stream." )
+
+#define AVISUAL_TITLE N_("Visualizations")
+#define AVISUAL_HELP N_( "Audio visualizations" )
+
+#define AOUT_TITLE N_( "Output modules" )
+#define AOUT_HELP N_("General settings for audio output modules.")
+
+#define AMISC_TITLE N_("Miscellaneous")
+#define AMISC_HELP N_( "Miscellaneous audio settings and modules." )
+
+/* Video */
+#define VIDEO_TITLE N_("Video")
+#define VIDEO_HELP N_("Video settings")
+
+#define VIDEO_GENERAL_HELP N_( "General video settings" )
+
+#define _VOUT_TITLE N_("Output modules" )
+#define VOUT_HELP N_( \
+    "Choose your preferred video output and configure it here." )
+
+#define VFILTER_TITLE N_("Filters" )
+#define VFILTER_HELP N_( \
+    "Video filters are used to process the video stream." )
+
+#define SUBPIC_TITLE N_( "Subtitles/OSD")
+#define SUBPIC_HELP N_( "Settings related to On-Screen-Display,"\
+        " subtitles and \"overlay subpictures\"")
+/*
+#define TEXT_TITLE N_("Text rendering")
+#define TEXT_HELP N_( \
+    "Use the settings of the \"freetype\" module to choose the font you " \
+    "want VLC to use for text rendering (to display subtitles for example).")
+*/
+/* Input */
+#define INPUT_TITLE N_( "Input / Codecs" )
+#define INPUT_HELP N_( "Settings for input, demultiplexing, " \
+         "decoding and encoding")
+
+#define ACCESS_TITLE N_( "Access modules" )
+#define ACCESS_HELP N_( \
+    "Settings related to the various access methods. " \
+    "Common settings you may want to alter are HTTP proxy or " \
+    "caching settings." )
+
+#define STREAM_FILTER_TITLE N_( "Stream filters" )
+#define STREAM_FILTER_HELP N_( \
+    "Stream filters are special modules that allow advanced operations on " \
+    "the input side of VLC. Use with care..." )
+
+#define DEMUX_TITLE N_("Demuxers")
+#define DEMUX_HELP N_( "Demuxers are used to separate audio and video streams." )
+
+#define VDEC_TITLE  N_( "Video codecs" )
+#define VDEC_HELP N_( "Settings for the video, images or video+audio decoders and encoders." )
+
+#define ADEC_TITLE  N_( "Audio codecs" )
+#define ADEC_HELP N_( "Settings for the audio-only decoders and encoders." )
+
+#define SDEC_TITLE N_( "Subtitles codecs")
+#define SDEC_HELP N_( "Settings for subtitles, teletext and CC decoders and encoders." )
+
+#define ADVANCED_TITLE N_("General Input" )
+#define ADVANCED_HELP N_( "General input settings. Use with care..." )
+
+/* Sout */
+#define SOUT_TITLE N_( "Stream output" )
+#define SOUT_HELP N_( \
+      "Stream output settings are used when acting as a streaming server " \
+      "or when saving incoming streams.\n" \
+      "Streams are first muxed and then sent through an \"access output\" "\
+      "module that can either save the stream to a file, or stream " \
+      "it (UDP, HTTP, RTP/RTSP).\n" \
+      "Sout streams modules allow advanced stream processing (transcoding, "\
+      "duplicating...).")
+
+#define SOUT_GENERAL_HELP N_( "General stream output settings")
+
+#define SOUT_MUX_TITLE N_( "Muxers" )
+#define SOUT_MUX_HELP N_( \
+       "Muxers create the encapsulation formats that are used to " \
+       "put all the elementary streams (video, audio, ...) " \
+       "together. This setting allows you to always force a specific muxer. " \
+       "You should probably not do that.\n" \
+       "You can also set default parameters for each muxer." )
+
+#define SOUT_ACO_TITLE N_( "Access output" )
+#define SOUT_ACO_HELP N_( \
+   "Access output modules control the ways the muxed streams are sent. " \
+   "This setting allows you to always force a specific access output method. " \
+   "You should probably not do that.\n" \
+   "You can also set default parameters for each access output.")
+
+#define SOUT_PACKET_TITLE N_( "Packetizers" )
+#define SOUT_PACKET_HELP N_( \
+        "Packetizers are used to \"preprocess\" the elementary "\
+        "streams before muxing. " \
+        "This setting allows you to always force a packetizer. " \
+        "You should probably not do that.\n" \
+        "You can also set default parameters for each packetizer." )
+
+#define SOUT_STREAM_TITLE N_("Sout stream")
+#define SOUT_STREAM_HELP N_( "Sout stream modules allow to build a sout " \
+                "processing chain. Please refer to the Streaming Howto for " \
+                "more information. You can configure default options for " \
+                "each sout stream module here.")
+
+#define SOUT_SAP_TITLE N_( "SAP" )
+#define SOUT_SAP_HELP N_( \
+                 "SAP is a way to publically announce streams that are being "\
+                 "sent using multicast UDP or RTP." )
+
+#define SOUT_VOD_TITLE N_( "VOD" )
+#define SOUT_VOD_HELP N_( "VLC's implementation of Video On Demand" )
+
+
+/* Playlist */
+#define PLAYLIST_TITLE N_( "Playlist" )
+#define PLAYLIST_HELP N_( "Settings related to playlist behaviour " \
+        "(e.g. playback mode) and to modules that automatically add "\
+        "items to the playlist (\"service discovery\" modules).")
+
+#define PGENERAL_HELP N_( "General playlist behaviour")
+#define SD_TITLE N_("Services discovery")
+#define SD_HELP N_("Services discovery modules are facilities "\
+        "that automatically add items to playlist.")
+
+/* Advanced */
+#define AADVANCED_TITLE N_( "Advanced" )
+#define AADVANCED_HELP N_( "Advanced settings. Use with care...")
+
+#define CPU_TITLE N_( "CPU features" )
+#define CPU_HELP N_( "You can choose to disable some CPU accelerations " \
+        "here. Use with extreme care!" )
+
+#define MISC_TITLE N_( "Advanced settings" )
+
+
+/* OLD */
+#if 0
+#define NETWORK_TITLE N_( "Network" )
+#define NETWORK_HELP N_( "These modules provide network functions to all " \
+                "other parts of VLC." )
+
+#define CHROMA_TITLE N_("Chroma modules settings")
+#define CHROMA_HELP N_("These settings affect chroma transformation modules.")
+
+#define PACKETIZER_TITLE  N_("Packetizer modules settings" )
+#define PACKETIZER_HELP "These are general settings for the "\
+        "packetizers used in VLC's stream output subsystem."
+
+#define ENCODER_TITLE N_("Encoders settings")
+#define ENCODER_HELP N_( \
+    "These are general settings for video/audio/subtitles encoding modules.")
+
+
+#define DIALOGS_TITLE N_("Dialog providers settings")
+#define DIALOGS_HELP  N_( \
+    "Dialog providers can be configured here.")
+
+#define SUBTITLE_DEMUX_TITLE N_("Subtitle demuxer settings")
+#define SUBTITLE_DEMUX_HELP N_( \
+    "In this section you can force the behavior of the subtitle demuxer, " \
+    "for example by setting the subtitles type or file name.")
+
+/*
+ *  A little help for modules with unknown capabilities
+ */
+
+#define UNKNOWN_TITLE N_("No help available" )
+#define UNKNOWN_HELP N_("There is no help available for these modules.")
+#endif
+
+/* This function is deprecated and is kept only for compatibility */
+static const struct config_category_t categories_array[] =
+{
+    /* Interface */
+    { CAT_INTERFACE, INTF_TITLE, INTF_HELP },
+    { SUBCAT_INTERFACE_GENERAL, INTF_TITLE, INTF_GENERAL_HELP },
+    { SUBCAT_INTERFACE_MAIN, INTF_MAIN_TITLE, INTF_MAIN_HELP },
+    { SUBCAT_INTERFACE_CONTROL, INTF_CONTROL_TITLE, INTF_CONTROL_HELP },
+    { SUBCAT_INTERFACE_HOTKEYS, INTF_HOTKEYS_TITLE, INTF_HOTKEYS_HELP },
+
+    { CAT_AUDIO, AUDIO_TITLE, AUDIO_HELP },
+    { SUBCAT_AUDIO_GENERAL, AUDIO_TITLE, AUDIO_GENERAL_HELP },
+    { SUBCAT_AUDIO_AOUT, AOUT_TITLE, AOUT_HELP },
+    { SUBCAT_AUDIO_AFILTER, AFILTER_TITLE, AFILTER_HELP },
+    { SUBCAT_AUDIO_VISUAL, AVISUAL_TITLE, AVISUAL_HELP },
+    { SUBCAT_AUDIO_MISC, AMISC_TITLE, AMISC_HELP },
+
+    { CAT_VIDEO, VIDEO_TITLE, VIDEO_HELP },
+    { SUBCAT_VIDEO_GENERAL, VIDEO_TITLE, VIDEO_GENERAL_HELP },
+    { SUBCAT_VIDEO_VOUT, _VOUT_TITLE, VOUT_HELP },
+    { SUBCAT_VIDEO_VFILTER, VFILTER_TITLE, VFILTER_HELP },
+    { SUBCAT_VIDEO_SUBPIC, SUBPIC_TITLE, SUBPIC_HELP },
+
+    { CAT_INPUT, INPUT_TITLE, INPUT_HELP },
+    { SUBCAT_INPUT_GENERAL, INPUT_TITLE, INPUT_HELP },
+    { SUBCAT_INPUT_ACCESS, ACCESS_TITLE, ACCESS_HELP },
+    { SUBCAT_INPUT_DEMUX, DEMUX_TITLE, DEMUX_HELP },
+    { SUBCAT_INPUT_VCODEC, VDEC_TITLE, VDEC_HELP },
+    { SUBCAT_INPUT_ACODEC, ADEC_TITLE, ADEC_HELP },
+    { SUBCAT_INPUT_SCODEC, SDEC_TITLE, SDEC_HELP },
+    { SUBCAT_INPUT_STREAM_FILTER, STREAM_FILTER_TITLE, STREAM_FILTER_HELP },
+
+    { CAT_SOUT, SOUT_TITLE, SOUT_HELP },
+    { SUBCAT_SOUT_GENERAL, SOUT_TITLE, SOUT_GENERAL_HELP },
+    { SUBCAT_SOUT_STREAM, SOUT_STREAM_TITLE, SOUT_STREAM_HELP },
+    { SUBCAT_SOUT_MUX, SOUT_MUX_TITLE, SOUT_MUX_HELP },
+    { SUBCAT_SOUT_ACO, SOUT_ACO_TITLE, SOUT_ACO_HELP },
+    { SUBCAT_SOUT_PACKETIZER, SOUT_PACKET_TITLE, SOUT_PACKET_HELP },
+    { SUBCAT_SOUT_SAP, SOUT_SAP_TITLE, SOUT_SAP_HELP },
+    { SUBCAT_SOUT_VOD, SOUT_VOD_TITLE, SOUT_VOD_HELP },
+
+    { CAT_PLAYLIST, PLAYLIST_TITLE , PLAYLIST_HELP },
+    { SUBCAT_PLAYLIST_GENERAL, PLAYLIST_TITLE, PGENERAL_HELP },
+    { SUBCAT_PLAYLIST_SD, SD_TITLE, SD_HELP },
+
+    { CAT_ADVANCED, AADVANCED_TITLE, AADVANCED_HELP },
+    { SUBCAT_ADVANCED_CPU, CPU_TITLE, CPU_HELP },
+    { SUBCAT_ADVANCED_MISC, MISC_TITLE, AADVANCED_HELP },
+
+    { -1, NULL, NULL }
+};
+
+VLC_USED
+static inline const char *config_CategoryNameGet( int i_value )
+{
+    int i = 0;
+    while( categories_array[i].psz_name != NULL )
+    {
+        if( categories_array[i].i_id == i_value )
+        {
+            return vlc_gettext(categories_array[i].psz_name);
+        }
+        i++;
+    }
+    return NULL;
+}
+
+VLC_USED
+static inline const char *config_CategoryHelpGet( int i_value )
+{
+    int i = 0;
+    while( categories_array[i].psz_help != NULL )
+    {
+        if( categories_array[i].i_id == i_value )
+        {
+            return vlc_gettext(categories_array[i].psz_help);
+        }
+        i++;
+    }
+    return NULL;
+}
+
+#endif /* VLC_HELP_H */

=== added file 'DivCity/DivCity/vlc/plugins/vlc_configuration.h'
--- DivCity/DivCity/vlc/plugins/vlc_configuration.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_configuration.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,308 @@
+/*****************************************************************************
+ * configuration.h : configuration management module
+ * This file describes the programming interface for the configuration module.
+ * It includes functions allowing to declare, get or set configuration options.
+ *****************************************************************************
+ * Copyright (C) 1999-2006 VLC authors and VideoLAN
+ * $Id: bd6e00b6bf70e4b6be324648146a0d5d7c0309b4 $
+ *
+ * Authors: Gildas Bazin <gbazin@videolan.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_CONFIGURATION_H
+#define VLC_CONFIGURATION_H 1
+
+/**
+ * \file
+ * This file describes the programming interface for the configuration module.
+ * It includes functions allowing to declare, get or set configuration options.
+ */
+
+# ifdef __cplusplus
+extern "C" {
+# endif
+
+/*****************************************************************************
+ * Macros used to build the configuration structure.
+ *****************************************************************************/
+
+/* Configuration hint types */
+#define CONFIG_HINT_CATEGORY                0x02  /* Start of new category */
+#define CONFIG_HINT_SUBCATEGORY             0x03  /* Start of sub-category */
+#define CONFIG_HINT_SUBCATEGORY_END         0x04  /* End of sub-category */
+#define CONFIG_HINT_USAGE                   0x05  /* Usage information */
+
+#define CONFIG_CATEGORY                     0x06 /* Set category */
+#define CONFIG_SUBCATEGORY                  0x07 /* Set subcategory */
+#define CONFIG_SECTION                      0x08 /* Start of new section */
+
+/* Configuration item types */
+#define CONFIG_ITEM_FLOAT                   0x20  /* Float option */
+#define CONFIG_ITEM_INTEGER                 0x40  /* Integer option */
+#define CONFIG_ITEM_RGB                     0x41  /* RGB color option */
+#define CONFIG_ITEM_BOOL                    0x60  /* Bool option */
+#define CONFIG_ITEM_STRING                  0x80  /* String option */
+#define CONFIG_ITEM_PASSWORD                0x81  /* Password option (*) */
+#define CONFIG_ITEM_KEY                     0x82  /* Hot key option */
+#define CONFIG_ITEM_MODULE                  0x84  /* Module option */
+#define CONFIG_ITEM_MODULE_CAT              0x85  /* Module option */
+#define CONFIG_ITEM_MODULE_LIST             0x86  /* Module option */
+#define CONFIG_ITEM_MODULE_LIST_CAT         0x87  /* Module option */
+#define CONFIG_ITEM_LOADFILE                0x8C  /* Read file option */
+#define CONFIG_ITEM_SAVEFILE                0x8D  /* Written file option */
+#define CONFIG_ITEM_DIRECTORY               0x8E  /* Directory option */
+#define CONFIG_ITEM_FONT                    0x8F  /* Font option */
+
+#define CONFIG_ITEM(x) (((x) & ~0xF) != 0)
+
+/*******************************************************************
+ * All predefined categories and subcategories
+ *******************************************************************/
+#define CAT_INTERFACE 1
+   #define SUBCAT_INTERFACE_GENERAL 101
+   #define SUBCAT_INTERFACE_MAIN 102
+   #define SUBCAT_INTERFACE_CONTROL 103
+   #define SUBCAT_INTERFACE_HOTKEYS 104
+
+#define CAT_AUDIO 2
+   #define SUBCAT_AUDIO_GENERAL 201
+   #define SUBCAT_AUDIO_AOUT 202
+   #define SUBCAT_AUDIO_AFILTER 203
+   #define SUBCAT_AUDIO_VISUAL 204
+   #define SUBCAT_AUDIO_MISC 205
+
+#define CAT_VIDEO 3
+   #define SUBCAT_VIDEO_GENERAL 301
+   #define SUBCAT_VIDEO_VOUT 302
+   #define SUBCAT_VIDEO_VFILTER 303
+   #define SUBCAT_VIDEO_TEXT 304
+   #define SUBCAT_VIDEO_SUBPIC 305
+   #define SUBCAT_VIDEO_VFILTER2 306
+
+#define CAT_INPUT 4
+   #define SUBCAT_INPUT_GENERAL 401
+   #define SUBCAT_INPUT_ACCESS 402
+   #define SUBCAT_INPUT_DEMUX 403
+   #define SUBCAT_INPUT_VCODEC 404
+   #define SUBCAT_INPUT_ACODEC 405
+   #define SUBCAT_INPUT_SCODEC 406
+   #define SUBCAT_INPUT_STREAM_FILTER 407
+
+#define CAT_SOUT 5
+   #define SUBCAT_SOUT_GENERAL 501
+   #define SUBCAT_SOUT_STREAM 502
+   #define SUBCAT_SOUT_MUX 503
+   #define SUBCAT_SOUT_ACO 504
+   #define SUBCAT_SOUT_PACKETIZER 505
+   #define SUBCAT_SOUT_SAP 506
+   #define SUBCAT_SOUT_VOD 507
+
+#define CAT_ADVANCED 6
+   #define SUBCAT_ADVANCED_CPU 601
+   #define SUBCAT_ADVANCED_MISC 602
+   #define SUBCAT_ADVANCED_NETWORK 603
+   #define SUBCAT_ADVANCED_XML 604
+
+#define CAT_PLAYLIST 7
+   #define SUBCAT_PLAYLIST_GENERAL 701
+   #define SUBCAT_PLAYLIST_SD 702
+   #define SUBCAT_PLAYLIST_EXPORT 703
+
+#define CAT_OSD 8
+   #define SUBCAT_OSD_IMPORT 801
+
+struct config_category_t
+{
+    int         i_id;
+    const char *psz_name;
+    const char *psz_help;
+};
+
+typedef union
+{
+    char       *psz;
+    int64_t     i;
+    float       f;
+} module_value_t;
+
+struct module_config_t
+{
+    char        *psz_type;                          /* Configuration subtype */
+    char        *psz_name;                                    /* Option name */
+    char        *psz_text;      /* Short comment on the configuration option */
+    char        *psz_longtext;   /* Long comment on the configuration option */
+    module_value_t value;                                    /* Option value */
+    module_value_t orig;
+    module_value_t min;
+    module_value_t max;
+
+    /* Values list */
+    char **      ppsz_list;       /* List of possible values for the option */
+    int         *pi_list;                              /* Idem for integers */
+    char       **ppsz_list_text;          /* Friendly names for list values */
+    int          i_list;                               /* Options list size */
+    vlc_callback_t pf_update_list; /* Callback to initialize dropdown lists */
+    uint8_t      i_type;                              /* Configuration type */
+    char         i_short;                     /* Optional short option name */
+
+    /* Misc */
+    unsigned    b_dirty:1;        /* Dirty flag to indicate a config change */
+    unsigned    b_advanced:1;        /* Flag to indicate an advanced option */
+    unsigned    b_internal:1; /* Flag to indicate option is not to be shown */
+    unsigned    b_unsaveable:1;               /* Config should not be saved */
+    unsigned    b_safe:1;       /* Safe to use in web plugins and playlists */
+
+    /* Actions list */
+    int            i_action;                           /* actions list size */
+    vlc_callback_t *ppf_action;    /* List of possible actions for a config */
+    char          **ppsz_action_text;         /* Friendly names for actions */
+
+    /* Deprecated */
+    bool        b_removed;
+};
+
+/*****************************************************************************
+ * Prototypes - these methods are used to get, set or manipulate configuration
+ * data.
+ *****************************************************************************/
+VLC_API int config_GetType(vlc_object_t *, const char *) VLC_USED;
+VLC_API int64_t config_GetInt(vlc_object_t *, const char *) VLC_USED;
+VLC_API void config_PutInt(vlc_object_t *, const char *, int64_t);
+VLC_API float config_GetFloat(vlc_object_t *, const char *) VLC_USED;
+VLC_API void config_PutFloat(vlc_object_t *, const char *, float);
+VLC_API char * config_GetPsz(vlc_object_t *, const char *) VLC_USED VLC_MALLOC;
+VLC_API void config_PutPsz(vlc_object_t *, const char *, const char *);
+
+VLC_API int config_SaveConfigFile( vlc_object_t * );
+#define config_SaveConfigFile(a) config_SaveConfigFile(VLC_OBJECT(a))
+
+VLC_API void config_ResetAll( vlc_object_t * );
+#define config_ResetAll(a) config_ResetAll(VLC_OBJECT(a))
+
+VLC_API module_config_t * config_FindConfig( vlc_object_t *, const char * ) VLC_USED;
+VLC_API char * config_GetDataDir( vlc_object_t * ) VLC_USED VLC_MALLOC;
+#define config_GetDataDir(a) config_GetDataDir(VLC_OBJECT(a))
+VLC_API const char * config_GetLibDir( void ) VLC_USED;
+VLC_API const char * config_GetConfDir( void ) VLC_USED;
+
+typedef enum vlc_userdir
+{
+    VLC_HOME_DIR, /* User's home */
+    VLC_CONFIG_DIR, /* VLC-specific configuration directory */
+    VLC_DATA_DIR, /* VLC-specific data directory */
+    VLC_CACHE_DIR, /* VLC-specific user cached data directory */
+    /* Generic directories (same as XDG) */
+    VLC_DESKTOP_DIR=0x80,
+    VLC_DOWNLOAD_DIR,
+    VLC_TEMPLATES_DIR,
+    VLC_PUBLICSHARE_DIR,
+    VLC_DOCUMENTS_DIR,
+    VLC_MUSIC_DIR,
+    VLC_PICTURES_DIR,
+    VLC_VIDEOS_DIR,
+} vlc_userdir_t;
+
+VLC_API char * config_GetUserDir( vlc_userdir_t ) VLC_USED VLC_MALLOC;
+
+VLC_API void config_AddIntf( vlc_object_t *, const char * );
+VLC_API void config_RemoveIntf( vlc_object_t *, const char * );
+VLC_API bool config_ExistIntf( vlc_object_t *, const char * ) VLC_USED;
+
+#define config_GetType(a,b) config_GetType(VLC_OBJECT(a),b)
+#define config_GetInt(a,b) config_GetInt(VLC_OBJECT(a),b)
+#define config_PutInt(a,b,c) config_PutInt(VLC_OBJECT(a),b,c)
+#define config_GetFloat(a,b) config_GetFloat(VLC_OBJECT(a),b)
+#define config_PutFloat(a,b,c) config_PutFloat(VLC_OBJECT(a),b,c)
+#define config_GetPsz(a,b) config_GetPsz(VLC_OBJECT(a),b)
+#define config_PutPsz(a,b,c) config_PutPsz(VLC_OBJECT(a),b,c)
+
+#define config_AddIntf(a,b) config_AddIntf(VLC_OBJECT(a),b)
+#define config_RemoveIntf(a,b) config_RemoveIntf(VLC_OBJECT(a),b)
+#define config_ExistIntf(a,b) config_ExistIntf(VLC_OBJECT(a),b)
+
+/****************************************************************************
+ * config_chain_t:
+ ****************************************************************************/
+struct config_chain_t
+{
+    config_chain_t *p_next;     /**< Pointer on the next config_chain_t element */
+
+    char        *psz_name;      /**< Option name */
+    char        *psz_value;     /**< Option value */
+};
+
+/**
+ * This function will
+ * - create all options in the array ppsz_options (var_Create).
+ * - parse the given linked list of config_chain_t and set the value (var_Set).
+ *
+ * The option names will be created by adding the psz_prefix prefix.
+ */
+VLC_API void config_ChainParse( vlc_object_t *, const char *psz_prefix, const char *const *ppsz_options, config_chain_t * );
+#define config_ChainParse( a, b, c, d ) config_ChainParse( VLC_OBJECT(a), b, c, d )
+
+/**
+ * This function will parse a configuration string (psz_string) and
+ * - set the module name (*ppsz_name)
+ * - set all options for this module in a chained list (*pp_cfg)
+ * - returns a pointer on the next module if any.
+ *
+ * The string format is
+ *   module{option=*,option=*}[:modulenext{option=*,...}]
+ *
+ * The options values are unescaped using config_StringUnescape.
+ */
+VLC_API char *config_ChainCreate( char **ppsz_name, config_chain_t **pp_cfg, const char *psz_string ) VLC_USED VLC_MALLOC;
+
+/**
+ * This function will release a linked list of config_chain_t
+ * (Including the head)
+ */
+VLC_API void config_ChainDestroy( config_chain_t * );
+
+/**
+ * This function will duplicate a linked list of config_chain_t
+ */
+VLC_API config_chain_t * config_ChainDuplicate( const config_chain_t * ) VLC_USED VLC_MALLOC;
+
+/**
+ * This function will unescape a string in place and will return a pointer on
+ * the given string.
+ * No memory is allocated by it (unlike config_StringEscape).
+ * If NULL is given as parameter nothing will be done (NULL will be returned).
+ *
+ * The following sequences will be unescaped (only one time):
+ * \\ \' and \"
+ */
+VLC_API char * config_StringUnescape( char *psz_string );
+
+/**
+ * This function will escape a string that can be unescaped by
+ * config_StringUnescape.
+ * The returned value is allocated by it. You have to free it once you
+ * do not need it anymore (unlike config_StringUnescape).
+ * If NULL is given as parameter nothing will be done (NULL will be returned).
+ *
+ * The escaped characters are ' " and \
+ */
+VLC_API char * config_StringEscape( const char *psz_string ) VLC_USED VLC_MALLOC;
+
+# ifdef __cplusplus
+}
+# endif
+
+#endif /* _VLC_CONFIGURATION_H */

=== added file 'DivCity/DivCity/vlc/plugins/vlc_cpu.h'
--- DivCity/DivCity/vlc/plugins/vlc_cpu.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_cpu.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,113 @@
+/*****************************************************************************
+ * vlc_cpu.h: CPU capabilities
+ *****************************************************************************
+ * Copyright (C) 1998-2009 VLC authors and VideoLAN
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+/**
+ * \file
+ * This file provides CPU-specific optimization flags.
+ */
+
+#ifndef VLC_CPU_H
+# define VLC_CPU_H 1
+
+# if defined (__i386__) || defined (__x86_64__)
+#  define CPU_CAPABILITY_MMX     (1<<3)
+#  define CPU_CAPABILITY_3DNOW   (1<<4)
+#  define CPU_CAPABILITY_MMXEXT  (1<<5)
+#  define CPU_CAPABILITY_SSE     (1<<6)
+#  define CPU_CAPABILITY_SSE2    (1<<7)
+#  define CPU_CAPABILITY_SSE3    (1<<8)
+#  define CPU_CAPABILITY_SSSE3   (1<<9)
+#  define CPU_CAPABILITY_SSE4_1  (1<<10)
+#  define CPU_CAPABILITY_SSE4_2  (1<<11)
+#  define CPU_CAPABILITY_SSE4A   (1<<12)
+
+# if defined (__MMX__)
+#  define VLC_MMX
+# elif VLC_GCC_VERSION(4, 4)
+#  define VLC_MMX __attribute__ ((__target__ ("mmx")))
+# else
+#  define VLC_MMX VLC_MMX_is_not_implemented_on_this_compiler
+# endif
+
+# if defined (__SSE__)
+#  define VLC_SSE
+# elif VLC_GCC_VERSION(4, 4)
+#  define VLC_SSE __attribute__ ((__target__ ("sse")))
+# else
+#  define VLC_SSE VLC_SSE_is_not_implemented_on_this_compiler
+# endif
+
+# else
+#  define CPU_CAPABILITY_MMX     (0)
+#  define CPU_CAPABILITY_3DNOW   (0)
+#  define CPU_CAPABILITY_MMXEXT  (0)
+#  define CPU_CAPABILITY_SSE     (0)
+#  define CPU_CAPABILITY_SSE2    (0)
+#  define CPU_CAPABILITY_SSE3    (0)
+#  define CPU_CAPABILITY_SSSE3   (0)
+#  define CPU_CAPABILITY_SSE4_1  (0)
+#  define CPU_CAPABILITY_SSE4_2  (0)
+#  define CPU_CAPABILITY_SSE4A   (0)
+# endif
+
+# if defined (__ppc__) || defined (__ppc64__) || defined (__powerpc__)
+#  define CPU_CAPABILITY_ALTIVEC (1<<16)
+# else
+#  define CPU_CAPABILITY_ALTIVEC (0)
+# endif
+
+# if defined (__arm__)
+#  define CPU_CAPABILITY_NEON    (1<<24)
+# else
+#  define CPU_CAPABILITY_NEON    (0)
+# endif
+
+VLC_API unsigned vlc_CPU( void );
+
+/** Are floating point operations fast?
+ * If this bit is not set, you should try to use fixed-point instead.
+ */
+# if defined (__i386__) || defined (__x86_64__)
+#  define HAVE_FPU 1
+
+# elif defined (__powerpc__) || defined (__ppc__) || defined (__ppc64__)
+#  define HAVE_FPU 1
+
+# elif defined (__arm__)
+#  if defined (__VFP_FP__) && !defined (__SOFTFP__)
+#   define HAVE_FPU 1
+#  else
+#   define HAVE_FPU 0
+#  endif
+
+# elif defined (__sparc__)
+#  define HAVE_FPU 1
+
+# else
+#  define HAVE_FPU 0
+
+# endif
+
+typedef void *(*vlc_memcpy_t) (void *tgt, const void *src, size_t n);
+
+VLC_API void vlc_fastmem_register(vlc_memcpy_t cpy);
+
+#endif /* !VLC_CPU_H */
+

=== added file 'DivCity/DivCity/vlc/plugins/vlc_demux.h'
--- DivCity/DivCity/vlc/plugins/vlc_demux.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_demux.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,222 @@
+/*****************************************************************************
+ * vlc_demux.h: Demuxer descriptor, queries and methods
+ *****************************************************************************
+ * Copyright (C) 1999-2005 VLC authors and VideoLAN
+ * $Id: 2ae2f841961977db764eef08ea502b60a07c160b $
+ *
+ * Authors: Laurent Aimar <fenrir@via.ecp.fr>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_DEMUX_H
+#define VLC_DEMUX_H 1
+
+/**
+ * \file
+ * This files defines functions and structures used by demux objects in vlc
+ */
+
+#include <vlc_es.h>
+#include <vlc_stream.h>
+#include <vlc_es_out.h>
+
+/**
+ * \defgroup demux Demux
+ * @{
+ */
+
+struct demux_t
+{
+    VLC_COMMON_MEMBERS
+
+    /* Module properties */
+    module_t    *p_module;
+
+    /* eg informative but needed (we can have access+demux) */
+    char        *psz_access;
+    char        *psz_demux;
+    char        *psz_location;
+    char        *psz_file;
+
+    /* input stream */
+    stream_t    *s;     /* NULL in case of a access+demux in one */
+
+    /* es output */
+    es_out_t    *out;   /* our p_es_out */
+
+    /* set by demuxer */
+    int (*pf_demux)  ( demux_t * );   /* demux one frame only */
+    int (*pf_control)( demux_t *, int i_query, va_list args);
+
+    /* Demux has to maintain them uptodate
+     * when it is responsible of seekpoint/title */
+    struct
+    {
+        unsigned int i_update;  /* Demux sets them on change,
+                                   Input removes them once take into account*/
+        /* Seekpoint/Title at demux level */
+        int          i_title;       /* idem, start from 0 (could be menu) */
+        int          i_seekpoint;   /* idem, start from 0 */
+    } info;
+    demux_sys_t *p_sys;
+
+    /* Weak link to parent input */
+    input_thread_t *p_input;
+};
+
+
+/* demux_meta_t is returned by "meta reader" module to the demuxer */
+typedef struct demux_meta_t
+{
+    VLC_COMMON_MEMBERS
+    demux_t *p_demux; /** FIXME: use stream_t instead? */
+    input_item_t *p_item; /***< the input item that is being read */
+
+    vlc_meta_t *p_meta;                 /**< meta data */
+
+    int i_attachments;                  /**< number of attachments */
+    input_attachment_t **attachments;    /**< array of attachments */
+} demux_meta_t;
+
+enum demux_query_e
+{
+    /* I. Common queries to access_demux and demux */
+    /* POSITION double between 0.0 and 1.0 */
+    DEMUX_GET_POSITION,         /* arg1= double *       res=    */
+    DEMUX_SET_POSITION,         /* arg1= double arg2= bool b_precise    res=can fail    */
+
+    /* LENGTH/TIME in microsecond, 0 if unknown */
+    DEMUX_GET_LENGTH,           /* arg1= int64_t *      res=    */
+    DEMUX_GET_TIME,             /* arg1= int64_t *      res=    */
+    DEMUX_SET_TIME,             /* arg1= int64_t arg2= bool b_precise   res=can fail    */
+
+    /* TITLE_INFO only if more than 1 title or 1 chapter */
+    DEMUX_GET_TITLE_INFO,       /* arg1=input_title_t*** arg2=int*
+                                   arg3=int*pi_title_offset(0), arg4=int*pi_seekpoint_offset(0) can fail */
+    /* TITLE/SEEKPOINT, only when TITLE_INFO succeed */
+    DEMUX_SET_TITLE,            /* arg1= int            can fail */
+    DEMUX_SET_SEEKPOINT,        /* arg1= int            can fail */
+
+    /* DEMUX_SET_GROUP only a hit for demuxer (mainly DVB) to allow not
+     * reading everything (you should not use this to call es_out_Control)
+     * if you don't know what to do with it, just IGNORE it, it is safe(r)
+     * -1 means all group, 0 default group (first es added) */
+    DEMUX_SET_GROUP,            /* arg1= int, arg2=const vlc_list_t *   can fail */
+
+    /* Ask the demux to demux until the given date at the next pf_demux call
+     * but not more (and not less, at the precision available of course).
+     * XXX: not mandatory (except for subtitle demux) but I will help a lot
+     * for multi-input
+     */
+    DEMUX_SET_NEXT_DEMUX_TIME,  /* arg1= int64_t *      can fail */
+    /* FPS for correct subtitles handling */
+    DEMUX_GET_FPS,              /* arg1= double *       res=can fail    */
+
+    /* Meta data */
+    DEMUX_GET_META,             /* arg1= vlc_meta_t **  res=can fail    */
+    DEMUX_HAS_UNSUPPORTED_META, /* arg1= bool *   res can fail    */
+
+    /* Attachments */
+    DEMUX_GET_ATTACHMENTS,      /* arg1=input_attachment_t***, int* res=can fail */
+
+    /* RECORD you are ensured that it is never called twice with the same state
+     * you should accept it only if the stream can be recorded without
+     * any modification or header addition. */
+    DEMUX_CAN_RECORD,           /* arg1=bool*   res=can fail(assume false) */
+    DEMUX_SET_RECORD_STATE,     /* arg1=bool    res=can fail */
+
+
+    /* II. Specific access_demux queries */
+    /* PAUSE you are ensured that it is never called twice with the same state */
+    DEMUX_CAN_PAUSE = 0x1000,   /* arg1= bool*    can fail (assume false)*/
+    DEMUX_SET_PAUSE_STATE,      /* arg1= bool     can fail */
+
+    DEMUX_GET_PTS_DELAY,        /* arg1= int64_t*       cannot fail */
+
+    /* DEMUX_CAN_CONTROL_PACE returns true (*pb_pace) if we can read the
+     * data at our pace */
+    DEMUX_CAN_CONTROL_PACE,     /* arg1= bool*pb_pace    can fail (assume false) */
+
+    /* DEMUX_CAN_CONTROL_RATE is called only if DEMUX_CAN_CONTROL_PACE has returned false.
+     * *pb_rate should be true when the rate can be changed (using DEMUX_SET_RATE)
+     * *pb_ts_rescale should be true when the timestamps (pts/dts/pcr) have to be rescaled */
+    DEMUX_CAN_CONTROL_RATE,     /* arg1= bool*pb_rate arg2= bool*pb_ts_rescale  can fail(assume false) */
+    /* DEMUX_SET_RATE is called only if DEMUX_CAN_CONTROL_RATE has returned true.
+     * It should return the value really used in *pi_rate */
+    DEMUX_SET_RATE,             /* arg1= int*pi_rate                                        can fail */
+
+    DEMUX_CAN_SEEK,            /* arg1= bool*    can fail (assume false)*/
+};
+
+VLC_API int demux_vaControlHelper( stream_t *, int64_t i_start, int64_t i_end, int64_t i_bitrate, int i_align, int i_query, va_list args );
+
+/*************************************************************************
+ * Miscellaneous helpers for demuxers
+ *************************************************************************/
+
+VLC_USED
+static inline bool demux_IsPathExtension( demux_t *p_demux, const char *psz_extension )
+{
+    if( !p_demux->psz_file )
+        return false;
+
+    const char *psz_ext = strrchr ( p_demux->psz_file, '.' );
+    if( !psz_ext || strcasecmp( psz_ext, psz_extension ) )
+        return false;
+    return true;
+}
+
+VLC_USED
+static inline bool demux_IsForced( demux_t *p_demux, const char *psz_name )
+{
+   if( !p_demux->psz_demux || strcmp( p_demux->psz_demux, psz_name ) )
+        return false;
+    return true;
+}
+
+/**
+ * This function will create a packetizer suitable for a demuxer that parses
+ * elementary stream.
+ *
+ * The provided es_format_t will be cleaned on error or by
+ * demux_PacketizerDestroy.
+ */
+VLC_API decoder_t * demux_PacketizerNew( demux_t *p_demux, es_format_t *p_fmt, const char *psz_msg ) VLC_USED;
+
+/**
+ * This function will destroy a packetizer create by demux_PacketizerNew.
+ */
+VLC_API void demux_PacketizerDestroy( decoder_t *p_packetizer );
+
+/**
+ * This function will return the parent input of this demux.
+ * It is retained. Can return NULL.
+ */
+VLC_API input_thread_t * demux_GetParentInput( demux_t *p_demux ) VLC_USED;
+
+/* */
+#define DEMUX_INIT_COMMON() do {            \
+    p_demux->pf_control = Control;          \
+    p_demux->pf_demux = Demux;              \
+    p_demux->p_sys = calloc( 1, sizeof( demux_sys_t ) ); \
+    if( !p_demux->p_sys ) return VLC_ENOMEM;\
+    } while(0)
+
+/**
+ * @}
+ */
+
+#endif

=== added file 'DivCity/DivCity/vlc/plugins/vlc_dialog.h'
--- DivCity/DivCity/vlc/plugins/vlc_dialog.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_dialog.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,122 @@
+/*****************************************************************************
+ * vlc_dialog.h: user interaction dialogs
+ *****************************************************************************
+ * Copyright (C) 2009 RÃ©mi Denis-Courmont
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_DIALOG_H_
+#define VLC_DIALOG_H_
+# include <stdarg.h>
+
+/**
+ * \file vlc_dialog.h
+ * User interaction dialog APIs
+ */
+
+/**
+ * A fatal error dialog.
+ * No response expected from the user.
+ */
+typedef struct dialog_fatal_t
+{
+    const char *title;
+    const char *message;
+} dialog_fatal_t;
+
+VLC_API void dialog_VFatal(vlc_object_t *, bool, const char *, const char *, va_list);
+
+static inline VLC_FORMAT(3, 4)
+void dialog_Fatal (vlc_object_t *obj, const char *title, const char *fmt, ...)
+{
+     va_list ap;
+
+     va_start (ap, fmt);
+     dialog_VFatal(obj, false, title, fmt, ap);
+     va_end (ap);
+}
+#define dialog_Fatal(o, t, ...) \
+        dialog_Fatal(VLC_OBJECT(o), t, __VA_ARGS__)
+
+static inline VLC_FORMAT(3, 4)
+void dialog_FatalWait (vlc_object_t *obj, const char *title,
+                       const char *fmt, ...){
+     va_list ap;
+
+     va_start (ap, fmt);
+     dialog_VFatal(obj, true, title, fmt, ap);
+     va_end (ap);
+}
+#define dialog_FatalWait(o, t, ...) \
+        dialog_FatalWait(VLC_OBJECT(o), t, __VA_ARGS__)
+
+/**
+ * A login dialog.
+ */
+typedef struct dialog_login_t
+{
+    const char *title;
+    const char *message;
+    char **username;
+    char **password;
+} dialog_login_t;
+
+VLC_API void dialog_Login(vlc_object_t *, char **, char **, const char *, const char *, ...) VLC_FORMAT (5, 6);
+#define dialog_Login(o, u, p, t, ...) \
+        dialog_Login(VLC_OBJECT(o), u, p, t, __VA_ARGS__)
+
+/**
+ * A question dialog.
+ */
+typedef struct dialog_question_t
+{
+    const char *title;
+    const char *message;
+    const char *yes;
+    const char *no;
+    const char *cancel;
+    int answer;
+} dialog_question_t;
+
+VLC_API int dialog_Question(vlc_object_t *, const char *, const char *, const char *, const char *, const char *);
+#define dialog_Question(o, t, m, y, n, c) \
+        dialog_Question(VLC_OBJECT(o), t, m, y, n, c)
+
+typedef struct dialog_progress_bar_t
+{   /* Request-time parameters */
+    const char *title;
+    const char *message;
+    const char *cancel;
+    /* Permanent parameters */
+    void (*pf_update) (void *, const char *, float);
+    bool (*pf_check) (void *);
+    void (*pf_destroy) (void *);
+    void *p_sys;
+} dialog_progress_bar_t;
+
+VLC_API dialog_progress_bar_t * dialog_ProgressCreate(vlc_object_t *, const char *, const char *, const char *) VLC_USED;
+#define dialog_ProgressCreate(o, t, m, c) \
+        dialog_ProgressCreate(VLC_OBJECT(o), t, m, c)
+VLC_API void dialog_ProgressDestroy(dialog_progress_bar_t *);
+VLC_API void dialog_ProgressSet(dialog_progress_bar_t *, const char *, float);
+VLC_API bool dialog_ProgressCancelled(dialog_progress_bar_t *);
+
+VLC_API int dialog_Register(vlc_object_t *);
+VLC_API int dialog_Unregister(vlc_object_t *);
+#define dialog_Register(o) dialog_Register(VLC_OBJECT(o))
+#define dialog_Unregister(o) dialog_Unregister(VLC_OBJECT(o))
+
+#endif

=== added file 'DivCity/DivCity/vlc/plugins/vlc_epg.h'
--- DivCity/DivCity/vlc/plugins/vlc_epg.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_epg.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,96 @@
+/*****************************************************************************
+ * vlc_epg.h: Electronic Program Guide
+ *****************************************************************************
+ * Copyright (C) 2007 VLC authors and VideoLAN
+ * $Id: 25d8ed275d918e16bf5b12ba494d234ed379cb19 $
+ *
+ * Authors: Laurent Aimar <fenrir@via.ecp.fr>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_EPG_H
+#define VLC_EPG_H 1
+
+/**
+ * \file
+ * This file defines functions and structures for storing dvb epg information
+ */
+
+typedef struct
+{
+    int64_t i_start;    /* Interpreted as a value return by time() */
+    int     i_duration;    /* Duration of the event in second */
+
+    char    *psz_name;
+    char    *psz_short_description;
+    char    *psz_description;
+
+} vlc_epg_event_t;
+
+typedef struct
+{
+    char            *psz_name;
+    vlc_epg_event_t *p_current; /* Can be null or should be the same than one of pp_event entry */
+
+    int             i_event;
+    vlc_epg_event_t **pp_event;
+} vlc_epg_t;
+
+/**
+ * It initializes a vlc_epg_t.
+ *
+ * You must call vlc_epg_Clean to release the associated resource.
+ */
+VLC_API void vlc_epg_Init(vlc_epg_t *p_epg, const char *psz_name);
+
+/**
+ * It releases all resources associated to a vlc_epg_t
+ */
+VLC_API void vlc_epg_Clean(vlc_epg_t *p_epg);
+
+/**
+ * It creates and appends a new vlc_epg_event_t to a vlc_epg_t.
+ *
+ * \see vlc_epg_t for the definitions of the parameters.
+ */
+VLC_API void vlc_epg_AddEvent(vlc_epg_t *p_epg, int64_t i_start, int i_duration, const char *psz_name, const char *psz_short_description, const char *psz_description);
+
+/**
+ * It creates a new vlc_epg_t*
+ *
+ * You must call vlc_epg_Delete to release the associated resource.
+ */
+VLC_API vlc_epg_t * vlc_epg_New(const char *psz_name) VLC_USED;
+
+/**
+ * It releases a vlc_epg_t*.
+ */
+VLC_API void vlc_epg_Delete(vlc_epg_t *p_epg);
+
+/**
+ * It set the current event of a vlc_epg_t given a start time
+ */
+VLC_API void vlc_epg_SetCurrent(vlc_epg_t *p_epg, int64_t i_start);
+
+/**
+ * It merges all the event of \p p_src and \p p_dst into \p p_dst.
+ *
+ * \p p_src is not modified.
+ */
+VLC_API void vlc_epg_Merge(vlc_epg_t *p_dst, const vlc_epg_t *p_src);
+
+#endif
+

=== added file 'DivCity/DivCity/vlc/plugins/vlc_es.h'
--- DivCity/DivCity/vlc/plugins/vlc_es.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_es.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,327 @@
+/*****************************************************************************
+ * vlc_es.h: Elementary stream formats descriptions
+ *****************************************************************************
+ * Copyright (C) 1999-2001 VLC authors and VideoLAN
+ * $Id: d80ec4d0bdf24100fcafd3536cee346e8dbd060d $
+ *
+ * Authors: Laurent Aimar <fenrir@via.ecp.fr>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_ES_H
+#define VLC_ES_H 1
+
+#include <vlc_fourcc.h>
+
+/**
+ * \file
+ * This file defines the elementary streams format types
+ */
+
+/**
+ * video palette data
+ * \see video_format_t
+ * \see subs_format_t
+ */
+struct video_palette_t
+{
+    int i_entries;      /**< to keep the compatibility with ffmpeg's palette */
+    uint8_t palette[256][4];                   /**< 4-byte RGBA/YUVA palette */
+};
+
+/**
+ * audio replay gain description
+ */
+#define AUDIO_REPLAY_GAIN_MAX (2)
+#define AUDIO_REPLAY_GAIN_TRACK (0)
+#define AUDIO_REPLAY_GAIN_ALBUM (1)
+typedef struct
+{
+    /* true if we have the peak value */
+    bool pb_peak[AUDIO_REPLAY_GAIN_MAX];
+    /* peak value where 1.0 means full sample value */
+    float      pf_peak[AUDIO_REPLAY_GAIN_MAX];
+
+    /* true if we have the gain value */
+    bool pb_gain[AUDIO_REPLAY_GAIN_MAX];
+    /* gain value in dB */
+    float      pf_gain[AUDIO_REPLAY_GAIN_MAX];
+} audio_replay_gain_t;
+
+/**
+ * audio format description
+ */
+struct audio_format_t
+{
+    vlc_fourcc_t i_format;                          /**< audio format fourcc */
+    unsigned int i_rate;                              /**< audio sample-rate */
+
+    /* Describes the channels configuration of the samples (ie. number of
+     * channels which are available in the buffer, and positions). */
+    uint32_t     i_physical_channels;
+
+    /* Describes from which original channels, before downmixing, the
+     * buffer is derived. */
+    uint32_t     i_original_channels;
+
+    /* Optional - for A/52, SPDIF and DTS types : */
+    /* Bytes used by one compressed frame, depends on bitrate. */
+    unsigned int i_bytes_per_frame;
+
+    /* Number of sampleframes contained in one compressed frame. */
+    unsigned int i_frame_length;
+    /* Please note that it may be completely arbitrary - buffers are not
+     * obliged to contain a integral number of so-called "frames". It's
+     * just here for the division :
+     * buffer_size = i_nb_samples * i_bytes_per_frame / i_frame_length
+     */
+
+    /* FIXME ? (used by the codecs) */
+    unsigned     i_bitspersample;
+    unsigned     i_blockalign;
+    uint8_t      i_channels; /* must be <=32 */
+};
+
+/**
+ * video format description
+ */
+struct video_format_t
+{
+    vlc_fourcc_t i_chroma;                               /**< picture chroma */
+
+    unsigned int i_width;                                 /**< picture width */
+    unsigned int i_height;                               /**< picture height */
+    unsigned int i_x_offset;               /**< start offset of visible area */
+    unsigned int i_y_offset;               /**< start offset of visible area */
+    unsigned int i_visible_width;                 /**< width of visible area */
+    unsigned int i_visible_height;               /**< height of visible area */
+
+    unsigned int i_bits_per_pixel;             /**< number of bits per pixel */
+
+    unsigned int i_sar_num;                   /**< sample/pixel aspect ratio */
+    unsigned int i_sar_den;
+
+    unsigned int i_frame_rate;                     /**< frame rate numerator */
+    unsigned int i_frame_rate_base;              /**< frame rate denominator */
+
+    uint32_t i_rmask, i_gmask, i_bmask;          /**< color masks for RGB chroma */
+    int i_rrshift, i_lrshift;
+    int i_rgshift, i_lgshift;
+    int i_rbshift, i_lbshift;
+    video_palette_t *p_palette;              /**< video palette from demuxer */
+};
+
+/**
+ * Initialize a video_format_t structure with chroma 'i_chroma'
+ * \param p_src pointer to video_format_t structure
+ * \param i_chroma chroma value to use
+ */
+static inline void video_format_Init( video_format_t *p_src, vlc_fourcc_t i_chroma )
+{
+    memset( p_src, 0, sizeof( video_format_t ) );
+    p_src->i_chroma = i_chroma;
+    p_src->i_sar_num = p_src->i_sar_den = 1;
+    p_src->p_palette = NULL;
+}
+
+/**
+ * Copy video_format_t including the palette
+ * \param p_dst video_format_t to copy to
+ * \param p_src video_format_t to copy from
+ */
+static inline int video_format_Copy( video_format_t *p_dst, const video_format_t *p_src )
+{
+    memcpy( p_dst, p_src, sizeof( *p_dst ) );
+    if( p_src->p_palette )
+    {
+        p_dst->p_palette = (video_palette_t *) malloc( sizeof( video_palette_t ) );
+        if( !p_dst->p_palette )
+            return VLC_ENOMEM;
+        memcpy( p_dst->p_palette, p_src->p_palette, sizeof( *p_dst->p_palette ) );
+    }
+    return VLC_SUCCESS;
+}
+
+/**
+ * Cleanup and free palette of this video_format_t
+ * \param p_src video_format_t structure to clean
+ */
+static inline void video_format_Clean( video_format_t *p_src )
+{
+    free( p_src->p_palette );
+    memset( p_src, 0, sizeof( video_format_t ) );
+    p_src->p_palette = NULL;
+}
+
+/**
+ * It will fill up a video_format_t using the given arguments.
+ * Note that the video_format_t must already be initialized.
+ */
+VLC_API void video_format_Setup( video_format_t *, vlc_fourcc_t i_chroma, int i_width, int i_height, int i_sar_num, int i_sar_den );
+
+/**
+ * It will copy the crop properties from a video_format_t to another.
+ */
+VLC_API void video_format_CopyCrop( video_format_t *, const video_format_t * );
+
+/**
+ * It will compute the crop/ar properties when scaling.
+ */
+VLC_API void video_format_ScaleCropAr( video_format_t *, const video_format_t * );
+
+/**
+ * This function will check if the first video format is similar
+ * to the second one.
+ */
+VLC_API bool video_format_IsSimilar( const video_format_t *, const video_format_t * );
+
+/**
+ * It prints details about the given video_format_t
+ */
+VLC_API void video_format_Print( vlc_object_t *, const char *, const video_format_t * );
+
+/**
+ * subtitles format description
+ */
+struct subs_format_t
+{
+    /* the character encoding of the text of the subtitle.
+     * all gettext recognized shorts can be used */
+    char *psz_encoding;
+
+
+    int  i_x_origin; /**< x coordinate of the subtitle. 0 = left */
+    int  i_y_origin; /**< y coordinate of the subtitle. 0 = top */
+
+    struct
+    {
+        /*  */
+        uint32_t palette[16+1];
+
+        /* the width of the original movie the spu was extracted from */
+        int i_original_frame_width;
+        /* the height of the original movie the spu was extracted from */
+        int i_original_frame_height;
+    } spu;
+
+    struct
+    {
+        int i_id;
+    } dvb;
+    struct
+    {
+        int i_magazine;
+        int i_page;
+    } teletext;
+};
+
+/**
+ * ES language definition
+ */
+typedef struct extra_languages_t
+{
+        char *psz_language;
+        char *psz_description;
+} extra_languages_t;
+
+/**
+ * ES format definition
+ */
+struct es_format_t
+{
+    int             i_cat;              /**< ES category @see es_format_category_e */
+    vlc_fourcc_t    i_codec;            /**< FOURCC value as used in vlc */
+    vlc_fourcc_t    i_original_fourcc;  /**< original FOURCC from the container */
+
+    int             i_id;       /**< es identifier, where means
+                                    -1: let the core mark the right id
+                                    >=0: valid id */
+    int             i_group;    /**< group identifier, where means:
+                                    -1 : standalone
+                                    >= 0 then a "group" (program) is created
+                                        for each value */
+    int             i_priority; /**< priority, where means:
+                                    -2 : mean not selectable by the users
+                                    -1 : mean not selected by default even
+                                         when no other stream
+                                    >=0: priority */
+
+    char            *psz_language;        /**< human readible language name */
+    char            *psz_description;     /**< human readible description of language */
+    int             i_extra_languages;    /**< length in bytes of extra language data pointer */
+    extra_languages_t *p_extra_languages; /**< extra language data needed by some decoders */
+
+    audio_format_t  audio;    /**< description of audio format */
+    audio_replay_gain_t audio_replay_gain; /*< audio replay gain information */
+    video_format_t video;     /**< description of video format */
+    subs_format_t  subs;      /**< description of subtitle format */
+
+    unsigned int   i_bitrate; /**< bitrate of this ES */
+    int      i_profile;       /**< codec specific information (like real audio flavor, mpeg audio layer, h264 profile ...) */
+    int      i_level;         /**< codec specific information: indicates maximum restrictions on the stream (resolution, bitrate, codec features ...) */
+
+    bool     b_packetized;  /**< wether the data is packetized (ie. not truncated) */
+    int     i_extra;        /**< length in bytes of extra data pointer */
+    void    *p_extra;       /**< extra data needed by some decoders or muxers */
+
+};
+
+/** ES Categories */
+enum es_format_category_e
+{
+    UNKNOWN_ES = 0x00,
+    VIDEO_ES   = 0x01,
+    AUDIO_ES   = 0x02,
+    SPU_ES     = 0x03,
+    NAV_ES     = 0x04,
+};
+
+/**
+ * This function will fill all RGB shift from RGB masks.
+ */
+VLC_API void video_format_FixRgb( video_format_t * );
+
+/**
+ * This function will initialize a es_format_t structure.
+ */
+VLC_API void es_format_Init( es_format_t *, int i_cat, vlc_fourcc_t i_codec );
+
+/**
+ * This function will initialize a es_format_t structure from a video_format_t.
+ */
+VLC_API void es_format_InitFromVideo( es_format_t *, const video_format_t * );
+
+/**
+ * This functions will copy a es_format_t.
+ */
+VLC_API int es_format_Copy( es_format_t *p_dst, const es_format_t *p_src );
+
+/**
+ * This function will clean up a es_format_t and release all associated
+ * resources.
+ * You can call it multiple times on the same structure.
+ */
+VLC_API void es_format_Clean( es_format_t *fmt );
+
+/**
+ * This function will check if the first ES format is similar
+ * to the second one.
+ *
+ * All descriptive fields are ignored.
+ */
+VLC_API bool es_format_IsSimilar( const es_format_t *, const es_format_t * );
+
+#endif

=== added file 'DivCity/DivCity/vlc/plugins/vlc_es_out.h'
--- DivCity/DivCity/vlc/plugins/vlc_es_out.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_es_out.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,163 @@
+/*****************************************************************************
+ * vlc_es_out.h: es_out (demuxer output) descriptor, queries and methods
+ *****************************************************************************
+ * Copyright (C) 1999-2004 VLC authors and VideoLAN
+ * $Id: cf1abcec08467eb495ad62474e055c1500f358b6 $
+ *
+ * Authors: Laurent Aimar <fenrir@via.ecp.fr>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_ES_OUT_H
+#define VLC_ES_OUT_H 1
+
+/**
+ * \file
+ * This file defines functions and structures for handling es_out in stream output
+ */
+
+/**
+ * \defgroup es out Es Out
+ * @{
+ */
+
+enum es_out_query_e
+{
+    /* set ES selected for the es category (audio/video/spu) */
+    ES_OUT_SET_ES,      /* arg1= es_out_id_t*                   */
+    ES_OUT_RESTART_ES,  /* arg1= es_out_id_t*                   */
+
+    /* set 'default' tag on ES (copied across from container) */
+    ES_OUT_SET_ES_DEFAULT, /* arg1= es_out_id_t*                */
+
+    /* force selection/unselection of the ES (bypass current mode) */
+    ES_OUT_SET_ES_STATE,/* arg1= es_out_id_t* arg2=bool   */
+    ES_OUT_GET_ES_STATE,/* arg1= es_out_id_t* arg2=bool*  */
+
+    /* */
+    ES_OUT_SET_GROUP,   /* arg1= int                            */
+
+    /* PCR handling, DTS/PTS will be automatically computed using thoses PCR
+     * XXX: SET_PCR(_GROUP) are in charge of the pace control. They will wait
+     * to slow down the demuxer so that it reads at the right speed.
+     * XXX: if you want PREROLL just call ES_OUT_SET_NEXT_DISPLAY_TIME and send
+     * as you would normally do.
+     */
+    ES_OUT_SET_PCR,             /* arg1=int64_t i_pcr(microsecond!) (using default group 0)*/
+    ES_OUT_SET_GROUP_PCR,       /* arg1= int i_group, arg2=int64_t i_pcr(microsecond!)*/
+    ES_OUT_RESET_PCR,           /* no arg */
+
+    /* Try not to use this one as it is a bit hacky */
+    ES_OUT_SET_ES_FMT,         /* arg1= es_out_id_t* arg2=es_format_t* */
+
+    /* Allow preroll of data (data with dts/pts < i_pts for all ES will be decoded but not displayed */
+    ES_OUT_SET_NEXT_DISPLAY_TIME,       /* arg1=int64_t i_pts(microsecond) */
+    /* Set meta data for group (dynamic) (The vlc_meta_t is not modified nor released) */
+    ES_OUT_SET_GROUP_META,  /* arg1=int i_group arg2=const vlc_meta_t */
+    /* Set epg for group (dynamic) (The vlc_epg_t is not modified nor released) */
+    ES_OUT_SET_GROUP_EPG,   /* arg1=int i_group arg2=const vlc_epg_t */
+    /* */
+    ES_OUT_DEL_GROUP,       /* arg1=int i_group */
+
+    /* Set scrambled state for one es */
+    ES_OUT_SET_ES_SCRAMBLED_STATE,  /* arg1=int i_group arg2=es_out_id_t* */
+
+    /* Stop any buffering being done, and ask if es_out has no more data to
+     * play.
+     * It will not block and so MUST be used carrefully. The only good reason
+     * is for interactive playback (like for DVD menu).
+     * XXX You SHALL call ES_OUT_RESET_PCR before any other es_out_Control/Send calls. */
+    ES_OUT_GET_EMPTY,       /* arg1=bool*   res=cannot fail */
+
+    /* Set global meta data (The vlc_meta_t is not modified nor released) */
+    ES_OUT_SET_META, /* arg1=const vlc_meta_t * */
+
+    /* PCR system clock manipulation for external clock synchronization */
+    ES_OUT_GET_PCR_SYSTEM, /* arg1=mtime_t *, arg2=mtime_t * res=can fail */
+    ES_OUT_MODIFY_PCR_SYSTEM, /* arg1=int is_absolute, arg2=mtime_t, res=can fail */
+
+    /* First value usable for private control */
+    ES_OUT_PRIVATE_START = 0x10000,
+};
+
+struct es_out_t
+{
+    es_out_id_t *(*pf_add)    ( es_out_t *, const es_format_t * );
+    int          (*pf_send)   ( es_out_t *, es_out_id_t *, block_t * );
+    void         (*pf_del)    ( es_out_t *, es_out_id_t * );
+    int          (*pf_control)( es_out_t *, int i_query, va_list );
+    void         (*pf_destroy)( es_out_t * );
+
+    es_out_sys_t    *p_sys;
+};
+
+VLC_USED
+static inline es_out_id_t * es_out_Add( es_out_t *out, const es_format_t *fmt )
+{
+    return out->pf_add( out, fmt );
+}
+
+static inline void es_out_Del( es_out_t *out, es_out_id_t *id )
+{
+    out->pf_del( out, id );
+}
+
+static inline int es_out_Send( es_out_t *out, es_out_id_t *id,
+                               block_t *p_block )
+{
+    return out->pf_send( out, id, p_block );
+}
+
+static inline int es_out_vaControl( es_out_t *out, int i_query, va_list args )
+{
+    return out->pf_control( out, i_query, args );
+}
+
+static inline int es_out_Control( es_out_t *out, int i_query, ... )
+{
+    va_list args;
+    int     i_result;
+
+    va_start( args, i_query );
+    i_result = es_out_vaControl( out, i_query, args );
+    va_end( args );
+    return i_result;
+}
+
+static inline void es_out_Delete( es_out_t *p_out )
+{
+    p_out->pf_destroy( p_out );
+}
+
+static inline int es_out_ControlSetMeta( es_out_t *out, const vlc_meta_t *p_meta )
+{
+    return es_out_Control( out, ES_OUT_SET_META, p_meta );
+}
+
+static inline int es_out_ControlGetPcrSystem( es_out_t *out, mtime_t *pi_system, mtime_t *pi_delay )
+{
+    return es_out_Control( out, ES_OUT_GET_PCR_SYSTEM, pi_system, pi_delay );
+}
+static inline int es_out_ControlModifyPcrSystem( es_out_t *out, bool b_absolute, mtime_t i_system )
+{
+    return es_out_Control( out, ES_OUT_MODIFY_PCR_SYSTEM, b_absolute, i_system );
+}
+
+/**
+ * @}
+ */
+
+#endif

=== added file 'DivCity/DivCity/vlc/plugins/vlc_events.h'
--- DivCity/DivCity/vlc/plugins/vlc_events.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_events.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,252 @@
+/*****************************************************************************
+ * events.h: events definitions
+ * Interface used to send events.
+ *****************************************************************************
+ * Copyright (C) 2007 VLC authors and VideoLAN
+ * $Id: 842e204ef45aea390aa01d4488abdc89d79b0c08 $
+ *
+ * Authors: Pierre d'Herbemont
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_EVENTS_H
+# define VLC_EVENTS_H
+
+#include <vlc_arrays.h>
+#include <vlc_meta.h>
+
+/**
+ * \file
+ * This file is the interface definition for events
+ * (implementation in src/misc/events.c)
+ */
+
+/*****************************************************************************
+ * Documentation
+ *****************************************************************************/
+/*
+ **** Background
+ *
+ * This implements a way to send and receive event for an object (which can be
+ * a simple C struct or less).
+ *
+ * This is in direct concurrency with the Variable based Callback
+ * (see src/misc/variables.c).
+ *
+ * It has the following advantages over Variable based Callback:
+ * - No need to implement the whole VLC_COMMON_MEMBERS in the object,
+ * thus it reduce it size. This is especially true for input_item_t which
+ * doesn't have VLC_COMMON_MEMBERS. This is the first reason of existence of
+ * this implementation.
+ * - Libvlc can easily be based upon that.
+ * - Existing event are clearly declared (in include/vlc_events.h)
+ *
+ *
+ **** Example usage
+ *
+ * (vlc_cool_object_t doesn't need to have the VLC_COMMON_MEMBERS.)
+ *
+ * struct vlc_cool_object_t
+ * {
+ *        ...
+ *        vlc_event_manager_t p_event_manager;
+ *        ...
+ * }
+ *
+ * vlc_my_cool_object_new()
+ * {
+ *        ...
+ *        vlc_event_manager_init( &p_self->p_event_manager, p_self, p_a_libvlc_object );
+ *        vlc_event_manager_register_event_type(p_self->p_event_manager,
+ *                vlc_MyCoolObjectDidSomething, p_e)
+ *        ...
+ * }
+ *
+ * vlc_my_cool_object_release()
+ * {
+ *         ...
+ *         vlc_event_manager_fini( &p_self->p_event_manager );
+ *         ...
+ * }
+ *
+ * vlc_my_cool_object_do_something()
+ * {
+ *        ...
+ *        vlc_event_t event;
+ *        event.type = vlc_MyCoolObjectDidSomething;
+ *        event.u.my_cool_object_did_something.what_it_did = kSomething;
+ *        vlc_event_send( &p_self->p_event_manager, &event );
+ * }
+ * */
+
+  /*****************************************************************************
+ * Event Type
+ *****************************************************************************/
+
+/* Private structure defined in misc/events.c */
+struct vlc_event_listeners_group_t;
+
+/* Event manager type */
+typedef struct vlc_event_manager_t
+{
+    void * p_obj;
+    vlc_mutex_t object_lock;
+    vlc_mutex_t event_sending_lock;
+    DECL_ARRAY(struct vlc_event_listeners_group_t *) listeners_groups;
+} vlc_event_manager_t;
+
+/* List of event */
+typedef enum vlc_event_type_t {
+    /* Input (thread) events */
+    vlc_InputStateChanged,
+    vlc_InputSelectedStreamChanged,
+
+    /* Input item events */
+    vlc_InputItemMetaChanged,
+    vlc_InputItemSubItemAdded,
+    vlc_InputItemSubItemTreeAdded,
+    vlc_InputItemDurationChanged,
+    vlc_InputItemPreparsedChanged,
+    vlc_InputItemNameChanged,
+    vlc_InputItemInfoChanged,
+    vlc_InputItemErrorWhenReadingChanged,
+
+    /* Service Discovery event */
+    vlc_ServicesDiscoveryItemAdded,
+    vlc_ServicesDiscoveryItemRemoved,
+    vlc_ServicesDiscoveryStarted,
+    vlc_ServicesDiscoveryEnded
+} vlc_event_type_t;
+
+/* Event definition */
+typedef struct vlc_event_t
+{
+    vlc_event_type_t type;
+    void * p_obj; /* Sender object, automatically filled by vlc_event_send() */
+    union vlc_event_type_specific
+    {
+        /* Input (thread) events */
+        struct vlc_input_state_changed
+        {
+            int new_state;
+        } input_state_changed;
+        struct vlc_input_selected_stream_changed
+        {
+            void * unused;
+        } input_selected_stream_changed;
+
+        /* Input item events */
+        struct vlc_input_item_meta_changed
+        {
+            vlc_meta_type_t meta_type;
+        } input_item_meta_changed;
+        struct vlc_input_item_subitem_added
+        {
+            input_item_t * p_new_child;
+        } input_item_subitem_added;
+        struct vlc_input_item_subitem_tree_added
+        {
+            input_item_node_t * p_root;
+        } input_item_subitem_tree_added;
+        struct vlc_input_item_duration_changed
+        {
+            mtime_t new_duration;
+        } input_item_duration_changed;
+        struct vlc_input_item_preparsed_changed
+        {
+            int new_status;
+        } input_item_preparsed_changed;
+        struct vlc_input_item_name_changed
+        {
+            const char * new_name;
+        } input_item_name_changed;
+        struct vlc_input_item_info_changed
+        {
+            void * unused;
+        } input_item_info_changed;
+        struct input_item_error_when_reading_changed
+        {
+            bool new_value;
+        } input_item_error_when_reading_changed;
+
+        /* Service discovery events */
+        struct vlc_services_discovery_item_added
+        {
+            input_item_t * p_new_item;
+            const char * psz_category;
+        } services_discovery_item_added;
+        struct vlc_services_discovery_item_removed
+        {
+            input_item_t * p_item;
+        } services_discovery_item_removed;
+        struct vlc_services_discovery_started
+        {
+            void * unused;
+        } services_discovery_started;
+        struct vlc_services_discovery_ended
+        {
+            void * unused;
+        } services_discovery_ended;
+
+    } u;
+} vlc_event_t;
+
+/* Event callback type */
+typedef void ( *vlc_event_callback_t )( const vlc_event_t *, void * );
+
+ /*****************************************************************************
+ * Event manager
+ *****************************************************************************/
+
+/*
+ * p_obj points to the object that owns the event manager, and from
+ * which events are sent
+ */
+VLC_API int vlc_event_manager_init( vlc_event_manager_t * p_em, void * p_obj );
+
+/*
+ * Destroy
+ */
+VLC_API void vlc_event_manager_fini( vlc_event_manager_t * p_em );
+
+/*
+ * Tells a specific event manager that it will handle event_type object
+ */
+VLC_API int vlc_event_manager_register_event_type( vlc_event_manager_t * p_em,
+                                                   vlc_event_type_t );
+
+/*
+ * Send an event to the listener attached to this p_em.
+ */
+VLC_API void vlc_event_send( vlc_event_manager_t * p_em, vlc_event_t * );
+
+/*
+ * Add a callback for an event.
+ */
+VLC_API int vlc_event_attach( vlc_event_manager_t * p_event_manager,
+                              vlc_event_type_t event_type,
+                              vlc_event_callback_t pf_callback,
+                              void *p_user_data );
+
+/*
+ * Remove a callback for an event.
+ */
+VLC_API void vlc_event_detach( vlc_event_manager_t *p_event_manager,
+                               vlc_event_type_t event_type,
+                               vlc_event_callback_t pf_callback,
+                               void *p_user_data );
+
+#endif /* VLC_EVENTS_H */

=== added file 'DivCity/DivCity/vlc/plugins/vlc_filter.h'
--- DivCity/DivCity/vlc/plugins/vlc_filter.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_filter.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,421 @@
+/*****************************************************************************
+ * vlc_filter.h: filter related structures and functions
+ *****************************************************************************
+ * Copyright (C) 1999-2008 VLC authors and VideoLAN
+ * $Id: b57b7eff75390d03e7ec0e1a1a510d701e8df5ef $
+ *
+ * Authors: Gildas Bazin <gbazin@videolan.org>
+ *          Antoine Cellerier <dionoea at videolan dot org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_FILTER_H
+#define VLC_FILTER_H 1
+
+#include <vlc_es.h>
+#include <vlc_picture.h>
+#include <vlc_subpicture.h>
+#include <vlc_mouse.h>
+
+/**
+ * \file
+ * This file defines the structure and types used by video and audio filters
+ */
+
+typedef struct filter_owner_sys_t filter_owner_sys_t;
+
+/** Structure describing a filter
+ * @warning BIG FAT WARNING : the code relies on the first 4 members of
+ * filter_t and decoder_t to be the same, so if you have anything to add,
+ * do it at the end of the structure.
+ */
+struct filter_t
+{
+    VLC_COMMON_MEMBERS
+
+    /* Module properties */
+    module_t *          p_module;
+    filter_sys_t *      p_sys;
+
+    /* Input format */
+    es_format_t         fmt_in;
+
+    /* Output format of filter */
+    es_format_t         fmt_out;
+    bool                b_allow_fmt_out_change;
+
+    /* Filter configuration */
+    config_chain_t *    p_cfg;
+
+    union
+    {
+        struct
+        {
+            picture_t * (*pf_filter) ( filter_t *, picture_t * );
+            void        (*pf_flush)( filter_t * );
+            picture_t * (*pf_buffer_new) ( filter_t * );
+            void        (*pf_buffer_del) ( filter_t *, picture_t * );
+            /* Filter mouse state.
+             *
+             * If non-NULL, you must convert from output to input formats:
+             * - If VLC_SUCCESS is returned, the mouse state is propagated.
+             * - Otherwise, the mouse change is not propagated.
+             * If NULL, the mouse state is considered unchanged and will be
+             * propagated.
+             */
+            int         (*pf_mouse)( filter_t *, vlc_mouse_t *,
+                                     const vlc_mouse_t *p_old,
+                                     const vlc_mouse_t *p_new );
+        } video;
+#define pf_video_filter     u.video.pf_filter
+#define pf_video_flush      u.video.pf_flush
+#define pf_video_mouse      u.video.pf_mouse
+#define pf_video_buffer_new u.video.pf_buffer_new
+#define pf_video_buffer_del u.video.pf_buffer_del
+
+        struct
+        {
+            block_t *   (*pf_filter) ( filter_t *, block_t * );
+        } audio;
+#define pf_audio_filter     u.audio.pf_filter
+
+        struct
+        {
+            void        (*pf_blend) ( filter_t *,  picture_t *,
+                                      const picture_t *, int, int, int );
+        } blend;
+#define pf_video_blend     u.blend.pf_blend
+
+        struct
+        {
+            subpicture_t * (*pf_source)    ( filter_t *, mtime_t );
+            subpicture_t * (*pf_buffer_new)( filter_t * );
+            void           (*pf_buffer_del)( filter_t *, subpicture_t * );
+            int            (*pf_mouse)     ( filter_t *,
+                                             const vlc_mouse_t *p_old,
+                                             const vlc_mouse_t *p_new,
+                                             const video_format_t * );
+        } sub;
+#define pf_sub_source      u.sub.pf_source
+#define pf_sub_buffer_new  u.sub.pf_buffer_new
+#define pf_sub_buffer_del  u.sub.pf_buffer_del
+#define pf_sub_mouse       u.sub.pf_mouse
+
+        struct
+        {
+            subpicture_t * (*pf_filter) ( filter_t *, subpicture_t * );
+        } subf;
+#define pf_sub_filter      u.subf.pf_filter
+
+        struct
+        {
+            int         (*pf_text) ( filter_t *, subpicture_region_t *,
+                                     subpicture_region_t *,
+                                     const vlc_fourcc_t * );
+            int         (*pf_html) ( filter_t *, subpicture_region_t *,
+                                     subpicture_region_t *,
+                                     const vlc_fourcc_t * );
+        } render;
+#define pf_render_text     u.render.pf_text
+#define pf_render_html     u.render.pf_html
+
+    } u;
+
+    /* Input attachments
+     * XXX use filter_GetInputAttachments */
+    int (*pf_get_attachments)( filter_t *, input_attachment_t ***, int * );
+
+    /* Private structure for the owner of the decoder */
+    filter_owner_sys_t *p_owner;
+};
+
+/**
+ * This function will return a new picture usable by p_filter as an output
+ * buffer. You have to release it using filter_DeletePicture or by returning
+ * it to the caller as a pf_video_filter return value.
+ * Provided for convenience.
+ *
+ * \param p_filter filter_t object
+ * \return new picture on success or NULL on failure
+ */
+static inline picture_t *filter_NewPicture( filter_t *p_filter )
+{
+    picture_t *p_picture = p_filter->pf_video_buffer_new( p_filter );
+    if( !p_picture )
+        msg_Warn( p_filter, "can't get output picture" );
+    return p_picture;
+}
+
+/**
+ * This function will release a picture create by filter_NewPicture.
+ * Provided for convenience.
+ *
+ * \param p_filter filter_t object
+ * \param p_picture picture to be deleted
+ */
+static inline void filter_DeletePicture( filter_t *p_filter, picture_t *p_picture )
+{
+    p_filter->pf_video_buffer_del( p_filter, p_picture );
+}
+
+/**
+ * This function will flush the state of a video filter.
+ */
+static inline void filter_FlushPictures( filter_t *p_filter )
+{
+    if( p_filter->pf_video_flush )
+        p_filter->pf_video_flush( p_filter );
+}
+
+/**
+ * This function will return a new subpicture usable by p_filter as an output
+ * buffer. You have to release it using filter_DeleteSubpicture or by returning
+ * it to the caller as a pf_sub_source return value.
+ * Provided for convenience.
+ *
+ * \param p_filter filter_t object
+ * \return new subpicture
+ */
+static inline subpicture_t *filter_NewSubpicture( filter_t *p_filter )
+{
+    subpicture_t *p_subpicture = p_filter->pf_sub_buffer_new( p_filter );
+    if( !p_subpicture )
+        msg_Warn( p_filter, "can't get output subpicture" );
+    return p_subpicture;
+}
+
+/**
+ * This function will release a subpicture create by filter_NewSubicture.
+ * Provided for convenience.
+ *
+ * \param p_filter filter_t object
+ * \param p_subpicture to be released
+ */
+static inline void filter_DeleteSubpicture( filter_t *p_filter, subpicture_t *p_subpicture )
+{
+    p_filter->pf_sub_buffer_del( p_filter, p_subpicture );
+}
+
+#define filter_NewAudioBuffer block_New
+
+/**
+ * This function gives all input attachments at once.
+ *
+ * You MUST release the returned values
+ */
+static inline int filter_GetInputAttachments( filter_t *p_filter,
+                                              input_attachment_t ***ppp_attachment,
+                                              int *pi_attachment )
+{
+    if( !p_filter->pf_get_attachments )
+        return VLC_EGENERIC;
+    return p_filter->pf_get_attachments( p_filter,
+                                         ppp_attachment, pi_attachment );
+}
+
+/**
+ * It creates a blend filter.
+ *
+ * Only the chroma properties of the dest format is used (chroma
+ * type, rgb masks and shifts)
+ */
+VLC_API filter_t * filter_NewBlend( vlc_object_t *, const video_format_t *p_dst_chroma ) VLC_USED;
+
+/**
+ * It configures blend filter parameters that are allowed to changed
+ * after the creation.
+ */
+VLC_API int filter_ConfigureBlend( filter_t *, int i_dst_width, int i_dst_height, const video_format_t *p_src );
+
+/**
+ * It blends a picture into another one.
+ *
+ * The input picture is not modified and not released.
+ */
+VLC_API int filter_Blend( filter_t *, picture_t *p_dst, int i_dst_x, int i_dst_y, const picture_t *p_src, int i_alpha );
+
+/**
+ * It destroys a blend filter created by filter_NewBlend.
+ */
+VLC_API void filter_DeleteBlend( filter_t * );
+
+/**
+ * Create a picture_t *(*)( filter_t *, picture_t * ) compatible wrapper
+ * using a void (*)( filter_t *, picture_t *, picture_t * ) function
+ *
+ * Currently used by the chroma video filters
+ */
+#define VIDEO_FILTER_WRAPPER( name )                                    \
+    static picture_t *name ## _Filter ( filter_t *p_filter,             \
+                                        picture_t *p_pic )              \
+    {                                                                   \
+        picture_t *p_outpic = filter_NewPicture( p_filter );            \
+        if( p_outpic )                                                  \
+        {                                                               \
+            name( p_filter, p_pic, p_outpic );                          \
+            picture_CopyProperties( p_outpic, p_pic );                  \
+        }                                                               \
+        picture_Release( p_pic );                                       \
+        return p_outpic;                                                \
+    }
+
+/**
+ * Filter chain management API
+ * The filter chain management API is used to dynamically construct filters
+ * and add them in a chain.
+ */
+
+typedef struct filter_chain_t filter_chain_t;
+
+/**
+ * Create new filter chain
+ *
+ * \param p_object pointer to a vlc object
+ * \param psz_capability vlc capability of filters in filter chain
+ * \param b_allow_format_fmt_change allow changing of fmt
+ * \param pf_buffer_allocation_init callback function to initialize buffer allocations
+ * \param pf_buffer_allocation_clear callback function to clear buffer allocation initialization
+ * \param p_buffer_allocation_data pointer to private allocation data
+ * \return pointer to a filter chain
+ */
+VLC_API filter_chain_t * filter_chain_New( vlc_object_t *, const char *, bool, int (*)( filter_t *, void * ), void (*)( filter_t * ), void *  ) VLC_USED;
+#define filter_chain_New( a, b, c, d, e, f ) filter_chain_New( VLC_OBJECT( a ), b, c, d, e, f )
+
+/**
+ * Delete filter chain will delete all filters in the chain and free all
+ * allocated data. The pointer to the filter chain is then no longer valid.
+ *
+ * \param p_chain pointer to filter chain
+ */
+VLC_API void filter_chain_Delete( filter_chain_t * );
+
+/**
+ * Reset filter chain will delete all filters in the chain and
+ * reset p_fmt_in and p_fmt_out to the new values.
+ *
+ * \param p_chain pointer to filter chain
+ * \param p_fmt_in new fmt_in params
+ * \param p_fmt_out new fmt_out params
+ */
+VLC_API void filter_chain_Reset( filter_chain_t *, const es_format_t *, const es_format_t * );
+
+/**
+ * Append filter to the end of the chain.
+ *
+ * \param p_chain pointer to filter chain
+ * \param psz_name name of filter
+ * \param p_cfg
+ * \param p_fmt_in input es_format_t
+ * \param p_fmt_out output es_format_t
+ * \return pointer to filter chain
+ */
+VLC_API filter_t * filter_chain_AppendFilter( filter_chain_t *, const char *, config_chain_t *, const es_format_t *, const es_format_t * );
+
+/**
+ * Append new filter to filter chain from string.
+ *
+ * \param p_chain pointer to filter chain
+ * \param psz_string string of filters
+ * \return 0 for success
+ */
+VLC_API int filter_chain_AppendFromString( filter_chain_t *, const char * );
+
+/**
+ * Delete filter from filter chain. This function also releases the filter
+ * object and unloads the filter modules. The pointer to p_filter is no
+ * longer valid after this function successfully returns.
+ *
+ * \param p_chain pointer to filter chain
+ * \param p_filter pointer to filter object
+ * \return VLC_SUCCESS on succes, else VLC_EGENERIC
+ */
+VLC_API int filter_chain_DeleteFilter( filter_chain_t *, filter_t * );
+
+/**
+ * Get the number of filters in the filter chain.
+ *
+ * \param p_chain pointer to filter chain
+ * \return number of filters in this filter chain
+ */
+VLC_API int filter_chain_GetLength( filter_chain_t * );
+
+/**
+ * Get last p_fmt_out in the chain.
+ *
+ * \param p_chain pointer to filter chain
+ * \return last p_fmt (es_format_t) of this filter chain
+ */
+VLC_API const es_format_t * filter_chain_GetFmtOut( filter_chain_t * );
+
+/**
+ * Apply the filter chain to a video picture.
+ *
+ * \param p_chain pointer to filter chain
+ * \param p_picture picture to apply filters on
+ * \return modified picture after applying all video filters
+ */
+VLC_API picture_t * filter_chain_VideoFilter( filter_chain_t *, picture_t * );
+
+/**
+ * Flush a video filter chain.
+ */
+VLC_API void filter_chain_VideoFlush( filter_chain_t * );
+
+/**
+ * Apply the filter chain to a audio block.
+ *
+ * \param p_chain pointer to filter chain
+ * \param p_block audio frame to apply filters on
+ * \return modified audio frame after applying all audio filters
+ */
+VLC_API block_t * filter_chain_AudioFilter( filter_chain_t *, block_t * );
+
+/**
+ * Apply filter chain to subpictures.
+ *
+ * \param p_chain pointer to filter chain
+ * \param display_date of subpictures
+ */
+VLC_API void filter_chain_SubSource( filter_chain_t *, mtime_t );
+
+/**
+ * Apply filter chain to subpictures.
+ *
+ * \param p_chain pointer to filter chain
+ * \param p_subpicture subpicture to apply filters on
+ * \return modified subpicture after applying all subpicture filters
+ */
+VLC_API subpicture_t * filter_chain_SubFilter( filter_chain_t *, subpicture_t * );
+
+/**
+ * Apply the filter chain to a mouse state.
+ *
+ * It will be applied from the output to the input. It makes sense only
+ * for a video filter chain.
+ *
+ * The vlc_mouse_t* pointers may be the same.
+ */
+VLC_API int filter_chain_MouseFilter( filter_chain_t *, vlc_mouse_t *, const vlc_mouse_t * );
+
+/**
+ * Inform the filter chain of mouse state.
+ *
+ * It makes sense only for a sub source chain.
+ */
+VLC_API int filter_chain_MouseEvent( filter_chain_t *, const vlc_mouse_t *, const video_format_t * );
+
+#endif /* _VLC_FILTER_H */
+

=== added file 'DivCity/DivCity/vlc/plugins/vlc_fourcc.h'
--- DivCity/DivCity/vlc/plugins/vlc_fourcc.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_fourcc.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,474 @@
+/*****************************************************************************
+ * vlc_fourcc.h: Definition of various FOURCC and helpers
+ *****************************************************************************
+ * Copyright (C) 2009 Laurent Aimar
+ * $Id: 0d09519fa6b4693e908e551ca653e3b3c3da1bcc $
+ *
+ * Authors: Laurent Aimar <fenrir _AT_ videolan _DOT_ com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_FOURCC_H
+#define VLC_FOURCC_H 1
+
+#include <vlc_common.h>
+
+/* Video codec */
+#define VLC_CODEC_MPGV      VLC_FOURCC('m','p','g','v')
+#define VLC_CODEC_MP4V      VLC_FOURCC('m','p','4','v')
+#define VLC_CODEC_DIV1      VLC_FOURCC('D','I','V','1')
+#define VLC_CODEC_DIV2      VLC_FOURCC('D','I','V','2')
+#define VLC_CODEC_DIV3      VLC_FOURCC('D','I','V','3')
+#define VLC_CODEC_SVQ1      VLC_FOURCC('S','V','Q','1')
+#define VLC_CODEC_SVQ3      VLC_FOURCC('S','V','Q','3')
+#define VLC_CODEC_H264      VLC_FOURCC('h','2','6','4')
+#define VLC_CODEC_H263      VLC_FOURCC('h','2','6','3')
+#define VLC_CODEC_H263I     VLC_FOURCC('I','2','6','3')
+#define VLC_CODEC_H263P     VLC_FOURCC('I','L','V','R')
+#define VLC_CODEC_FLV1      VLC_FOURCC('F','L','V','1')
+#define VLC_CODEC_H261      VLC_FOURCC('h','2','6','1')
+#define VLC_CODEC_MJPG      VLC_FOURCC('M','J','P','G')
+#define VLC_CODEC_MJPGB     VLC_FOURCC('m','j','p','b')
+#define VLC_CODEC_LJPG      VLC_FOURCC('L','J','P','G')
+#define VLC_CODEC_WMV1      VLC_FOURCC('W','M','V','1')
+#define VLC_CODEC_WMV2      VLC_FOURCC('W','M','V','2')
+#define VLC_CODEC_WMV3      VLC_FOURCC('W','M','V','3')
+#define VLC_CODEC_WMVA      VLC_FOURCC('W','M','V','A')
+#define VLC_CODEC_WMVP      VLC_FOURCC('W','M','V','P')
+#define VLC_CODEC_WMVP2     VLC_FOURCC('W','V','P','2')
+#define VLC_CODEC_VC1       VLC_FOURCC('V','C','-','1')
+#define VLC_CODEC_THEORA    VLC_FOURCC('t','h','e','o')
+#define VLC_CODEC_TARKIN    VLC_FOURCC('t','a','r','k')
+#define VLC_CODEC_SNOW      VLC_FOURCC('S','N','O','W')
+#define VLC_CODEC_DIRAC     VLC_FOURCC('d','r','a','c')
+#define VLC_CODEC_CAVS      VLC_FOURCC('C','A','V','S')
+#define VLC_CODEC_NUV       VLC_FOURCC('N','J','P','G')
+#define VLC_CODEC_RV10      VLC_FOURCC('R','V','1','0')
+#define VLC_CODEC_RV13      VLC_FOURCC('R','V','1','3')
+#define VLC_CODEC_RV20      VLC_FOURCC('R','V','2','0')
+#define VLC_CODEC_RV30      VLC_FOURCC('R','V','3','0')
+#define VLC_CODEC_RV40      VLC_FOURCC('R','V','4','0')
+#define VLC_CODEC_VP3       VLC_FOURCC('V','P','3',' ')
+#define VLC_CODEC_VP5       VLC_FOURCC('V','P','5',' ')
+#define VLC_CODEC_VP6       VLC_FOURCC('V','P','6','2')
+#define VLC_CODEC_VP6F      VLC_FOURCC('V','P','6','F')
+#define VLC_CODEC_VP6A      VLC_FOURCC('V','P','6','A')
+#define VLC_CODEC_MSVIDEO1  VLC_FOURCC('M','S','V','C')
+#define VLC_CODEC_FLIC      VLC_FOURCC('F','L','I','C')
+#define VLC_CODEC_SP5X      VLC_FOURCC('S','P','5','X')
+#define VLC_CODEC_DV        VLC_FOURCC('d','v',' ',' ')
+#define VLC_CODEC_MSRLE     VLC_FOURCC('m','r','l','e')
+#define VLC_CODEC_INDEO3    VLC_FOURCC('I','V','3','1')
+#define VLC_CODEC_HUFFYUV   VLC_FOURCC('H','F','Y','U')
+#define VLC_CODEC_FFVHUFF   VLC_FOURCC('F','F','V','H')
+#define VLC_CODEC_ASV1      VLC_FOURCC('A','S','V','1')
+#define VLC_CODEC_ASV2      VLC_FOURCC('A','S','V','2')
+#define VLC_CODEC_FFV1      VLC_FOURCC('F','F','V','1')
+#define VLC_CODEC_VCR1      VLC_FOURCC('V','C','R','1')
+#define VLC_CODEC_CLJR      VLC_FOURCC('C','L','J','R')
+#define VLC_CODEC_RPZA      VLC_FOURCC('r','p','z','a')
+#define VLC_CODEC_SMC       VLC_FOURCC('s','m','c',' ')
+#define VLC_CODEC_CINEPAK   VLC_FOURCC('C','V','I','D')
+#define VLC_CODEC_TSCC      VLC_FOURCC('T','S','C','C')
+#define VLC_CODEC_CSCD      VLC_FOURCC('C','S','C','D')
+#define VLC_CODEC_ZMBV      VLC_FOURCC('Z','M','B','V')
+#define VLC_CODEC_VMNC      VLC_FOURCC('V','M','n','c')
+#define VLC_CODEC_FRAPS     VLC_FOURCC('F','P','S','1')
+#define VLC_CODEC_TRUEMOTION1 VLC_FOURCC('D','U','C','K')
+#define VLC_CODEC_TRUEMOTION2 VLC_FOURCC('T','M','2','0')
+#define VLC_CODEC_QTRLE     VLC_FOURCC('r','l','e',' ')
+#define VLC_CODEC_QDRAW     VLC_FOURCC('q','d','r','w')
+#define VLC_CODEC_QPEG      VLC_FOURCC('Q','P','E','G')
+#define VLC_CODEC_ULTI      VLC_FOURCC('U','L','T','I')
+#define VLC_CODEC_VIXL      VLC_FOURCC('V','I','X','L')
+#define VLC_CODEC_LOCO      VLC_FOURCC('L','O','C','O')
+#define VLC_CODEC_WNV1      VLC_FOURCC('W','N','V','1')
+#define VLC_CODEC_AASC      VLC_FOURCC('A','A','S','C')
+#define VLC_CODEC_INDEO2    VLC_FOURCC('I','V','2','0')
+#define VLC_CODEC_FLASHSV   VLC_FOURCC('F','S','V','1')
+#define VLC_CODEC_KMVC      VLC_FOURCC('K','M','V','C')
+#define VLC_CODEC_SMACKVIDEO VLC_FOURCC('S','M','K','2')
+#define VLC_CODEC_DNXHD     VLC_FOURCC('A','V','d','n')
+#define VLC_CODEC_8BPS      VLC_FOURCC('8','B','P','S')
+#define VLC_CODEC_MIMIC     VLC_FOURCC('M','L','2','O')
+#define VLC_CODEC_INTERPLAY VLC_FOURCC('i','m','v','e')
+#define VLC_CODEC_IDCIN     VLC_FOURCC('I','D','C','I')
+#define VLC_CODEC_4XM       VLC_FOURCC('4','X','M','V')
+#define VLC_CODEC_ROQ       VLC_FOURCC('R','o','Q','v')
+#define VLC_CODEC_MDEC      VLC_FOURCC('M','D','E','C')
+#define VLC_CODEC_VMDVIDEO  VLC_FOURCC('V','M','D','V')
+#define VLC_CODEC_CDG       VLC_FOURCC('C','D','G',' ')
+#define VLC_CODEC_FRWU      VLC_FOURCC('F','R','W','U')
+#define VLC_CODEC_AMV       VLC_FOURCC('A','M','V',' ')
+#define VLC_CODEC_INDEO5    VLC_FOURCC('I','V','5','0')
+#define VLC_CODEC_VP8       VLC_FOURCC('V','P','8','0')
+#define VLC_CODEC_JPEG2000  VLC_FOURCC('J','P','2','K')
+#define VLC_CODEC_LAGARITH  VLC_FOURCC('L','A','G','S')
+#define VLC_CODEC_FLASHSV2  VLC_FOURCC('F','S','V','2')
+#define VLC_CODEC_PRORES    VLC_FOURCC('a','p','c','n')
+#define VLC_CODEC_MXPEG     VLC_FOURCC('M','X','P','G')
+
+/* Planar YUV 4:1:0 Y:V:U */
+#define VLC_CODEC_YV9       VLC_FOURCC('Y','V','U','9')
+/* Planar YUV 4:2:0 Y:V:U */
+#define VLC_CODEC_YV12      VLC_FOURCC('Y','V','1','2')
+/* Planar YUV 4:1:0 Y:U:V */
+#define VLC_CODEC_I410      VLC_FOURCC('I','4','1','0')
+/* Planar YUV 4:1:1 Y:U:V */
+#define VLC_CODEC_I411      VLC_FOURCC('I','4','1','1')
+/* Planar YUV 4:2:0 Y:U:V 8-bit */
+#define VLC_CODEC_I420      VLC_FOURCC('I','4','2','0')
+/* Planar YUV 4:2:0 Y:U:V  9-bit stored on 16 bits */
+#define VLC_CODEC_I420_9L   VLC_FOURCC('I','0','9','L')
+#define VLC_CODEC_I420_9B   VLC_FOURCC('I','0','9','B')
+/* Planar YUV 4:2:0 Y:U:V 10-bit stored on 16 bits */
+#define VLC_CODEC_I420_10L  VLC_FOURCC('I','0','A','L')
+#define VLC_CODEC_I420_10B  VLC_FOURCC('I','0','A','B')
+/* Planar YUV 4:2:2 Y:U:V 8-bit */
+#define VLC_CODEC_I422      VLC_FOURCC('I','4','2','2')
+/* Planar YUV 4:2:2 Y:U:V  9-bit stored on 16 bits */
+#define VLC_CODEC_I422_9L   VLC_FOURCC('I','2','9','L')
+#define VLC_CODEC_I422_9B   VLC_FOURCC('I','2','9','B')
+/* Planar YUV 4:2:2 Y:U:V 10-bit stored on 16 bits */
+#define VLC_CODEC_I422_10L  VLC_FOURCC('I','2','A','L')
+#define VLC_CODEC_I422_10B  VLC_FOURCC('I','2','A','B')
+/* Planar YUV 4:4:0 Y:U:V */
+#define VLC_CODEC_I440      VLC_FOURCC('I','4','4','0')
+/* Planar YUV 4:4:4 Y:U:V 8-bit */
+#define VLC_CODEC_I444      VLC_FOURCC('I','4','4','4')
+/* Planar YUV 4:4:4 Y:U:V  9-bit stored on 16 bits */
+#define VLC_CODEC_I444_9L   VLC_FOURCC('I','4','9','L')
+#define VLC_CODEC_I444_9B   VLC_FOURCC('I','4','9','B')
+/* Planar YUV 4:4:4 Y:U:V 10-bit stored on 16 bits */
+#define VLC_CODEC_I444_10L  VLC_FOURCC('I','4','A','L')
+#define VLC_CODEC_I444_10B  VLC_FOURCC('I','4','A','B')
+/* Planar YUV 4:2:0 Y:U:V full scale */
+#define VLC_CODEC_J420      VLC_FOURCC('J','4','2','0')
+/* Planar YUV 4:2:2 Y:U:V full scale */
+#define VLC_CODEC_J422      VLC_FOURCC('J','4','2','2')
+/* Planar YUV 4:4:0 Y:U:V full scale */
+#define VLC_CODEC_J440      VLC_FOURCC('J','4','4','0')
+/* Planar YUV 4:4:4 Y:U:V full scale */
+#define VLC_CODEC_J444      VLC_FOURCC('J','4','4','4')
+/* Palettized YUV with palette element Y:U:V:A */
+#define VLC_CODEC_YUVP      VLC_FOURCC('Y','U','V','P')
+/* Planar YUV 4:4:4 Y:U:V:A */
+#define VLC_CODEC_YUVA      VLC_FOURCC('Y','U','V','A')
+/* Palettized RGB with palette element R:G:B */
+#define VLC_CODEC_RGBP      VLC_FOURCC('R','G','B','P')
+/* 8 bits RGB */
+#define VLC_CODEC_RGB8      VLC_FOURCC('R','G','B','8')
+/* 12 bits RGB padded to 16 bits */
+#define VLC_CODEC_RGB12     VLC_FOURCC('R','V','1','2')
+/* 16 bits RGBA (12 bits RGB + 4 bits alpha) */
+#define VLC_CODEC_RGBA16    VLC_FOURCC('A','V','1','6')
+/* 15 bits RGB padded to 16 bits */
+#define VLC_CODEC_RGB15     VLC_FOURCC('R','V','1','5')
+/* 16 bits RGBA (15 bits RGB + 1 bit alpha)  */
+#define VLC_CODEC_RGBT      VLC_FOURCC('R','G','B','T')
+/* 16 bits RGB */
+#define VLC_CODEC_RGB16     VLC_FOURCC('R','V','1','6')
+/* 24 bits RGB */
+#define VLC_CODEC_RGB24     VLC_FOURCC('R','V','2','4')
+/* 24 bits RGB padded to 32 bits */
+#define VLC_CODEC_RGB32     VLC_FOURCC('R','V','3','2')
+/* 32 bits RGBA */
+#define VLC_CODEC_RGBA      VLC_FOURCC('R','G','B','A')
+/* 8 bits grey */
+#define VLC_CODEC_GREY      VLC_FOURCC('G','R','E','Y')
+/* Packed YUV 4:2:2, U:Y:V:Y */
+#define VLC_CODEC_UYVY      VLC_FOURCC('U','Y','V','Y')
+/* Packed YUV 4:2:2, V:Y:U:Y */
+#define VLC_CODEC_VYUY      VLC_FOURCC('V','Y','U','Y')
+/* Packed YUV 4:2:2, Y:U:Y:V */
+#define VLC_CODEC_YUYV      VLC_FOURCC('Y','U','Y','2')
+/* Packed YUV 4:2:2, Y:V:Y:U */
+#define VLC_CODEC_YVYU      VLC_FOURCC('Y','V','Y','U')
+/* Packed YUV 2:1:1, Y:U:Y:V */
+#define VLC_CODEC_Y211      VLC_FOURCC('Y','2','1','1')
+/* Packed YUV 4:2:2, U:Y:V:Y, reverted */
+#define VLC_CODEC_CYUV      VLC_FOURCC('c','y','u','v')
+/* 10-bit 4:2:2 Component YCbCr */
+#define VLC_CODEC_V210      VLC_FOURCC('v','2','1','0')
+/* 2 planes Y/UV 4:2:0 */
+#define VLC_CODEC_NV12      VLC_FOURCC('N','V','1','2')
+/* 2 planes Y/VU 4:2:0 */
+#define VLC_CODEC_NV21      VLC_FOURCC('N','V','2','1')
+/* 2 planes Y/UV 4:2:2 */
+#define VLC_CODEC_NV16      VLC_FOURCC('N','V','1','6')
+/* 2 planes Y/VU 4:2:2 */
+#define VLC_CODEC_NV61      VLC_FOURCC('N','V','6','1')
+
+/* Image codec (video) */
+#define VLC_CODEC_PNG       VLC_FOURCC('p','n','g',' ')
+#define VLC_CODEC_PPM       VLC_FOURCC('p','p','m',' ')
+#define VLC_CODEC_PGM       VLC_FOURCC('p','g','m',' ')
+#define VLC_CODEC_PGMYUV    VLC_FOURCC('p','g','m','y')
+#define VLC_CODEC_PAM       VLC_FOURCC('p','a','m',' ')
+#define VLC_CODEC_JPEG      VLC_FOURCC('j','p','e','g')
+#define VLC_CODEC_JPEGLS    VLC_FOURCC('M','J','L','S')
+#define VLC_CODEC_BMP       VLC_FOURCC('b','m','p',' ')
+#define VLC_CODEC_TIFF      VLC_FOURCC('t','i','f','f')
+#define VLC_CODEC_GIF       VLC_FOURCC('g','i','f',' ')
+#define VLC_CODEC_TARGA     VLC_FOURCC('t','g','a',' ')
+#define VLC_CODEC_SGI       VLC_FOURCC('s','g','i',' ')
+#define VLC_CODEC_PNM       VLC_FOURCC('p','n','m',' ')
+#define VLC_CODEC_PCX       VLC_FOURCC('p','c','x',' ')
+
+
+/* Audio codec */
+#define VLC_CODEC_MPGA      VLC_FOURCC('m','p','g','a')
+#define VLC_CODEC_MP4A      VLC_FOURCC('m','p','4','a')
+#define VLC_CODEC_ALS       VLC_FOURCC('a','l','s',' ')
+#define VLC_CODEC_A52       VLC_FOURCC('a','5','2',' ')
+#define VLC_CODEC_EAC3      VLC_FOURCC('e','a','c','3')
+#define VLC_CODEC_DTS       VLC_FOURCC('d','t','s',' ')
+#define VLC_CODEC_WMA1      VLC_FOURCC('W','M','A','1')
+#define VLC_CODEC_WMA2      VLC_FOURCC('W','M','A','2')
+#define VLC_CODEC_WMAP      VLC_FOURCC('W','M','A','P')
+#define VLC_CODEC_WMAL      VLC_FOURCC('W','M','A','L')
+#define VLC_CODEC_WMAS      VLC_FOURCC('W','M','A','S')
+#define VLC_CODEC_FLAC      VLC_FOURCC('f','l','a','c')
+#define VLC_CODEC_MLP       VLC_FOURCC('m','l','p',' ')
+#define VLC_CODEC_TRUEHD    VLC_FOURCC('t','r','h','d')
+#define VLC_CODEC_DVAUDIO   VLC_FOURCC('d','v','a','u')
+#define VLC_CODEC_SPEEX     VLC_FOURCC('s','p','x',' ')
+#define VLC_CODEC_OPUS      VLC_FOURCC('O','p','u','s')
+#define VLC_CODEC_VORBIS    VLC_FOURCC('v','o','r','b')
+#define VLC_CODEC_MACE3     VLC_FOURCC('M','A','C','3')
+#define VLC_CODEC_MACE6     VLC_FOURCC('M','A','C','6')
+#define VLC_CODEC_MUSEPACK7 VLC_FOURCC('M','P','C',' ')
+#define VLC_CODEC_MUSEPACK8 VLC_FOURCC('M','P','C','K')
+#define VLC_CODEC_RA_144    VLC_FOURCC('1','4','_','4')
+#define VLC_CODEC_RA_288    VLC_FOURCC('2','8','_','8')
+#define VLC_CODEC_ADPCM_4XM VLC_FOURCC('4','x','m','a')
+#define VLC_CODEC_ADPCM_EA  VLC_FOURCC('A','D','E','A')
+#define VLC_CODEC_INTERPLAY_DPCM VLC_FOURCC('i','d','p','c')
+#define VLC_CODEC_ROQ_DPCM  VLC_FOURCC('R','o','Q','a')
+#define VLC_CODEC_DSICINAUDIO VLC_FOURCC('D','C','I','A')
+#define VLC_CODEC_ADPCM_XA  VLC_FOURCC('x','a',' ',' ')
+#define VLC_CODEC_ADPCM_ADX VLC_FOURCC('a','d','x',' ')
+#define VLC_CODEC_ADPCM_IMA_WS VLC_FOURCC('A','I','W','S')
+#define VLC_CODEC_ADPCM_G722 VLC_FOURCC('g','7','2','2')
+#define VLC_CODEC_ADPCM_G726 VLC_FOURCC('g','7','2','6')
+#define VLC_CODEC_ADPCM_SWF VLC_FOURCC('S','W','F','a')
+#define VLC_CODEC_ADPCM_MS  VLC_FOURCC('m','s',0x00,0x02)
+#define VLC_CODEC_ADPCM_IMA_WAV VLC_FOURCC('m','s',0x00,0x11)
+#define VLC_CODEC_VMDAUDIO  VLC_FOURCC('v','m','d','a')
+#define VLC_CODEC_AMR_NB    VLC_FOURCC('s','a','m','r')
+#define VLC_CODEC_AMR_WB    VLC_FOURCC('s','a','w','b')
+#define VLC_CODEC_ALAC      VLC_FOURCC('a','l','a','c')
+#define VLC_CODEC_QDM2      VLC_FOURCC('Q','D','M','2')
+#define VLC_CODEC_COOK      VLC_FOURCC('c','o','o','k')
+#define VLC_CODEC_SIPR      VLC_FOURCC('s','i','p','r')
+#define VLC_CODEC_TTA       VLC_FOURCC('T','T','A','1')
+#define VLC_CODEC_SHORTEN   VLC_FOURCC('s','h','n',' ')
+#define VLC_CODEC_WAVPACK   VLC_FOURCC('W','V','P','K')
+#define VLC_CODEC_GSM       VLC_FOURCC('g','s','m',' ')
+#define VLC_CODEC_GSM_MS    VLC_FOURCC('a','g','s','m')
+#define VLC_CODEC_ATRAC1    VLC_FOURCC('a','t','r','1')
+#define VLC_CODEC_ATRAC3    VLC_FOURCC('a','t','r','c')
+#define VLC_CODEC_SONIC     VLC_FOURCC('S','O','N','C')
+#define VLC_CODEC_IMC       VLC_FOURCC(0x1,0x4,0x0,0x0)
+#define VLC_CODEC_TRUESPEECH VLC_FOURCC(0x22,0x0,0x0,0x0)
+#define VLC_CODEC_NELLYMOSER VLC_FOURCC('N','E','L','L')
+#define VLC_CODEC_APE       VLC_FOURCC('A','P','E',' ')
+#define VLC_CODEC_QCELP     VLC_FOURCC('Q','c','l','p')
+#define VLC_CODEC_302M      VLC_FOURCC('3','0','2','m')
+#define VLC_CODEC_DVD_LPCM  VLC_FOURCC('l','p','c','m')
+#define VLC_CODEC_DVDA_LPCM VLC_FOURCC('a','p','c','m')
+#define VLC_CODEC_BD_LPCM   VLC_FOURCC('b','p','c','m')
+#define VLC_CODEC_SDDS      VLC_FOURCC('s','d','d','s')
+#define VLC_CODEC_MIDI      VLC_FOURCC('M','I','D','I')
+#define VLC_CODEC_S8        VLC_FOURCC('s','8',' ',' ')
+#define VLC_CODEC_U8        VLC_FOURCC('u','8',' ',' ')
+#define VLC_CODEC_S16L      VLC_FOURCC('s','1','6','l')
+#define VLC_CODEC_S16B      VLC_FOURCC('s','1','6','b')
+#define VLC_CODEC_U16L      VLC_FOURCC('u','1','6','l')
+#define VLC_CODEC_U16B      VLC_FOURCC('u','1','6','b')
+#define VLC_CODEC_S20B      VLC_FOURCC('s','2','0','b')
+#define VLC_CODEC_S24L      VLC_FOURCC('s','2','4','l')
+#define VLC_CODEC_S24B      VLC_FOURCC('s','2','4','b')
+#define VLC_CODEC_U24L      VLC_FOURCC('u','2','4','l')
+#define VLC_CODEC_U24B      VLC_FOURCC('u','2','4','b')
+#define VLC_CODEC_S32L      VLC_FOURCC('s','3','2','l')
+#define VLC_CODEC_S32B      VLC_FOURCC('s','3','2','b')
+#define VLC_CODEC_U32L      VLC_FOURCC('u','3','2','l')
+#define VLC_CODEC_U32B      VLC_FOURCC('u','3','2','b')
+#define VLC_CODEC_F32L      VLC_FOURCC('f','3','2','l')
+#define VLC_CODEC_F32B      VLC_FOURCC('f','3','2','b')
+#define VLC_CODEC_F64L      VLC_FOURCC('f','6','4','l')
+#define VLC_CODEC_F64B      VLC_FOURCC('f','6','4','b')
+
+#define VLC_CODEC_ALAW      VLC_FOURCC('a','l','a','w')
+#define VLC_CODEC_MULAW     VLC_FOURCC('m','l','a','w')
+#define VLC_CODEC_DAT12     VLC_FOURCC('L','P','1','2')
+#define VLC_CODEC_S24DAUD   VLC_FOURCC('d','a','u','d')
+#define VLC_CODEC_FI32      VLC_FOURCC('f','i','3','2')
+#define VLC_CODEC_TWINVQ    VLC_FOURCC('T','W','I','N')
+#define VLC_CODEC_ADPCM_IMA_AMV VLC_FOURCC('i','m','a','v')
+
+/* Subtitle */
+#define VLC_CODEC_SPU       VLC_FOURCC('s','p','u',' ')
+#define VLC_CODEC_DVBS      VLC_FOURCC('d','v','b','s')
+#define VLC_CODEC_SUBT      VLC_FOURCC('s','u','b','t')
+#define VLC_CODEC_XSUB      VLC_FOURCC('X','S','U','B')
+#define VLC_CODEC_SSA       VLC_FOURCC('s','s','a',' ')
+#define VLC_CODEC_TEXT      VLC_FOURCC('T','E','X','T')
+#define VLC_CODEC_TELETEXT  VLC_FOURCC('t','e','l','x')
+#define VLC_CODEC_KATE      VLC_FOURCC('k','a','t','e')
+#define VLC_CODEC_CMML      VLC_FOURCC('c','m','m','l')
+#define VLC_CODEC_ITU_T140  VLC_FOURCC('t','1','4','0')
+#define VLC_CODEC_USF       VLC_FOURCC('u','s','f',' ')
+#define VLC_CODEC_OGT       VLC_FOURCC('o','g','t',' ')
+#define VLC_CODEC_CVD       VLC_FOURCC('c','v','d',' ')
+/* Blu-ray Presentation Graphics */
+#define VLC_CODEC_BD_PG     VLC_FOURCC('b','d','p','g')
+/* EBU STL (TECH. 3264-E) */
+#define VLC_CODEC_EBU_STL   VLC_FOURCC('S','T','L',' ')
+
+
+/* Special endian dependant values
+ * The suffic N means Native
+ * The suffix I means Inverted (ie non native) */
+#ifdef WORDS_BIGENDIAN
+#   define VLC_CODEC_S16N VLC_CODEC_S16B
+#   define VLC_CODEC_U16N VLC_CODEC_U16B
+#   define VLC_CODEC_S24N VLC_CODEC_S24B
+#   define VLC_CODEC_S32N VLC_CODEC_S32B
+#   define VLC_CODEC_FL32 VLC_CODEC_F32B
+#   define VLC_CODEC_FL64 VLC_CODEC_F64B
+
+#   define VLC_CODEC_S16I VLC_CODEC_S16L
+#   define VLC_CODEC_U16I VLC_CODEC_U16L
+#   define VLC_CODEC_S24I VLC_CODEC_S24L
+#   define VLC_CODEC_S32I VLC_CODEC_S32L
+
+#else
+#   define VLC_CODEC_S16N VLC_CODEC_S16L
+#   define VLC_CODEC_U16N VLC_CODEC_U16L
+#   define VLC_CODEC_S24N VLC_CODEC_S24L
+#   define VLC_CODEC_S32N VLC_CODEC_S32L
+#   define VLC_CODEC_FL32 VLC_CODEC_F32L
+#   define VLC_CODEC_FL64 VLC_CODEC_F64L
+
+#   define VLC_CODEC_S16I VLC_CODEC_S16B
+#   define VLC_CODEC_U16I VLC_CODEC_U16B
+#   define VLC_CODEC_S24I VLC_CODEC_S24B
+#   define VLC_CODEC_S32I VLC_CODEC_S32B
+#endif
+
+/* Non official codecs, used to force a profile in an encoder */
+/* MPEG-1 video */
+#define VLC_CODEC_MP1V      VLC_FOURCC('m','p','1','v')
+/* MPEG-2 video */
+#define VLC_CODEC_MP2V      VLC_FOURCC('m','p','2','v')
+/* MPEG-I/II layer 2 audio */
+#define VLC_CODEC_MP2       VLC_FOURCC('m','p','2',' ')
+/* MPEG-I/II layer 3 audio */
+#define VLC_CODEC_MP3       VLC_FOURCC('m','p','3',' ')
+
+/**
+ * It returns the codec associated to a fourcc within a ES category.
+ *
+ * If not found, it will return the given fourcc.
+ * If found, it will always be one of the VLC_CODEC_ defined above.
+ *
+ * You may use UNKNOWN_ES for the ES category if you don't have the information.
+ */
+VLC_API vlc_fourcc_t vlc_fourcc_GetCodec( int i_cat, vlc_fourcc_t i_fourcc );
+
+/**
+ * It returns the codec associated to a fourcc store in a zero terminated
+ * string.
+ *
+ * If the string is NULL or does not have exactly 4 charateres, it will
+ * return 0, otherwise it behaves like vlc_fourcc_GetCodec.
+ *
+ * Provided for convenience.
+ */
+VLC_API vlc_fourcc_t vlc_fourcc_GetCodecFromString( int i_cat, const char * );
+
+/**
+ * It convert the gives fourcc to an audio codec when possible.
+ *
+ * The fourcc converted are aflt, araw/pcm , twos, sowt. When an incompatible i_bits
+ * is detected, 0 is returned.
+ * The other fourcc goes through vlc_fourcc_GetCodec and i_bits is not checked.
+ */
+VLC_API vlc_fourcc_t vlc_fourcc_GetCodecAudio( vlc_fourcc_t i_fourcc, int i_bits );
+
+/**
+ * It returns the description of the given fourcc or NULL if not found.
+ *
+ * You may use UNKNOWN_ES for the ES category if you don't have the information.
+ */
+VLC_API const char * vlc_fourcc_GetDescription( int i_cat, vlc_fourcc_t i_fourcc );
+
+/**
+ * It returns a list (terminated with the value 0) of YUV fourccs in
+ * decreasing priority order for the given chroma.
+ *
+ * It will always return a non NULL pointer that must not be freed.
+ */
+VLC_API const vlc_fourcc_t * vlc_fourcc_GetYUVFallback( vlc_fourcc_t );
+
+/**
+ * It returns a list (terminated with the value 0) of RGB fourccs in
+ * decreasing priority order for the given chroma.
+ *
+ * It will always return a non NULL pointer that must not be freed.
+ */
+VLC_API const vlc_fourcc_t * vlc_fourcc_GetRGBFallback( vlc_fourcc_t );
+
+/**
+ * It returns true if the given fourcc is YUV and false otherwise.
+ */
+VLC_API bool vlc_fourcc_IsYUV( vlc_fourcc_t );
+
+/**
+ * It returns true if the two fourccs are equivalent if their U&V planes are
+ * swapped.
+ */
+VLC_API bool vlc_fourcc_AreUVPlanesSwapped(vlc_fourcc_t , vlc_fourcc_t );
+
+/**
+ * Chroma related information.
+ */
+typedef struct {
+    unsigned plane_count;
+    struct {
+        struct {
+            unsigned num;
+            unsigned den;
+        } w;
+        struct {
+            unsigned num;
+            unsigned den;
+        } h;
+    } p[4];
+    unsigned pixel_size;        /* Number of bytes per pixel for a plane */
+    unsigned pixel_bits;        /* Number of bits actually used bits per pixel for a plane */
+} vlc_chroma_description_t;
+
+/**
+ * It returns a vlc_chroma_description_t describing the request fourcc or NULL
+ * if not found.
+ */
+VLC_API const vlc_chroma_description_t * vlc_fourcc_GetChromaDescription( vlc_fourcc_t fourcc );
+
+#endif /* _VLC_FOURCC_H */
+

=== added file 'DivCity/DivCity/vlc/plugins/vlc_fs.h'
--- DivCity/DivCity/vlc/plugins/vlc_fs.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_fs.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,78 @@
+/*****************************************************************************
+ * vlc_fs.h: File system helpers
+ *****************************************************************************
+ * Copyright Â© 2006-2010 RÃ©mi Denis-Courmont
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_FS_H
+#define VLC_FS_H 1
+
+/**
+ * \file
+ * Those functions convert file paths from UTF-8 to the system-specific
+ * encoding (especially UTF-16 on Windows). Also, they always mark file
+ * descriptor with the close-on-exec flag.
+ */
+
+#include <sys/types.h>
+#include <dirent.h>
+
+VLC_API int vlc_open( const char *filename, int flags, ... ) VLC_USED;
+VLC_API FILE * vlc_fopen( const char *filename, const char *mode ) VLC_USED;
+VLC_API int vlc_openat( int fd, const char *filename, int flags, ... ) VLC_USED;
+
+VLC_API DIR * vlc_opendir( const char *dirname ) VLC_USED;
+VLC_API char * vlc_readdir( DIR *dir ) VLC_USED;
+VLC_API int vlc_loaddir( DIR *dir, char ***namelist, int (*select)( const char * ), int (*compar)( const char **, const char ** ) );
+VLC_API int vlc_scandir( const char *dirname, char ***namelist, int (*select)( const char * ), int (*compar)( const char **, const char ** ) );
+VLC_API int vlc_mkdir( const char *filename, mode_t mode );
+
+VLC_API int vlc_unlink( const char *filename );
+VLC_API int vlc_rename( const char *oldpath, const char *newpath );
+VLC_API char *vlc_getcwd( void ) VLC_USED;
+
+#if defined( WIN32 )
+# ifndef UNDER_CE
+#  define stat _stati64
+# endif
+static inline int vlc_closedir( DIR *dir )
+{
+    _WDIR *wdir = *(_WDIR **)dir;
+    free( dir );
+    return wdir ? _wclosedir( wdir ) : 0;
+}
+# undef closedir
+# define closedir vlc_closedir
+
+static inline void vlc_rewinddir( DIR *dir )
+{
+    _WDIR *wdir = *(_WDIR **)dir;
+
+    _wrewinddir( wdir );
+}
+# undef rewinddir
+# define rewinddir vlc_rewinddir
+#endif
+
+VLC_API int vlc_stat( const char *filename, struct stat *buf );
+VLC_API int vlc_lstat( const char *filename, struct stat *buf );
+
+VLC_API int vlc_mkstemp( char * );
+
+VLC_API int vlc_dup( int );
+VLC_API int vlc_pipe( int[2] );
+#endif

=== added file 'DivCity/DivCity/vlc/plugins/vlc_gcrypt.h'
--- DivCity/DivCity/vlc/plugins/vlc_gcrypt.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_gcrypt.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,103 @@
+/*****************************************************************************
+ * vlc_gcrypt.h: VLC thread support for gcrypt
+ *****************************************************************************
+ * Copyright (C) 2004-2010 RÃ©mi Denis-Courmont
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+/**
+ * \file
+ * This file implements gcrypt support functions in vlc
+ */
+
+#include <errno.h>
+
+#ifdef LIBVLC_USE_PTHREAD
+/**
+ * If possible, use gcrypt-provided thread implementation. This is so that
+ * other non-VLC components (inside the process) can also use gcrypt safely.
+ */
+GCRY_THREAD_OPTION_PTHREAD_IMPL;
+# define gcry_threads_vlc gcry_threads_pthread
+#else
+
+/**
+ * gcrypt thread option VLC implementation
+ */
+
+static int gcry_vlc_mutex_init( void **p_sys )
+{
+    vlc_mutex_t *p_lock = (vlc_mutex_t *)malloc( sizeof( vlc_mutex_t ) );
+    if( p_lock == NULL)
+        return ENOMEM;
+
+    vlc_mutex_init( p_lock );
+    *p_sys = p_lock;
+    return VLC_SUCCESS;
+}
+
+static int gcry_vlc_mutex_destroy( void **p_sys )
+{
+    vlc_mutex_t *p_lock = (vlc_mutex_t *)*p_sys;
+    vlc_mutex_destroy( p_lock );
+    free( p_lock );
+    return VLC_SUCCESS;
+}
+
+static int gcry_vlc_mutex_lock( void **p_sys )
+{
+    vlc_mutex_lock( (vlc_mutex_t *)*p_sys );
+    return VLC_SUCCESS;
+}
+
+static int gcry_vlc_mutex_unlock( void **lock )
+{
+    vlc_mutex_unlock( (vlc_mutex_t *)*lock );
+    return VLC_SUCCESS;
+}
+
+static const struct gcry_thread_cbs gcry_threads_vlc =
+{
+    GCRY_THREAD_OPTION_USER,
+    NULL,
+    gcry_vlc_mutex_init,
+    gcry_vlc_mutex_destroy,
+    gcry_vlc_mutex_lock,
+    gcry_vlc_mutex_unlock,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
+};
+#endif
+
+/**
+ * Initializes gcrypt with proper locking.
+ */
+static inline void vlc_gcrypt_init (void)
+{
+    /* This would need a process-wide static mutex with all libraries linking
+     * to a given instance of libgcrypt. We cannot do this as we have different
+     * plugins linking with gcrypt, and some underlying libraries may use it
+     * behind our back. Only way is to always link gcrypt statically (ouch!) or
+     * have upstream gcrypt provide one shared object per threading system. */
+    static bool done = false;
+
+    vlc_global_lock (VLC_GCRYPT_MUTEX);
+    if (!done)
+    {
+        gcry_control (GCRYCTL_SET_THREAD_CBS, &gcry_threads_vlc);
+        done = true;
+    }
+    vlc_global_unlock (VLC_GCRYPT_MUTEX);
+}

=== added file 'DivCity/DivCity/vlc/plugins/vlc_http.h'
--- DivCity/DivCity/vlc/plugins/vlc_http.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_http.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,67 @@
+/*****************************************************************************
+ * vlc_http.h: Shared code for HTTP clients
+ *****************************************************************************
+ * Copyright (C) 2001-2008 VLC authors and VideoLAN
+ * $Id: ddde13efed1e11a15632f17e1da4437f59750988 $
+ *
+ * Authors: Laurent Aimar <fenrir@via.ecp.fr>
+ *          Christophe Massiot <massiot@via.ecp.fr>
+ *          RÃ©mi Denis-Courmont <rem # videolan.org>
+ *          Antoine Cellerier <dionoea at videolan dot org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_HTTP_H
+#define VLC_HTTP_H 1
+
+/**
+ * \file
+ * This file defines functions, structures, enums and macros shared between
+ * HTTP clients.
+ */
+
+/* RFC 2617: Basic and Digest Access Authentication */
+typedef struct http_auth_t
+{
+    char *psz_realm;
+    char *psz_domain;
+    char *psz_nonce;
+    char *psz_opaque;
+    char *psz_stale;
+    char *psz_algorithm;
+    char *psz_qop;
+    int i_nonce;
+    char *psz_cnonce;
+    char *psz_HA1; /* stored H(A1) value if algorithm = "MD5-sess" */
+} http_auth_t;
+
+
+VLC_API void http_auth_Init( http_auth_t * );
+VLC_API void http_auth_Reset( http_auth_t * );
+VLC_API void http_auth_ParseWwwAuthenticateHeader
+            ( vlc_object_t *, http_auth_t * ,
+              const char * );
+VLC_API int http_auth_ParseAuthenticationInfoHeader
+            ( vlc_object_t *, http_auth_t *,
+              const char *, const char *,
+              const char *, const char *,
+              const char * );
+VLC_API char *http_auth_FormatAuthorizationHeader
+            ( vlc_object_t *, http_auth_t *,
+              const char *, const char *,
+              const char *, const char * ) VLC_USED;
+
+#endif /* VLC_HTTP_H */

=== added file 'DivCity/DivCity/vlc/plugins/vlc_httpd.h'
--- DivCity/DivCity/vlc/plugins/vlc_httpd.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_httpd.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,139 @@
+/*****************************************************************************
+ * vlc_httpd.h: builtin HTTP/RTSP server.
+ *****************************************************************************
+ * Copyright (C) 2004-2006 VLC authors and VideoLAN
+ * $Id: a4c3a0f699137ee873d71ecdca961bc1240c861a $
+ *
+ * Authors: Laurent Aimar <fenrir@via.ecp.fr>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_HTTPD_H
+#define VLC_HTTPD_H 1
+
+/**
+ * \file
+ * This file defines functions, structures, enums and macros for httpd functionality in vlc.
+ */
+
+enum
+{
+    HTTPD_MSG_NONE,
+
+    /* answer */
+    HTTPD_MSG_ANSWER,
+
+    /* http request */
+    HTTPD_MSG_GET,
+    HTTPD_MSG_HEAD,
+    HTTPD_MSG_POST,
+
+    /* rtsp request */
+    HTTPD_MSG_OPTIONS,
+    HTTPD_MSG_DESCRIBE,
+    HTTPD_MSG_SETUP,
+    HTTPD_MSG_PLAY,
+    HTTPD_MSG_PAUSE,
+    HTTPD_MSG_GETPARAMETER,
+    HTTPD_MSG_TEARDOWN,
+
+    /* just to track the count of MSG */
+    HTTPD_MSG_MAX
+};
+
+enum
+{
+    HTTPD_PROTO_NONE,
+    HTTPD_PROTO_HTTP,  /* HTTP/1.x */
+    HTTPD_PROTO_RTSP,  /* RTSP/1.x */
+    HTTPD_PROTO_HTTP0, /* HTTP/0.x */
+};
+
+struct httpd_message_t
+{
+    httpd_client_t *cl; /* NULL if not throught a connection e vlc internal */
+
+    uint8_t i_type;
+    uint8_t i_proto;
+    uint8_t i_version;
+
+    /* for an answer */
+    int     i_status;
+
+    /* for a query */
+    char    *psz_url;
+    /* FIXME find a clean way to handle GET(psz_args)
+       and POST(body) through the same code */
+    uint8_t *psz_args;
+
+    /* options */
+    int     i_name;
+    char    **name;
+    int     i_value;
+    char    **value;
+
+    /* body */
+    int64_t i_body_offset;
+    int     i_body;
+    uint8_t *p_body;
+
+};
+
+/* create a new host */
+VLC_API httpd_host_t *vlc_http_HostNew( vlc_object_t * ) VLC_USED;
+VLC_API httpd_host_t *vlc_https_HostNew( vlc_object_t * ) VLC_USED;
+VLC_API httpd_host_t *vlc_rtsp_HostNew( vlc_object_t * ) VLC_USED;
+
+/* delete a host */
+VLC_API void httpd_HostDelete( httpd_host_t * );
+
+/* register a new url */
+VLC_API httpd_url_t * httpd_UrlNew( httpd_host_t *, const char *psz_url, const char *psz_user, const char *psz_password, const vlc_acl_t *p_acl ) VLC_USED;
+VLC_API httpd_url_t * httpd_UrlNewUnique( httpd_host_t *, const char *psz_url, const char *psz_user, const char *psz_password, const vlc_acl_t *p_acl ) VLC_USED;
+/* register callback on a url */
+VLC_API int httpd_UrlCatch( httpd_url_t *, int i_msg, httpd_callback_t, httpd_callback_sys_t * );
+/* delete a url */
+VLC_API void httpd_UrlDelete( httpd_url_t * );
+
+VLC_API char* httpd_ClientIP( const httpd_client_t *cl, char *, int * );
+VLC_API char* httpd_ServerIP( const httpd_client_t *cl, char *, int * );
+
+/* High level */
+
+VLC_API httpd_file_t * httpd_FileNew( httpd_host_t *, const char *psz_url, const char *psz_mime, const char *psz_user, const char *psz_password, const vlc_acl_t *p_acl, httpd_file_callback_t pf_fill, httpd_file_sys_t * ) VLC_USED;
+VLC_API httpd_file_sys_t * httpd_FileDelete( httpd_file_t * );
+
+
+VLC_API httpd_handler_t * httpd_HandlerNew( httpd_host_t *, const char *psz_url, const char *psz_user, const char *psz_password, const vlc_acl_t *p_acl, httpd_handler_callback_t pf_fill, httpd_handler_sys_t * ) VLC_USED;
+VLC_API httpd_handler_sys_t * httpd_HandlerDelete( httpd_handler_t * );
+
+
+VLC_API httpd_redirect_t * httpd_RedirectNew( httpd_host_t *, const char *psz_url_dst, const char *psz_url_src ) VLC_USED;
+VLC_API void httpd_RedirectDelete( httpd_redirect_t * );
+
+
+VLC_API httpd_stream_t * httpd_StreamNew( httpd_host_t *, const char *psz_url, const char *psz_mime, const char *psz_user, const char *psz_password, const vlc_acl_t *p_acl ) VLC_USED;
+VLC_API void httpd_StreamDelete( httpd_stream_t * );
+VLC_API int httpd_StreamHeader( httpd_stream_t *, uint8_t *p_data, int i_data );
+VLC_API int httpd_StreamSend( httpd_stream_t *, uint8_t *p_data, int i_data );
+
+
+/* Msg functions facilities */
+VLC_API void httpd_MsgAdd( httpd_message_t *, const char *psz_name, const char *psz_value, ... ) VLC_FORMAT( 3, 4 );
+/* return "" if not found. The string is not allocated */
+VLC_API const char * httpd_MsgGet( const httpd_message_t *, const char *psz_name );
+
+#endif /* _VLC_HTTPD_H */

=== added file 'DivCity/DivCity/vlc/plugins/vlc_image.h'
--- DivCity/DivCity/vlc/plugins/vlc_image.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_image.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,81 @@
+/*****************************************************************************
+ * vlc_image.h : wrapper for image reading/writing facilities
+ *****************************************************************************
+ * Copyright (C) 2004 VLC authors and VideoLAN
+ * $Id: 52bce1f24495ffdbadfb6d0aef0953577992b9a2 $
+ *
+ * Authors: Gildas Bazin <gbazin@videolan.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_IMAGE_H
+#define VLC_IMAGE_H 1
+
+/**
+ * \file
+ * This file defines functions and structures for image conversions in vlc
+ */
+
+#include <vlc_vout.h>
+
+# ifdef __cplusplus
+extern "C" {
+# endif
+
+struct image_handler_t
+{
+    picture_t * (*pf_read)      ( image_handler_t *, block_t *,
+                                  video_format_t *, video_format_t * );
+    picture_t * (*pf_read_url)  ( image_handler_t *, const char *,
+                                  video_format_t *, video_format_t * );
+    block_t * (*pf_write)       ( image_handler_t *, picture_t *,
+                                  video_format_t *, video_format_t * );
+    int (*pf_write_url)         ( image_handler_t *, picture_t *,
+                                  video_format_t *, video_format_t *,
+                                  const char * );
+
+    picture_t * (*pf_convert)   ( image_handler_t *, picture_t *,
+                                  video_format_t *, video_format_t * );
+    picture_t * (*pf_filter)    ( image_handler_t *, picture_t *,
+                                  video_format_t *, const char * );
+
+    /* Private properties */
+    vlc_object_t *p_parent;
+    decoder_t *p_dec;
+    encoder_t *p_enc;
+    filter_t  *p_filter;
+};
+
+VLC_API image_handler_t * image_HandlerCreate( vlc_object_t * ) VLC_USED;
+#define image_HandlerCreate( a ) image_HandlerCreate( VLC_OBJECT(a) )
+VLC_API void image_HandlerDelete( image_handler_t * );
+
+#define image_Read( a, b, c, d ) a->pf_read( a, b, c, d )
+#define image_ReadUrl( a, b, c, d ) a->pf_read_url( a, b, c, d )
+#define image_Write( a, b, c, d ) a->pf_write( a, b, c, d )
+#define image_WriteUrl( a, b, c, d, e ) a->pf_write_url( a, b, c, d, e )
+#define image_Convert( a, b, c, d ) a->pf_convert( a, b, c, d )
+#define image_Filter( a, b, c, d ) a->pf_filter( a, b, c, d )
+
+VLC_API vlc_fourcc_t image_Type2Fourcc( const char *psz_name );
+VLC_API vlc_fourcc_t image_Ext2Fourcc( const char *psz_name );
+VLC_API vlc_fourcc_t image_Mime2Fourcc( const char *psz_mime );
+
+# ifdef __cplusplus
+}
+# endif
+
+#endif /* _VLC_IMAGE_H */

=== added file 'DivCity/DivCity/vlc/plugins/vlc_inhibit.h'
--- DivCity/DivCity/vlc/plugins/vlc_inhibit.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_inhibit.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,41 @@
+/*****************************************************************************
+ * vlc_inhibit.h: VLC screen saver inhibition
+ *****************************************************************************
+ * Copyright (C) 2009 RÃ©mi Denis-Courmont
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+/**
+ * \file
+ * This file defines the interface for screen-saver inhibition modules
+ */
+
+#ifndef VLC_INHIBIT_H
+# define VLC_INHIBIT_H 1
+
+typedef struct vlc_inhibit vlc_inhibit_t;
+typedef struct vlc_inhibit_sys vlc_inhibit_sys_t;
+
+struct vlc_inhibit
+{
+    VLC_COMMON_MEMBERS
+
+    uint32_t           window_id;
+    vlc_inhibit_sys_t *p_sys;
+    void             (*inhibit) (vlc_inhibit_t *, bool);
+};
+
+#endif

=== added file 'DivCity/DivCity/vlc/plugins/vlc_input.h'
--- DivCity/DivCity/vlc/plugins/vlc_input.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_input.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,672 @@
+/*****************************************************************************
+ * vlc_input.h: Core input structures
+ *****************************************************************************
+ * Copyright (C) 1999-2006 VLC authors and VideoLAN
+ * $Id: 7d8320a75ce9b2263aa3ec1fe34090cc4f7cf732 $
+ *
+ * Authors: Christophe Massiot <massiot@via.ecp.fr>
+ *          Laurent Aimar <fenrir@via.ecp.fr>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+/* __ is need because conflict with <vlc/input.h> */
+#ifndef VLC_INPUT_H
+#define VLC_INPUT_H 1
+
+/**
+ * \file
+ * This file defines functions, structures and enums for input objects in vlc
+ */
+
+#include <vlc_es.h>
+#include <vlc_meta.h>
+#include <vlc_epg.h>
+#include <vlc_events.h>
+#include <vlc_input_item.h>
+
+#include <string.h>
+
+/*****************************************************************************
+ * Meta data helpers
+ *****************************************************************************/
+static inline void vlc_audio_replay_gain_MergeFromMeta( audio_replay_gain_t *p_dst,
+                                                        const vlc_meta_t *p_meta )
+{
+    const char * psz_value;
+
+    if( !p_meta )
+        return;
+
+    if( (psz_value = vlc_meta_GetExtra(p_meta, "REPLAYGAIN_TRACK_GAIN")) ||
+        (psz_value = vlc_meta_GetExtra(p_meta, "RG_RADIO")) )
+    {
+        p_dst->pb_gain[AUDIO_REPLAY_GAIN_TRACK] = true;
+        p_dst->pf_gain[AUDIO_REPLAY_GAIN_TRACK] = atof( psz_value );
+    }
+    else if( (psz_value = vlc_meta_GetExtra(p_meta, "REPLAYGAIN_TRACK_PEAK" )) ||
+             (psz_value = vlc_meta_GetExtra(p_meta, "RG_PEAK" )) )
+    {
+        p_dst->pb_peak[AUDIO_REPLAY_GAIN_TRACK] = true;
+        p_dst->pf_peak[AUDIO_REPLAY_GAIN_TRACK] = atof( psz_value );
+    }
+    else if( (psz_value = vlc_meta_GetExtra(p_meta, "REPLAYGAIN_ALBUM_GAIN" )) ||
+             (psz_value = vlc_meta_GetExtra(p_meta, "RG_AUDIOPHILE" )) )
+    {
+        p_dst->pb_gain[AUDIO_REPLAY_GAIN_ALBUM] = true;
+        p_dst->pf_gain[AUDIO_REPLAY_GAIN_ALBUM] = atof( psz_value );
+    }
+    else if( (psz_value = vlc_meta_GetExtra(p_meta, "REPLAYGAIN_ALBUM_PEAK" )) )
+    {
+        p_dst->pb_peak[AUDIO_REPLAY_GAIN_ALBUM] = true;
+        p_dst->pf_peak[AUDIO_REPLAY_GAIN_ALBUM] = atof( psz_value );
+    }
+}
+
+/*****************************************************************************
+ * Seek point: (generalisation of chapters)
+ *****************************************************************************/
+struct seekpoint_t
+{
+    int64_t i_byte_offset;
+    int64_t i_time_offset;
+    char    *psz_name;
+};
+
+static inline seekpoint_t *vlc_seekpoint_New( void )
+{
+    seekpoint_t *point = (seekpoint_t*)malloc( sizeof( seekpoint_t ) );
+    point->i_byte_offset =
+    point->i_time_offset = -1;
+    point->psz_name = NULL;
+    return point;
+}
+
+static inline void vlc_seekpoint_Delete( seekpoint_t *point )
+{
+    if( !point ) return;
+    free( point->psz_name );
+    free( point );
+}
+
+static inline seekpoint_t *vlc_seekpoint_Duplicate( const seekpoint_t *src )
+{
+    seekpoint_t *point = vlc_seekpoint_New();
+    if( src->psz_name ) point->psz_name = strdup( src->psz_name );
+    point->i_time_offset = src->i_time_offset;
+    point->i_byte_offset = src->i_byte_offset;
+    return point;
+}
+
+/*****************************************************************************
+ * Title:
+ *****************************************************************************/
+typedef struct
+{
+    char        *psz_name;
+
+    bool        b_menu;      /* Is it a menu or a normal entry */
+
+    int64_t     i_length;   /* Length(microsecond) if known, else 0 */
+    int64_t     i_size;     /* Size (bytes) if known, else 0 */
+
+    /* Title seekpoint */
+    int         i_seekpoint;
+    seekpoint_t **seekpoint;
+
+} input_title_t;
+
+static inline input_title_t *vlc_input_title_New(void)
+{
+    input_title_t *t = (input_title_t*)malloc( sizeof( input_title_t ) );
+
+    t->psz_name = NULL;
+    t->b_menu = false;
+    t->i_length = 0;
+    t->i_size   = 0;
+    t->i_seekpoint = 0;
+    t->seekpoint = NULL;
+
+    return t;
+}
+
+static inline void vlc_input_title_Delete( input_title_t *t )
+{
+    int i;
+    if( t == NULL )
+        return;
+
+    free( t->psz_name );
+    for( i = 0; i < t->i_seekpoint; i++ )
+    {
+        free( t->seekpoint[i]->psz_name );
+        free( t->seekpoint[i] );
+    }
+    free( t->seekpoint );
+    free( t );
+}
+
+static inline input_title_t *vlc_input_title_Duplicate( const input_title_t *t )
+{
+    input_title_t *dup = vlc_input_title_New( );
+    int i;
+
+    if( t->psz_name ) dup->psz_name = strdup( t->psz_name );
+    dup->b_menu      = t->b_menu;
+    dup->i_length    = t->i_length;
+    dup->i_size      = t->i_size;
+    dup->i_seekpoint = t->i_seekpoint;
+    if( t->i_seekpoint > 0 )
+    {
+        dup->seekpoint = (seekpoint_t**)calloc( t->i_seekpoint,
+                                                sizeof(seekpoint_t*) );
+
+        for( i = 0; i < t->i_seekpoint; i++ )
+        {
+            dup->seekpoint[i] = vlc_seekpoint_Duplicate( t->seekpoint[i] );
+        }
+    }
+
+    return dup;
+}
+
+/*****************************************************************************
+ * Attachments
+ *****************************************************************************/
+struct input_attachment_t
+{
+    char *psz_name;
+    char *psz_mime;
+    char *psz_description;
+
+    int  i_data;
+    void *p_data;
+};
+
+static inline input_attachment_t *vlc_input_attachment_New( const char *psz_name,
+                                                            const char *psz_mime,
+                                                            const char *psz_description,
+                                                            const void *p_data,
+                                                            int i_data )
+{
+    input_attachment_t *a =
+        (input_attachment_t*)malloc( sizeof(input_attachment_t) );
+    if( !a )
+        return NULL;
+    a->psz_name = strdup( psz_name ? psz_name : "" );
+    a->psz_mime = strdup( psz_mime ? psz_mime : "" );
+    a->psz_description = strdup( psz_description ? psz_description : "" );
+    a->i_data = i_data;
+    a->p_data = NULL;
+    if( i_data > 0 )
+    {
+        a->p_data = malloc( i_data );
+        if( a->p_data && p_data )
+            memcpy( a->p_data, p_data, i_data );
+    }
+    return a;
+}
+static inline input_attachment_t *vlc_input_attachment_Duplicate( const input_attachment_t *a )
+{
+    return vlc_input_attachment_New( a->psz_name, a->psz_mime, a->psz_description,
+                                     a->p_data, a->i_data );
+}
+static inline void vlc_input_attachment_Delete( input_attachment_t *a )
+{
+    if( !a )
+        return;
+    free( a->psz_name );
+    free( a->psz_mime );
+    free( a->psz_description );
+    free( a->p_data );
+    free( a );
+}
+
+/*****************************************************************************
+ * input defines/constants.
+ *****************************************************************************/
+
+/* i_update field of access_t/demux_t */
+#define INPUT_UPDATE_NONE       0x0000
+#define INPUT_UPDATE_SIZE       0x0001
+#define INPUT_UPDATE_TITLE      0x0010
+#define INPUT_UPDATE_SEEKPOINT  0x0020
+#define INPUT_UPDATE_META       0x0040
+#define INPUT_UPDATE_SIGNAL     0x0080
+
+/**
+ * This defines private core storage for an input.
+ */
+typedef struct input_thread_private_t input_thread_private_t;
+
+/**
+ * This defines an opaque input resource handler.
+ */
+typedef struct input_resource_t input_resource_t;
+
+/**
+ * Main structure representing an input thread. This structure is mostly
+ * private. The only public fields are READ-ONLY. You must use the helpers
+ * to modify them
+ */
+struct input_thread_t
+{
+    VLC_COMMON_MEMBERS
+
+    bool b_error;
+    bool b_eof;
+    bool b_preparsing;
+    bool b_dead;
+
+    /* All other data is input_thread is PRIVATE. You can't access it
+     * outside of src/input */
+    input_thread_private_t *p;
+};
+
+/**
+ * Record prefix string.
+ * TODO make it configurable.
+ */
+#define INPUT_RECORD_PREFIX "vlc-record-%Y-%m-%d-%Hh%Mm%Ss-$ N-$ p"
+
+/*****************************************************************************
+ * Input events and variables
+ *****************************************************************************/
+
+/**
+ * \defgroup inputvariable Input variables
+ *
+ * The input provides multiples variable you can write to and/or read from.
+ *
+ * TODO complete the documentation.
+ * The read only variables are:
+ *  - "length"
+ *  - "can-seek" (if you can seek, it doesn't say if 'bar display' has be shown
+ *    or not, for that check position != 0.0)
+ *  - "can-pause"
+ *  - "can-rate"
+ *  - "can-rewind"
+ *  - "can-record" (if a stream can be recorded while playing)
+ *  - "teletext-es" (list of id from the spu tracks (spu-es) that are teletext, the
+ *                   variable value being the one currently selected, -1 if no teletext)
+ *  - "signal-quality"
+ *  - "signal-strength"
+ *  - "program-scrambled" (if the current program is scrambled)
+ *  - "cache" (level of data cached [0 .. 1])
+ *
+ * The read-write variables are:
+ *  - state (\see input_state_e)
+ *  - rate
+ *  - position, position-offset
+ *  - time, time-offset
+ *  - title, next-title, prev-title
+ *  - chapter, next-chapter, next-chapter-prev
+ *  - program, audio-es, video-es, spu-es
+ *  - audio-delay, spu-delay
+ *  - bookmark (bookmark list)
+ *  - record
+ *  - frame-next
+ *  - navigation (list of "title %2i")
+ *  - "title %2i"
+ *
+ * The variable used for event is
+ *  - intf-event (\see input_event_type_e)
+ */
+
+/**
+ * Input state
+ *
+ * This enum is used by the variable "state"
+ */
+typedef enum input_state_e
+{
+    INIT_S = 0,
+    OPENING_S,
+    PLAYING_S,
+    PAUSE_S,
+    END_S,
+    ERROR_S,
+} input_state_e;
+
+/**
+ * Input rate.
+ *
+ * It is an float used by the variable "rate" in the
+ * range [INPUT_RATE_DEFAULT/INPUT_RATE_MAX, INPUT_RATE_DEFAULT/INPUT_RATE_MAX]
+ * the default value being 1. It represents the ratio of playback speed to
+ * nominal speed (bigger is faster).
+ *
+ * Internally, the rate is stored as a value in the range
+ * [INPUT_RATE_MIN, INPUT_RATE_MAX].
+ * internal rate = INPUT_RATE_DEFAULT / rate variable
+ */
+
+/**
+ * Default rate value
+ */
+#define INPUT_RATE_DEFAULT  1000
+/**
+ * Minimal rate value
+ */
+#define INPUT_RATE_MIN        32            /* Up to 32/1 */
+/**
+ * Maximal rate value
+ */
+#define INPUT_RATE_MAX     32000            /* Up to 1/32 */
+
+/**
+ * Input events
+ *
+ * You can catch input event by adding a callback on the variable "intf-event".
+ * This variable is an integer that will hold a input_event_type_e value.
+ */
+typedef enum input_event_type_e
+{
+    /* "state" has changed */
+    INPUT_EVENT_STATE,
+    /* b_dead is true */
+    INPUT_EVENT_DEAD,
+    /* a *user* abort has been requested */
+    INPUT_EVENT_ABORT,
+
+    /* "rate" has changed */
+    INPUT_EVENT_RATE,
+
+    /* At least one of "position" or "time" */
+    INPUT_EVENT_POSITION,
+
+    /* "length" has changed */
+    INPUT_EVENT_LENGTH,
+
+    /* A title has been added or removed or selected.
+     * It imply that chapter has changed (not chapter event is sent) */
+    INPUT_EVENT_TITLE,
+    /* A chapter has been added or removed or selected. */
+    INPUT_EVENT_CHAPTER,
+
+    /* A program ("program") has been added or removed or selected,
+     * or "program-scrambled" has changed.*/
+    INPUT_EVENT_PROGRAM,
+    /* A ES has been added or removed or selected */
+    INPUT_EVENT_ES,
+    /* "teletext-es" has changed */
+    INPUT_EVENT_TELETEXT,
+
+    /* "record" has changed */
+    INPUT_EVENT_RECORD,
+
+    /* input_item_t media has changed */
+    INPUT_EVENT_ITEM_META,
+    /* input_item_t info has changed */
+    INPUT_EVENT_ITEM_INFO,
+    /* input_item_t name has changed */
+    INPUT_EVENT_ITEM_NAME,
+    /* input_item_t epg has changed */
+    INPUT_EVENT_ITEM_EPG,
+
+    /* Input statistics have been updated */
+    INPUT_EVENT_STATISTICS,
+    /* At least one of "signal-quality" or "signal-strength" has changed */
+    INPUT_EVENT_SIGNAL,
+
+    /* "audio-delay" has changed */
+    INPUT_EVENT_AUDIO_DELAY,
+    /* "spu-delay" has changed */
+    INPUT_EVENT_SUBTITLE_DELAY,
+
+    /* "bookmark" has changed */
+    INPUT_EVENT_BOOKMARK,
+
+    /* cache" has changed */
+    INPUT_EVENT_CACHE,
+
+    /* A audio_output_t object has been created/deleted by *the input* */
+    INPUT_EVENT_AOUT,
+    /* A vout_thread_t object has been created/deleted by *the input* */
+    INPUT_EVENT_VOUT,
+
+} input_event_type_e;
+
+/**
+ * Input queries
+ */
+enum input_query_e
+{
+    /* input variable "position" */
+    INPUT_GET_POSITION,         /* arg1= double *       res=    */
+    INPUT_SET_POSITION,         /* arg1= double         res=can fail    */
+
+    /* input variable "length" */
+    INPUT_GET_LENGTH,           /* arg1= int64_t *      res=can fail    */
+
+    /* input variable "time" */
+    INPUT_GET_TIME,             /* arg1= int64_t *      res=    */
+    INPUT_SET_TIME,             /* arg1= int64_t        res=can fail    */
+
+    /* input variable "rate" (nominal is INPUT_RATE_DEFAULT) */
+    INPUT_GET_RATE,             /* arg1= int *          res=    */
+    INPUT_SET_RATE,             /* arg1= int            res=can fail    */
+
+    /* input variable "state" */
+    INPUT_GET_STATE,            /* arg1= int *          res=    */
+    INPUT_SET_STATE,            /* arg1= int            res=can fail    */
+
+    /* input variable "audio-delay" and "sub-delay" */
+    INPUT_GET_AUDIO_DELAY,      /* arg1 = int* res=can fail */
+    INPUT_SET_AUDIO_DELAY,      /* arg1 = int  res=can fail */
+    INPUT_GET_SPU_DELAY,        /* arg1 = int* res=can fail */
+    INPUT_SET_SPU_DELAY,        /* arg1 = int  res=can fail */
+
+    /* Meta datas */
+    INPUT_ADD_INFO,   /* arg1= char* arg2= char* arg3=...     res=can fail */
+    INPUT_REPLACE_INFOS,/* arg1= info_category_t *            res=cannot fail */
+    INPUT_MERGE_INFOS,/* arg1= info_category_t *              res=cannot fail */
+    INPUT_GET_INFO,   /* arg1= char* arg2= char* arg3= char** res=can fail */
+    INPUT_DEL_INFO,   /* arg1= char* arg2= char*              res=can fail */
+    INPUT_SET_NAME,   /* arg1= char* res=can fail    */
+
+    /* Input properties */
+    INPUT_GET_VIDEO_FPS,         /* arg1= double *        res=can fail */
+
+    /* bookmarks */
+    INPUT_GET_BOOKMARK,    /* arg1= seekpoint_t *               res=can fail */
+    INPUT_GET_BOOKMARKS,   /* arg1= seekpoint_t *** arg2= int * res=can fail */
+    INPUT_CLEAR_BOOKMARKS, /* res=can fail */
+    INPUT_ADD_BOOKMARK,    /* arg1= seekpoint_t *  res=can fail   */
+    INPUT_CHANGE_BOOKMARK, /* arg1= seekpoint_t * arg2= int * res=can fail   */
+    INPUT_DEL_BOOKMARK,    /* arg1= seekpoint_t *  res=can fail   */
+    INPUT_SET_BOOKMARK,    /* arg1= int  res=can fail    */
+
+    /* titles */
+    INPUT_GET_TITLE_INFO,     /* arg1=input_title_t** arg2= int * res=can fail */
+
+    /* Attachments */
+    INPUT_GET_ATTACHMENTS, /* arg1=input_attachment_t***, arg2=int*  res=can fail */
+    INPUT_GET_ATTACHMENT,  /* arg1=input_attachment_t**, arg2=char*  res=can fail */
+
+    /* On the fly input slave */
+    INPUT_ADD_SLAVE,       /* arg1= const char * */
+    INPUT_ADD_SUBTITLE,    /* arg1= const char *, arg2=bool b_check_extension */
+
+    /* On the fly record while playing */
+    INPUT_SET_RECORD_STATE, /* arg1=bool    res=can fail */
+    INPUT_GET_RECORD_STATE, /* arg1=bool*   res=can fail */
+
+    /* ES */
+    INPUT_RESTART_ES,       /* arg1=int (-AUDIO/VIDEO/SPU_ES for the whole category) */
+
+    /* Input ressources
+     * XXX You must call vlc_object_release as soon as possible */
+    INPUT_GET_AOUT,         /* arg1=audio_output_t **              res=can fail */
+    INPUT_GET_VOUTS,        /* arg1=vout_thread_t ***, size_t *        res=can fail */
+    INPUT_GET_ES_OBJECTS,   /* arg1=int id, vlc_object_t **dec, vout_thread_t **, audio_output_t ** */
+
+    /* External clock managments */
+    INPUT_GET_PCR_SYSTEM,   /* arg1=mtime_t *, arg2=mtime_t *       res=can fail */
+    INPUT_MODIFY_PCR_SYSTEM,/* arg1=int absolute, arg2=mtime_t      res=can fail */
+};
+
+/** @}*/
+
+/*****************************************************************************
+ * Prototypes
+ *****************************************************************************/
+
+VLC_API input_thread_t * input_Create( vlc_object_t *p_parent, input_item_t *, const char *psz_log, input_resource_t * ) VLC_USED;
+#define input_Create(a,b,c,d) input_Create(VLC_OBJECT(a),b,c,d)
+
+VLC_API input_thread_t * input_CreateAndStart( vlc_object_t *p_parent, input_item_t *, const char *psz_log ) VLC_USED;
+#define input_CreateAndStart(a,b,c) input_CreateAndStart(VLC_OBJECT(a),b,c)
+
+VLC_API int input_Start( input_thread_t * );
+
+VLC_API void input_Stop( input_thread_t *, bool b_abort );
+
+VLC_API int input_Read( vlc_object_t *, input_item_t * );
+#define input_Read(a,b) input_Read(VLC_OBJECT(a),b)
+
+VLC_API int input_vaControl( input_thread_t *, int i_query, va_list  );
+
+VLC_API int input_Control( input_thread_t *, int i_query, ...  );
+
+VLC_API void input_Close( input_thread_t * );
+void input_Join( input_thread_t * );
+void input_Release( input_thread_t * );
+
+/**
+ * Get the input item for an input thread
+ *
+ * You have to keep a reference to the input or to the input_item_t until
+ * you do not need it anymore.
+ */
+VLC_API input_item_t* input_GetItem( input_thread_t * ) VLC_USED;
+
+/**
+ * It will return the current state of the input.
+ * Provided for convenience.
+ */
+static inline input_state_e input_GetState( input_thread_t * p_input )
+{
+    input_state_e state = INIT_S;
+    input_Control( p_input, INPUT_GET_STATE, &state );
+    return state;
+}
+/**
+ * It will add a new subtitle source to the input.
+ * Provided for convenience.
+ */
+static inline int input_AddSubtitle( input_thread_t *p_input, const char *psz_url, bool b_check_extension )
+{
+    return input_Control( p_input, INPUT_ADD_SUBTITLE, psz_url, b_check_extension );
+}
+
+/**
+ * Return one of the video output (if any). If possible, you should use
+ * INPUT_GET_VOUTS directly and process _all_ video outputs instead.
+ * @param p_input an input thread from which to get a video output
+ * @return NULL on error, or a video output thread pointer (which needs to be
+ * released with vlc_object_release()).
+ */
+static inline vout_thread_t *input_GetVout( input_thread_t *p_input )
+{
+     vout_thread_t **pp_vout, *p_vout;
+     size_t i_vout;
+
+     if( input_Control( p_input, INPUT_GET_VOUTS, &pp_vout, &i_vout ) )
+         return NULL;
+
+     for( size_t i = 1; i < i_vout; i++ )
+         vlc_object_release( (vlc_object_t *)(pp_vout[i]) );
+
+     p_vout = (i_vout >= 1) ? pp_vout[0] : NULL;
+     free( pp_vout );
+     return p_vout;
+}
+
+/**
+ * Return the audio output (if any) associated with an input.
+ * @param p_input an input thread
+ * @return NULL on error, or the audio output (which needs to be
+ * released with vlc_object_release()).
+ */
+static inline audio_output_t *input_GetAout( input_thread_t *p_input )
+{
+     audio_output_t *p_aout;
+     return input_Control( p_input, INPUT_GET_AOUT, &p_aout ) ? NULL : p_aout;
+}
+
+/**
+ * Returns the objects associated to an ES.
+ *
+ * You must release all non NULL object using vlc_object_release.
+ * You may set pointer of pointer to NULL to avoid retreiving it.
+ */
+static inline int input_GetEsObjects( input_thread_t *p_input, int i_id,
+                                      vlc_object_t **pp_decoder,
+                                      vout_thread_t **pp_vout, audio_output_t **pp_aout )
+{
+    return input_Control( p_input, INPUT_GET_ES_OBJECTS, i_id,
+                          pp_decoder, pp_vout, pp_aout );
+}
+
+/**
+ * \see input_clock_GetSystemOrigin
+ */
+static inline int input_GetPcrSystem( input_thread_t *p_input, mtime_t *pi_system, mtime_t *pi_delay )
+{
+    return input_Control( p_input, INPUT_GET_PCR_SYSTEM, pi_system, pi_delay );
+}
+/**
+ * \see input_clock_ChangeSystemOrigin
+ */
+static inline int input_ModifyPcrSystem( input_thread_t *p_input, bool b_absolute, mtime_t i_system )
+{
+    return input_Control( p_input, INPUT_MODIFY_PCR_SYSTEM, b_absolute, i_system );
+}
+
+/* */
+VLC_API decoder_t * input_DecoderCreate( vlc_object_t *, es_format_t *, input_resource_t * ) VLC_USED;
+VLC_API void input_DecoderDelete( decoder_t * );
+VLC_API void input_DecoderDecode( decoder_t *, block_t *, bool b_do_pace );
+
+/**
+ * This function creates a sane filename path.
+ */
+VLC_API char * input_CreateFilename( vlc_object_t *, const char *psz_path, const char *psz_prefix, const char *psz_extension ) VLC_USED;
+
+/**
+ * It creates an empty input resource handler.
+ *
+ * The given object MUST stay alive as long as the input_resource_t is
+ * not deleted.
+ */
+VLC_API input_resource_t * input_resource_New( vlc_object_t * ) VLC_USED;
+
+/**
+ * It releases an input resource.
+ */
+VLC_API void input_resource_Release( input_resource_t * );
+
+/**
+ * Forcefully destroys the video output (e.g. when the playlist is stopped).
+ */
+VLC_API void input_resource_TerminateVout( input_resource_t * );
+
+/**
+ * This function releases all resources (object).
+ */
+VLC_API void input_resource_Terminate( input_resource_t * );
+
+#endif

=== added file 'DivCity/DivCity/vlc/plugins/vlc_input_item.h'
--- DivCity/DivCity/vlc/plugins/vlc_input_item.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_input_item.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,310 @@
+/*****************************************************************************
+ * vlc_input_item.h: Core input item
+ *****************************************************************************
+ * Copyright (C) 1999-2009 VLC authors and VideoLAN
+ * $Id: 686957288e574ef911209db70178568c9ba61a39 $
+ *
+ * Authors: Christophe Massiot <massiot@via.ecp.fr>
+ *          Laurent Aimar <fenrir@via.ecp.fr>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_INPUT_ITEM_H
+#define VLC_INPUT_ITEM_H 1
+
+/**
+ * \file
+ * This file defines functions, structures and enums for input items in vlc
+ */
+
+#include <vlc_meta.h>
+#include <vlc_epg.h>
+#include <vlc_events.h>
+
+#include <string.h>
+
+/*****************************************************************************
+ * input_item_t: Describes an input and is used to spawn input_thread_t objects
+ *****************************************************************************/
+struct info_t
+{
+    char *psz_name;            /**< Name of this info */
+    char *psz_value;           /**< Value of the info */
+};
+
+struct info_category_t
+{
+    char   *psz_name;      /**< Name of this category */
+    int    i_infos;        /**< Number of infos in the category */
+    struct info_t **pp_infos;     /**< Pointer to an array of infos */
+};
+
+struct input_item_t
+{
+    VLC_GC_MEMBERS
+    int        i_id;                 /**< Identifier of the item */
+
+    char       *psz_name;            /**< text describing this item */
+    char       *psz_uri;             /**< mrl of this item */
+
+    int        i_options;            /**< Number of input options */
+    char       **ppsz_options;       /**< Array of input options */
+    uint8_t    *optflagv;            /**< Some flags of input options */
+    unsigned   optflagc;
+
+    mtime_t    i_duration;           /**< Duration in microseconds */
+
+
+    int        i_categories;         /**< Number of info categories */
+    info_category_t **pp_categories; /**< Pointer to the first info category */
+
+    int         i_es;                /**< Number of es format descriptions */
+    es_format_t **es;                /**< Es formats */
+
+    input_stats_t *p_stats;          /**< Statistics */
+    int           i_nb_played;       /**< Number of times played */
+
+    vlc_meta_t *p_meta;
+
+    int         i_epg;               /**< Number of EPG entries */
+    vlc_epg_t   **pp_epg;            /**< EPG entries */
+
+    vlc_event_manager_t event_manager;
+
+    vlc_mutex_t lock;                 /**< Lock for the item */
+
+    uint8_t     i_type;              /**< Type (file, disc, ... see input_item_type_e) */
+    bool        b_fixed_name;        /**< Can the interface change the name ?*/
+    bool        b_error_when_reading;/**< Error When Reading */
+};
+
+enum input_item_type_e
+{
+    ITEM_TYPE_UNKNOWN,
+    ITEM_TYPE_FILE,
+    ITEM_TYPE_DIRECTORY,
+    ITEM_TYPE_DISC,
+    ITEM_TYPE_CDDA,
+    ITEM_TYPE_CARD,
+    ITEM_TYPE_NET,
+    ITEM_TYPE_PLAYLIST,
+    ITEM_TYPE_NODE,
+
+    /* This one is not a real type but the number of input_item types. */
+    ITEM_TYPE_NUMBER
+};
+
+struct input_item_node_t
+{
+    input_item_t *         p_item;
+    int                    i_children;
+    input_item_node_t      **pp_children;
+    input_item_node_t      *p_parent;
+};
+
+VLC_API void input_item_CopyOptions( input_item_t *p_parent, input_item_t *p_child );
+VLC_API void input_item_SetName( input_item_t *p_item, const char *psz_name );
+
+/**
+ * Add one subitem to this item
+ *
+ * This won't hold the item, but can tell to interested third parties
+ * Like the playlist, that there is a new sub item. With this design
+ * It is not the input item's responsability to keep all the ref of
+ * the input item children.
+ *
+ * Sends a vlc_InputItemSubItemTreeAdded and a vlc_InputItemSubItemAdded event
+ */
+VLC_API void input_item_PostSubItem( input_item_t *p_parent, input_item_t *p_child );
+
+/**
+ * Start adding multiple subitems.
+ *
+ * Create a root node to hold a tree of subitems for given item
+ */
+VLC_API input_item_node_t * input_item_node_Create( input_item_t *p_input ) VLC_USED;
+
+/**
+ * Add a new child node to this parent node that will point to this subitem.
+ */
+VLC_API input_item_node_t * input_item_node_AppendItem( input_item_node_t *p_node, input_item_t *p_item );
+
+/**
+ * Add an already created node to children of this parent node.
+ */
+VLC_API void input_item_node_AppendNode( input_item_node_t *p_parent, input_item_node_t *p_child );
+
+/**
+ * Delete a node created with input_item_node_Create() and all its children.
+ */
+VLC_API void input_item_node_Delete( input_item_node_t *p_node );
+
+/**
+ * End adding multiple subitems.
+ *
+ * Sends a vlc_InputItemSubItemTreeAdded event to notify that the item pointed to
+ * by the given root node has created new subitems that are pointed to by all the
+ * children of the node.
+ *
+ * Also sends vlc_InputItemSubItemAdded event for every child under the given root node;
+ *
+ * In the end deletes the node and all its children nodes.
+ */
+VLC_API void input_item_node_PostAndDelete( input_item_node_t *p_node );
+
+
+/**
+ * Option flags
+ */
+enum input_item_option_e
+{
+    /* Allow VLC to trust the given option.
+     * By default options are untrusted */
+    VLC_INPUT_OPTION_TRUSTED = 0x2,
+
+    /* Change the value associated to an option if already present, otherwise
+     * add the option */
+    VLC_INPUT_OPTION_UNIQUE  = 0x100,
+};
+
+/**
+ * This function allows to add an option to an existing input_item_t.
+ */
+VLC_API int input_item_AddOption(input_item_t *, const char *, unsigned i_flags );
+
+/* */
+VLC_API bool input_item_HasErrorWhenReading( input_item_t * );
+VLC_API void input_item_SetMeta( input_item_t *, vlc_meta_type_t meta_type, const char *psz_val );
+VLC_API bool input_item_MetaMatch( input_item_t *p_i, vlc_meta_type_t meta_type, const char *psz );
+VLC_API char * input_item_GetMeta( input_item_t *p_i, vlc_meta_type_t meta_type ) VLC_USED;
+VLC_API char * input_item_GetName( input_item_t * p_i ) VLC_USED;
+VLC_API char * input_item_GetTitleFbName( input_item_t * p_i ) VLC_USED;
+VLC_API char * input_item_GetURI( input_item_t * p_i ) VLC_USED;
+VLC_API void input_item_SetURI( input_item_t * p_i, const char *psz_uri );
+VLC_API mtime_t input_item_GetDuration( input_item_t * p_i );
+VLC_API void input_item_SetDuration( input_item_t * p_i, mtime_t i_duration );
+VLC_API bool input_item_IsPreparsed( input_item_t *p_i );
+VLC_API bool input_item_IsArtFetched( input_item_t *p_i );
+
+#define INPUT_META( name ) \
+static inline \
+void input_item_Set ## name (input_item_t *p_input, const char *val) \
+{ \
+    input_item_SetMeta (p_input, vlc_meta_ ## name, val); \
+} \
+static inline \
+char *input_item_Get ## name (input_item_t *p_input) \
+{ \
+    return input_item_GetMeta (p_input, vlc_meta_ ## name); \
+}
+
+INPUT_META(Title)
+INPUT_META(Artist)
+INPUT_META(Genre)
+INPUT_META(Copyright)
+INPUT_META(Album)
+INPUT_META(TrackNumber)
+INPUT_META(Description)
+INPUT_META(Rating)
+INPUT_META(Date)
+INPUT_META(Setting)
+INPUT_META(URL)
+INPUT_META(Language)
+INPUT_META(NowPlaying)
+INPUT_META(Publisher)
+INPUT_META(EncodedBy)
+INPUT_META(ArtworkURL)
+INPUT_META(TrackID)
+
+#define input_item_SetTrackNum input_item_SetTrackNumber
+#define input_item_GetTrackNum input_item_GetTrackNumber
+#define input_item_SetArtURL   input_item_SetArtworkURL
+#define input_item_GetArtURL   input_item_GetArtworkURL
+
+VLC_API char * input_item_GetInfo( input_item_t *p_i, const char *psz_cat,const char *psz_name ) VLC_USED;
+VLC_API int input_item_AddInfo( input_item_t *p_i, const char *psz_cat, const char *psz_name, const char *psz_format, ... ) VLC_FORMAT( 4, 5 );
+VLC_API int input_item_DelInfo( input_item_t *p_i, const char *psz_cat, const char *psz_name );
+VLC_API void input_item_ReplaceInfos( input_item_t *, info_category_t * );
+VLC_API void input_item_MergeInfos( input_item_t *, info_category_t * );
+
+/**
+ * This function creates a new input_item_t with the provided information.
+ *
+ * XXX You may also use input_item_New or input_item_NewExt as they need
+ * less arguments.
+ */
+VLC_API input_item_t * input_item_NewWithType( const char *psz_uri, const char *psz_name, int i_options, const char *const *ppsz_options, unsigned i_option_flags, mtime_t i_duration, int i_type ) VLC_USED;
+
+/**
+ * This function creates a new input_item_t with the provided information.
+ *
+ * Provided for convenience.
+ */
+VLC_API input_item_t * input_item_NewExt( const char *psz_uri, const char *psz_name, int i_options, const char *const *ppsz_options, unsigned i_option_flags, mtime_t i_duration ) VLC_USED;
+
+/**
+ * This function creates a new input_item_t with the provided information.
+ *
+ * Provided for convenience.
+ */
+#define input_item_New( a,b ) input_item_NewExt( a, b, 0, NULL, 0, -1 )
+
+/**
+ * This function creates a new input_item_t as a copy of another.
+ */
+VLC_API input_item_t * input_item_Copy(input_item_t * ) VLC_USED;
+
+
+/******************
+ * Input stats
+ ******************/
+struct input_stats_t
+{
+    vlc_mutex_t         lock;
+
+    /* Input */
+    int64_t i_read_packets;
+    int64_t i_read_bytes;
+    float f_input_bitrate;
+    float f_average_input_bitrate;
+
+    /* Demux */
+    int64_t i_demux_read_packets;
+    int64_t i_demux_read_bytes;
+    float f_demux_bitrate;
+    float f_average_demux_bitrate;
+    int64_t i_demux_corrupted;
+    int64_t i_demux_discontinuity;
+
+    /* Decoders */
+    int64_t i_decoded_audio;
+    int64_t i_decoded_video;
+
+    /* Vout */
+    int64_t i_displayed_pictures;
+    int64_t i_lost_pictures;
+
+    /* Sout */
+    int64_t i_sent_packets;
+    int64_t i_sent_bytes;
+    float f_send_bitrate;
+
+    /* Aout */
+    int64_t i_played_abuffers;
+    int64_t i_lost_abuffers;
+};
+
+#endif

=== added file 'DivCity/DivCity/vlc/plugins/vlc_main.h'
--- DivCity/DivCity/vlc/plugins/vlc_main.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_main.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,45 @@
+/*****************************************************************************
+ * main.h: access to all program variables
+ * Declaration and extern access to LibVLC instance object.
+ *****************************************************************************
+ * Copyright (C) 1999, 2000, 2001, 2002, 2008 VLC authors and VideoLAN
+ *
+ * Authors: Vincent Seguin <seguin@via.ecp.fr>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+/**
+ * \file
+ * This file defines libvlc_int_t internal libvlc instance
+ */
+
+TYPEDEF_ARRAY(input_item_t*, input_item_array_t)
+
+struct hotkey;
+
+/*****************************************************************************
+ * libvlc_internal_instance_t
+ *****************************************************************************
+ * This structure is a LibVLC instance, for use by libvlc core and plugins
+ *****************************************************************************/
+struct libvlc_int_t
+{
+    VLC_COMMON_MEMBERS
+
+    /* Structure storing the action name / key associations */
+    const struct hotkey *p_hotkeys;
+};
+

=== added file 'DivCity/DivCity/vlc/plugins/vlc_md5.h'
--- DivCity/DivCity/vlc/plugins/vlc_md5.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_md5.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,59 @@
+/*****************************************************************************
+ * vlc_md5.h: MD5 hash
+ *****************************************************************************
+ * Copyright Â© 2004-2011 VLC authors and VideoLAN
+ *
+ * Authors: RÃ©mi Denis-Courmont
+ *          RafaÃ«l CarrÃ©
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_MD5_H
+# define VLC_MD5_H
+
+/**
+ * \file
+ * This file defines functions and structures to compute MD5 digests
+ */
+
+struct md5_s
+{
+    uint32_t A, B, C, D;          /* chaining variables */
+    uint32_t nblocks;
+    uint8_t buf[64];
+    int count;
+};
+
+VLC_API void InitMD5( struct md5_s * );
+VLC_API void AddMD5( struct md5_s *, const void *, size_t );
+VLC_API void EndMD5( struct md5_s * );
+
+/**
+ * Returns a char representation of the md5 hash, as shown by UNIX md5 or
+ * md5sum tools.
+ */
+static inline char * psz_md5_hash( struct md5_s *md5_s )
+{
+    char *psz = malloc( 33 ); /* md5 string is 32 bytes + NULL character */
+    if( likely(psz) )
+    {
+        for( int i = 0; i < 16; i++ )
+            sprintf( &psz[2*i], "%02"PRIx8, md5_s->buf[i] );
+    }
+    return psz;
+}
+
+#endif

=== added file 'DivCity/DivCity/vlc/plugins/vlc_media_library.h'
--- DivCity/DivCity/vlc/plugins/vlc_media_library.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_media_library.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,1272 @@
+/*****************************************************************************
+ * vlc_media_library.h: SQL-based media library
+ *****************************************************************************
+ * Copyright (C) 2008-2010 the VideoLAN Team and AUTHORS
+ * $Id: 2529dd51c1c6b95061828b21b3ea0d0daf81710b $
+ *
+ * Authors: Antoine Lejeune <phytos@videolan.org>
+ *          Jean-Philippe AndrÃ© <jpeg@videolan.org>
+ *          RÃ©mi Duraffort <ivoire@videolan.org>
+ *          Adrien Maglo <magsoft@videolan.org>
+ *          Srikanth Raju <srikiraju at gmail dot com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_MEDIA_LIBRARY_H
+# define VLC_MEDIA_LIBRARY_H
+
+# ifdef __cplusplus
+extern "C" {
+# endif
+
+#include <vlc_common.h>
+#include <vlc_playlist.h>
+
+/*****************************************************************************
+ * ML Enums
+ *****************************************************************************/
+
+#define ML_PERSON_ARTIST        "Artist"
+#define ML_PERSON_ALBUM_ARTIST  "Album Artist"
+#define ML_PERSON_ENCODER       "Encoder"
+#define ML_PERSON_PUBLISHER     "Publisher"
+
+
+#define ml_priv( gc, t ) ((t *)(((char *)(gc)) - offsetof(t, ml_gc_data)))
+
+/** List of Query select types.
+ * In a query array or variable argument list, each select type is followed
+ * by an argument (X) of variable type (char* or int, @see ml_element_t).
+ * These types can be used either in the query list or in the result array.
+ * Some types are reserved for the result array:
+ */
+typedef enum
+{
+    ML_ALBUM = 1,              /**< Album Title */
+    ML_ALBUM_ID,               /**< Album ID */
+    ML_ALBUM_COVER,            /**< Album Cover art url */
+    /* FIXME: Remove ML_ARTIST */
+    ML_ARTIST,                 /**< Artist, interpreted as ML_PEOPLE
+                                    && ML_PEOPLE_ROLE = ML_PERSON_ARTIST */
+    ML_ARTIST_ID,              /**< Artist ID, interpreted as ML_PEOPLE_ID
+                                    && ML_PEOPLE_ROLE = ML_PERSON_ARTIST */
+    ML_COMMENT,                /**< Comment about media */
+    ML_COUNT_MEDIA,            /**< Number of medias */
+    ML_COUNT_ALBUM,            /**< Number of albums */
+    ML_COUNT_PEOPLE,           /**< Number of people */
+    ML_COVER,                  /**< Cover art url */
+    ML_DURATION,               /**< Duration in ms */
+    ML_DISC_NUMBER,            /**< Disc number of the track */
+    ML_EXTRA,                  /**< Extra/comment (string) on the media */
+    ML_FIRST_PLAYED,           /**< First time media was played */
+    ML_FILESIZE,               /**< Size of the media file */
+    ML_GENRE,                  /**< Genre of the media (if any) */
+    ML_ID,                     /**< Media ID */
+    ML_IMPORT_TIME,            /**< Date when media was imported */
+    ML_LANGUAGE,               /**< Language */
+    ML_LAST_PLAYED,            /**< Last play UNIX timestamp */
+    ML_LAST_SKIPPED,           /**< Time when media was last skipped */
+    ML_ORIGINAL_TITLE,         /**< Media original title (if any) */
+    ML_PEOPLE,                 /**< Any People associated with this media */
+    ML_PEOPLE_ID,              /**< Id of a person */
+    ML_PEOPLE_ROLE,            /**< Person role */
+    ML_PLAYED_COUNT,           /**< Media play count */
+    ML_PREVIEW,                /**< Url of the video preview */
+    ML_SKIPPED_COUNT,          /**< Number of times skipped */
+    ML_SCORE,                  /**< Computed media score */
+    ML_TITLE,                  /**< Media title */
+    ML_TRACK_NUMBER,           /**< Media track number (if any) */
+    ML_TYPE,                   /**< Media type. @see ml_type_e */
+    ML_URI,                    /**< Media full URI. */
+    ML_VOTE,                   /**< Media user vote value */
+    ML_YEAR,                   /**< Media publishing year */
+    ML_DIRECTORY,              /**< Monitored directory */
+    ML_MEDIA,                  /**< Full media descriptor. @see ml_media_t */
+    ML_MEDIA_SPARSE,           /**< Sparse media. @see ml_media_t */
+    ML_MEDIA_EXTRA,            /**< Sparse + Extra = Full media */
+
+    /* Some special elements */
+    ML_LIMIT     = -1,         /**< Limit a query to X results */
+    ML_SORT_DESC = -2,         /**< Sort a query descending on argument X */
+    ML_SORT_ASC  = -3,         /**< Sort a query ascending on argument X */
+    ML_DISTINCT  = -4,         /**< Add DISTINCT to SELECT statements. */
+    ML_END       = -42         /**< End of argument list */
+} ml_select_e;
+
+/** Media types (audio, video, etc...) */
+typedef enum
+{
+    ML_UNKNOWN   = 0,       /**< Unknown media type */
+    ML_AUDIO     = 1 << 0,  /**< Audio only media */
+    ML_VIDEO     = 1 << 1,  /**< Video media. May contain audio channels */
+    ML_STREAM    = 1 << 2,  /**< Streamed media = not a local file */
+    ML_NODE      = 1 << 3,  /**< Nodes like simple nodes, directories, playlists, etc */
+    ML_REMOVABLE = 1 << 4,  /**< Removable media: CD/DVD/Card/... */
+} ml_type_e;
+
+/** Query result item/list type: integers, strings, medias, timestamps */
+typedef enum {
+    ML_TYPE_INT,        /**< Object is an int */
+    ML_TYPE_PSZ,        /**< A string char* */
+    ML_TYPE_TIME,       /**< A timestamp mtime_t */
+    ML_TYPE_MEDIA,      /**< A pointer to a media ml_media_t* */
+} ml_result_type_e;
+
+/** Arguments for VLC Control for the media library */
+typedef enum
+{
+    ML_SET_DATABASE,      /**< arg1 = char *psz_host
+                               arg2 = int i_port
+                               arg3 = char *psz_user
+                               arg4 = char *psz_pass */
+    ML_INIT_DATABASE,     /**< No arg */
+    ML_ADD_INPUT_ITEM,    /**< arg1 = input_item_t* */
+    ML_ADD_PLAYLIST_ITEM, /**< arg1 = playlist_item_t * */
+    ML_ADD_MONITORED,     /**< arg1 = char* */
+    ML_DEL_MONITORED,     /**< arg1 = char* */
+    ML_GET_MONITORED,     /**< arg1 = vlc_array_t* */
+} ml_control_e;
+
+/* Operations that can be specified between find conditions */
+typedef enum
+{
+    ML_OP_NONE = 0,       /**< This is to specify an actual condition */
+    ML_OP_AND,            /**< AND condition */
+    ML_OP_OR,             /**< OR condition */
+    ML_OP_NOT,            /**< NOT condition */
+    ML_OP_SPECIAL         /**< This is for inclusion of
+                            *  special stuffs like LIMIT */
+} ml_op_e;
+
+/* Comparison operators used in a single find condition */
+typedef enum
+{
+    ML_COMP_NONE = 0,
+    ML_COMP_LESSER,              ///< <
+    ML_COMP_LESSER_OR_EQUAL,     ///< <=
+    ML_COMP_EQUAL,               ///< ==
+    ML_COMP_GREATER_OR_EQUAL,    ///< >=
+    ML_COMP_GREATER,             ///< >
+    ML_COMP_HAS,                 ///< "Contains", equivalent to SQL "LIKE %x%"
+    ML_COMP_STARTS_WITH,         ///< Equivalent to SQL "LIKE %x"
+    ML_COMP_ENDS_WITH,           ///< Equivalent to SQL "LIKE x%"
+} ml_comp_e;
+
+/*****************************************************************************
+ * ML Structures and types
+ *****************************************************************************/
+
+typedef struct media_library_t media_library_t;
+typedef struct media_library_sys_t media_library_sys_t;
+
+typedef struct ml_media_t      ml_media_t;
+typedef struct ml_result_t     ml_result_t;
+typedef struct ml_element_t    ml_element_t;
+typedef struct ml_person_t     ml_person_t;
+typedef struct ml_ftree_t      ml_ftree_t;
+
+
+typedef struct ml_gc_object_t
+{
+    vlc_spinlock_t spin;
+    bool           pool;
+    uintptr_t      refs;
+    void          (*pf_destructor) (struct ml_gc_object_t *);
+} ml_gc_object_t;
+
+#define ML_GC_MEMBERS ml_gc_object_t ml_gc_data;
+
+/** Main structure of the media library. VLC object. */
+struct media_library_t
+{
+    VLC_COMMON_MEMBERS
+
+    module_t             *p_module;  /**< the media library module */
+    media_library_sys_t  *p_sys;     /**< internal struture */
+
+    /** Member functions */
+    struct
+    {
+        /**< Search in the database */
+        int ( * pf_Find )            ( media_library_t *p_media_library,
+                                       vlc_array_t *p_result_array,
+                                       va_list args );
+
+        /**< Search in the database using an array of arguments */
+        int ( * pf_FindAdv )         ( media_library_t *p_media_library,
+                                       vlc_array_t *p_result_array,
+                                       ml_select_e selected_type,
+                                       const char *psz_lvalue,
+                                       ml_ftree_t *tree );
+
+        /**< Update the database using an array of arguments */
+        int ( * pf_Update )          ( media_library_t *p_media_library,
+                                       ml_select_e selected_type,
+                                       const char *psz_lvalue,
+                                       ml_ftree_t *where,
+                                       vlc_array_t *changes );
+
+        /**< Delete many medias in the database */
+        int ( * pf_Delete )    ( media_library_t *p_media_library,
+                                       vlc_array_t *p_array );
+
+        /**< Control the media library */
+        int ( * pf_Control ) ( media_library_t *p_media_library,
+                               int i_query, va_list args );
+
+        /**< Create associated input item */
+        input_item_t* ( * pf_InputItemFromMedia ) (
+                    media_library_t *p_media_library, int i_media );
+
+        /**< Get a media */
+        ml_media_t* ( * pf_GetMedia ) (
+                    media_library_t *p_media_library, int i_media,
+                    ml_select_e select, bool reload );
+    } functions;
+};
+
+
+/**
+ * @brief Structure to describe a media
+ *
+ * This is the main structure holding the meta data in ML.
+ * @see b_sparse indicates whether the media struct has valid values
+ * in its Extra fields. Otherwise, it must be loaded with the API
+ * function.
+ * @see i_id indicates whether this struct is saved in the ML if i_id > 0
+ * Otherwise, it can be added to the database
+ */
+struct ml_media_t
+{
+    ML_GC_MEMBERS
+    vlc_mutex_t     lock;               /**< Mutex for multithreaded access */
+    bool            b_sparse;           /**< Specifies if media is loaded fully */
+    ml_type_e       i_type;             /**< Type of the media (ml_type_e) */
+    int8_t          i_vote;             /**< User vote */
+    int16_t         i_disc_number;      /**< Disc number of media */
+    int16_t         i_track_number;     /**< Track number */
+    int16_t         i_year;             /**< Year of release */
+    int32_t         i_id;               /**< Media ID in the database */
+    int32_t         i_score;            /**< Score computed about the media */
+    int32_t         i_album_id;         /**< Album id */
+    int32_t         i_played_count;     /**< How many time the media was played */
+    int32_t         i_skipped_count;    /**< No. of times file was skipped */
+    int32_t         i_bitrate;          /**< Extra: Bitrate of the media */
+    int32_t         i_samplerate;       /**< Extra: Samplerate of the media */
+    int32_t         i_bpm;              /**< Extra: Beats per minute */
+    char            *psz_uri;           /**< URI to find the media */
+    char            *psz_title;         /**< Title of the media */
+    char            *psz_orig_title;    /**< Original title (mainly for movies) */
+    char            *psz_album;         /**< Name of the album */
+    char            *psz_cover;         /**< URI of the cover */
+    char            *psz_genre;         /**< Genre of the media */
+    char            *psz_preview;       /**< Preview thumbnail for video, if any */
+    char            *psz_comment;       /**< Comment or description about media */
+    char            *psz_language;      /**< Extra: Language */
+    char            *psz_extra;         /**< Extra: Some extra datas like lyrics */
+    ml_person_t     *p_people;          /**< Extra: People associated with this
+                                             media This meta holds only one
+                                             artist if b_sparse = true */
+    int64_t         i_filesize;         /**< Size of the file */
+    mtime_t         i_duration;         /**< Duration in microseconds */
+    mtime_t         i_last_played;      /**< Time when the media was last played */
+    mtime_t         i_last_skipped;     /**< Time when the media was last skipped */
+    mtime_t         i_first_played;     /**< First played */
+    mtime_t         i_import_time;      /**< Time when media was added */
+
+};
+
+
+/**
+ * @brief Main communication struct between GUI and sql_media_library.
+ * Generic representation of an ML/SQL query result.
+ */
+struct ml_result_t
+{
+    int32_t          id;        /**< Media/Album/Artist... ID (if any) */
+    ml_result_type_e type;      /**< Type of value */
+    union
+    {
+        /* Classical results */
+        int             i;
+        char           *psz;
+        mtime_t         time;
+
+        /* Complex result: media descriptor */
+        ml_media_t     *p_media;
+    } value;                    /**< Value of the result obtained */
+};
+
+
+/**
+ * @brief Element of a query: criteria type/value pair
+ * Used for update and delete queries
+ */
+struct ml_element_t
+{
+    ml_select_e    criteria;    /**< SELECT criteria type. @see ml_select_e */
+    union
+    {
+        int     i;
+        char*   str;
+    } value;                    /**< SELECT criteria value (string or int) */
+    union
+    {
+        int     i;
+        char*   str;
+    } lvalue;                   /**< Refer to @see ml_ftree_t lvalue docs */
+};
+
+/**
+ * Binary tree used to parse the WHERE condition for a search
+ *
+ * Let [expr] indicate a valid expression
+ * [expr] = [expr] AND [expr], where the left and right are respective
+ * [expr] = [expr] OR [expr]
+ * [expr] = [expr] NOT [NULL]
+ * [expr] = [expr] SPEC [spec_expr]
+ * [expr] = [criteria=val]
+ * [spec_expr] = [DISTINCT/LIMIT/ASC/DESC = val ]
+ */
+struct ml_ftree_t
+{
+    ml_op_e         op;         /**< Operator. ML_OP_NONE means this is a leaf
+                                  *  node. Criteria and value gives its data.
+                                  *  ML_OP_SPECIAL specifies a special node
+                                  *  that does not form a part of the WHERE.
+                                  *  The right node consists of the data
+                                  *  with its criteria set to the special val
+                                  *  and the left node is the corresponding
+                                  *  subtree of the parent node.
+                                  *  ML_OP_NOT only left sub tree is considered
+                                  *  ML_OP_AND and ML_OP_OR consider both
+                                  *  left and right subtrees */
+    ml_ftree_t      *left;      /**< Left child of Bin tree */
+    ml_ftree_t      *right;     /**< Right child of Bin tree */
+    ml_select_e     criteria;   /**< SELECT criteria type @see ml_select_e
+                                  *  The criteria value is considered only when
+                                  *  op = ML_OP_NONE i.e. in leaf nodes */
+    ml_comp_e       comp;       /**< Condition between type and value */
+    union
+    {
+        int     i;
+        char    *str;
+    } value;                    /**< SELECT criteria value ( string or int ) */
+    union
+    {
+        int     i;
+        char    *str;
+    } lvalue;                   /**< Used as key value for people types/roles.
+                                     An empty string "" denotes ANY person role.
+                                     NULL is used for all other criterias */
+};
+
+
+/**
+ * Person class. Implemented as a linked list
+ */
+struct ml_person_t
+{
+    char               *psz_role;   /**< Type of person */
+    char               *psz_name;   /**< Name of the person */
+    int                 i_id;       /**< ID in the database */
+    ml_person_t        *p_next;     /**< Next person in list */
+};
+
+
+/*****************************************************************************
+ * ML Function headers
+ *****************************************************************************/
+
+/**
+ * @brief Acquire a reference to the media library singleton
+ * @param p_this The object holding the media library
+ * @return The media library object. NULL if the media library
+ * object could not be loaded
+ */
+VLC_API media_library_t* ml_Get( vlc_object_t* p_this );
+#define ml_Get( a ) ml_Get( VLC_OBJECT(a) )
+
+/**
+ * @brief Create a Media Library VLC object.
+ * @param p_this Parent to attach the ML object to.
+ * @param psz_name Name for the module
+ * @return The ML object.
+ */
+VLC_API media_library_t* ml_Create( vlc_object_t *p_this, char* psz_name );
+
+/**
+ * @brief Destructor for the Media library singleton
+ * @param p_this Parent the ML object is attached to
+ */
+VLC_API void ml_Destroy( vlc_object_t* p_this );
+
+/**
+ * @brief Control the Media Library
+ * @param p_media_library the media library object
+ * @param i_type one of ml_control_e values @see ml_control_e.
+ * @param ... optional arguments.
+ * @return VLC_SUCCESS or an error
+ */
+static inline int ml_ControlVa( media_library_t *p_media_library,
+                                ml_control_e i_type, va_list args )
+{
+    return p_media_library->functions.pf_Control( p_media_library,
+                                                  i_type,
+                                                  args );
+}
+
+/**
+ * @brief Control the Media Library
+ * @param i_type one of ml_control_e values @see ml_control_e.
+ * Variable arguments list equivalent
+ */
+#define ml_Control( a, b, args... )     __ml_Control( a, b, ## args )
+static inline int __ml_Control( media_library_t *p_media_library,
+                                ml_control_e i_type, ... )
+{
+    va_list args;
+    int returned;
+
+    va_start( args, i_type );
+    returned = ml_ControlVa( p_media_library, i_type, args );
+    va_end( args );
+
+    return returned;
+}
+
+/**
+ * @brief Determine an attribute's type (int or string)
+ * @param meta Attribute to test @see ml_select_e
+ * @return -1 if invalid, 0 if this is an integer, 1 if this is a string
+ */
+static inline int ml_AttributeIsString( ml_select_e meta )
+{
+    switch( meta )
+    {
+    /* Strings */
+    case ML_ALBUM:
+    case ML_ARTIST:
+    case ML_COMMENT:
+    case ML_COVER:
+    case ML_EXTRA:
+    case ML_GENRE:
+    case ML_LANGUAGE:
+    case ML_PREVIEW:
+    case ML_PEOPLE:
+    case ML_PEOPLE_ROLE:
+    case ML_ORIGINAL_TITLE:
+    case ML_TITLE:
+    case ML_URI:
+        return 1;
+
+    /* Integers */
+    case ML_ALBUM_ID:
+    case ML_ARTIST_ID:
+    case ML_DURATION:
+    case ML_DISC_NUMBER:
+    case ML_COUNT_MEDIA:
+    case ML_COUNT_ALBUM:
+    case ML_COUNT_PEOPLE:
+    case ML_FILESIZE:
+    case ML_FIRST_PLAYED:
+    case ML_ID:
+    case ML_IMPORT_TIME:
+    case ML_LAST_PLAYED:
+    case ML_LIMIT:
+    case ML_PLAYED_COUNT:
+    case ML_PEOPLE_ID:
+    case ML_SCORE:
+    case ML_SKIPPED_COUNT:
+    case ML_TRACK_NUMBER:
+    case ML_TYPE:
+    case ML_VOTE:
+    case ML_YEAR:
+        return 0;
+
+    /* Invalid or no following value (in a SELECT statement) */
+    default:
+        return -1;
+    }
+}
+
+/* Reference Counting Functions */
+/**
+ * @brief Increment reference count of media
+ * @param p_media The media object
+ */
+static inline void ml_gc_incref( ml_media_t* p_media )
+{
+    ml_gc_object_t* p_gc = &p_media->ml_gc_data;
+    if( p_gc == NULL )
+        return;
+
+    vlc_spin_lock (&p_gc->spin);
+    ++p_gc->refs;
+    vlc_spin_unlock (&p_gc->spin);
+}
+
+/**
+ * @brief Decrease reference count of media
+ * @param p_media The media object
+ */
+static inline void ml_gc_decref( ml_media_t* p_media )
+{
+    /* The below code is from vlc_release(). */
+    unsigned refs;
+    bool pool;
+    ml_gc_object_t* p_gc = &p_media->ml_gc_data;
+    if( p_gc == NULL )
+        return;
+
+    vlc_spin_lock (&p_gc->spin);
+    refs = --p_gc->refs;
+    pool = p_gc->pool;
+    vlc_spin_unlock (&p_gc->spin);
+
+    if( refs == 0 && !pool )
+    {
+        vlc_spin_destroy (&p_gc->spin);
+        p_gc->pf_destructor (p_gc);
+    }
+}
+
+/*****************************************************************************
+ * ML Free Functions
+ *****************************************************************************/
+
+/**
+ * @brief Free a person object
+ * @param p_media Person object to free
+ * @note This function is NOT threadsafe
+ */
+static inline void ml_FreePeople( ml_person_t *p_person )
+{
+    if( p_person == NULL )
+        return;
+    ml_FreePeople( p_person->p_next );
+    free( p_person->psz_name );
+    free( p_person->psz_role );
+    free( p_person );
+}
+
+/**
+ * @brief Free only the content of a media. @see ml_media_t
+ * @param p_media Media object
+ * @note This function is NOT threadsafe.
+ */
+static inline void ml_FreeMediaContent( ml_media_t *p_media )
+{
+    free( p_media->psz_uri );
+    free( p_media->psz_title );
+    free( p_media->psz_orig_title );
+    free( p_media->psz_cover );
+    free( p_media->psz_comment );
+    free( p_media->psz_extra );
+    free( p_media->psz_genre );
+    free( p_media->psz_album );
+    free( p_media->psz_preview );
+    free( p_media->psz_language );
+    ml_FreePeople( p_media->p_people );
+    p_media->b_sparse = true;
+    p_media->i_id = 0;
+    p_media->i_type = ML_UNKNOWN;
+    p_media->i_album_id = 0;
+    p_media->i_disc_number = 0;
+    p_media->i_track_number = 0;
+    p_media->i_year = 0;
+    p_media->i_vote = 0;
+    p_media->i_score = 0;
+    p_media->i_filesize = 0;
+    p_media->i_duration = 0;
+    p_media->i_played_count = 0;
+    p_media->i_last_played = 0;
+    p_media->i_skipped_count = 0;
+    p_media->i_last_skipped = 0;
+    p_media->i_first_played = 0;
+    p_media->i_import_time = 0;
+    p_media->i_bitrate = 0;
+    p_media->i_samplerate = 0;
+    p_media->i_bpm = 0;
+}
+
+/**
+ * @brief Free a result item. @see ml_result_t
+ * @param p_result Result item to free
+ * @note This will free any strings and decref medias.
+ */
+static inline void ml_FreeResult( ml_result_t *p_result )
+{
+    if( p_result )
+    {
+        switch( p_result->type )
+        {
+            case ML_TYPE_PSZ:
+                free( p_result->value.psz );
+                break;
+            case ML_TYPE_MEDIA:
+                ml_gc_decref( p_result->value.p_media );
+                break;
+            default:
+                break;
+        }
+        free( p_result );
+    }
+}
+
+
+/**
+ * @brief Free a ml_element_t item.
+ * @param p_find Find object to free
+ * @see ml_element_t */
+static inline void ml_FreeElement( ml_element_t *p_elt )
+{
+    if( p_elt )
+    {
+        if( ml_AttributeIsString( p_elt->criteria ) )
+        {
+            free( p_elt->value.str );
+        }
+        if( p_elt->criteria == ML_PEOPLE )
+        {
+            free( p_elt->lvalue.str );
+        }
+        free( p_elt );
+    }
+}
+
+
+/**
+ * @brief Destroy a vlc_array_t of ml_result_t
+ * @param ml_result_array The result array to free
+ * @note Frees all results and contents of the results
+ */
+static inline void ml_DestroyResultArray( vlc_array_t *p_result_array )
+{
+    for( int i = 0; i < vlc_array_count( p_result_array ); i++ )
+    {
+        ml_FreeResult( ( ml_result_t* ) vlc_array_item_at_index(
+                p_result_array, i ) );
+    }
+}
+
+
+
+/*****************************************************************************
+ * ML Object Management Functions
+ *****************************************************************************/
+
+/** Helpers for locking and unlocking */
+#define ml_LockMedia( a )      vlc_mutex_lock( &a->lock )
+#define ml_UnlockMedia( a )    vlc_mutex_unlock( &a->lock )
+
+/**
+ * @brief Object constructor for ml_media_t
+ * @param p_ml The media library object
+ * @param id If 0, this item isn't in database. If non zero, it is and
+ * it will be a singleton
+ * @param select Type of object
+ * @param reload Whether to reload from database
+ */
+VLC_API ml_media_t *media_New( media_library_t* p_ml, int id,
+        ml_select_e select, bool reload );
+
+
+/* Forward declaration */
+static inline int ml_CopyPersons( ml_person_t** a, ml_person_t* b );
+
+/**
+ * @brief Copy all members of a ml_media_t to another.
+ * @param b Destination media, already allocated
+ * @param a Source media, cannot be NULL, const
+ * @note This does not check memory allocation (for strdup). It is threadsafe
+ * @todo Free b content, before inserting a?
+ */
+static inline int ml_CopyMedia( ml_media_t *b, ml_media_t *a )
+{
+    if( !a || !b ) return VLC_EGENERIC;
+    if( a == b ) return VLC_SUCCESS;
+    ml_LockMedia( a );
+    ml_LockMedia( b );
+    b->b_sparse = a->b_sparse;
+    b->i_id = a->i_id;
+    b->i_type = a->i_type;
+    b->i_album_id = a->i_album_id;
+    b->i_disc_number = a->i_disc_number;
+    b->i_track_number = a->i_track_number;
+    b->i_year = a->i_year;
+    b->i_vote = a->i_vote;
+    b->i_score = a->i_score;
+    b->i_filesize = a->i_filesize;
+    b->i_duration = a->i_duration;
+    b->i_played_count = a->i_played_count;
+    b->i_last_played = a->i_last_played;
+    b->i_skipped_count = a->i_skipped_count;
+    b->i_last_skipped = a->i_last_skipped;
+    b->i_first_played = a->i_first_played;
+    b->i_import_time = a->i_import_time;
+    b->i_bitrate = a->i_bitrate;
+    b->i_samplerate = a->i_samplerate;
+    b->i_bpm = a->i_bpm;
+    free( b->psz_uri );
+    if( a->psz_uri )
+        b->psz_uri = strdup( a->psz_uri );
+    free( b->psz_title );
+    if( a->psz_title )
+        b->psz_title = strdup( a->psz_title );
+    free( b->psz_orig_title );
+    if( a->psz_orig_title )
+        b->psz_orig_title = strdup( a->psz_orig_title );
+    free( b->psz_album );
+    if( a->psz_album )
+        b->psz_album = strdup( a->psz_album );
+    free( b->psz_cover );
+    if( a->psz_cover )
+        b->psz_cover = strdup( a->psz_cover );
+    free( b->psz_genre );
+    if( a->psz_genre )
+        b->psz_genre = strdup( a->psz_genre );
+    free( b->psz_comment );
+    if( a->psz_comment )
+        b->psz_comment = strdup( a->psz_comment );
+    free( b->psz_extra );
+    if( a->psz_extra )
+        b->psz_extra = strdup( a->psz_extra );
+    free( b->psz_preview );
+    if( a->psz_preview )
+        b->psz_preview = strdup( a->psz_preview );
+    free( b->psz_language );
+    if( a->psz_language )
+        b->psz_language = strdup( a->psz_language );
+    ml_FreePeople( b->p_people );
+    if( a->p_people )        ml_CopyPersons( &( b->p_people ), a->p_people );
+    ml_UnlockMedia( b );
+    ml_UnlockMedia( a );
+    return VLC_SUCCESS;
+}
+
+/*****************************************************************************
+ * ML Find Tree Related Functions
+ *****************************************************************************/
+#define ml_FreeFindTree( tree )          ml_GenericFreeFindTree( tree, true )
+#define ml_ShallowFreeFindTree( tree )   ml_GenericFreeFindTree( tree, false )
+/**
+ * @brief Free a find tree
+ * @param Find tree to free
+ * @param true to free any associated strings, false to not free them
+ */
+static inline void ml_GenericFreeFindTree( ml_ftree_t* tree, bool freestrings )
+{
+    if( tree == NULL )
+        return;
+    if( tree->left )
+    {
+        ml_GenericFreeFindTree( tree->left, freestrings );
+        free( tree->left );
+    }
+    if( tree->right )
+    {
+        ml_GenericFreeFindTree( tree->right, freestrings );
+        free( tree->right );
+    }
+    if( tree->op == ML_OP_NONE && ml_AttributeIsString( tree->criteria )
+            && freestrings)
+    {
+        free( tree->value.str );
+        if( tree->criteria == ML_PEOPLE )
+            free( tree->lvalue.str );
+    }
+}
+
+/**
+ * @brief Checks if a given find tree has leaf nodes
+ * @param Find tree
+ * @return Number of leaf nodes
+ */
+static inline int ml_FtreeHasOp( ml_ftree_t* tree )
+{
+    if( tree == NULL )
+        return 0;
+    if( tree->criteria > 0 && tree->op == ML_OP_NONE )
+        return 1;
+    else
+        return ml_FtreeHasOp( tree->left ) + ml_FtreeHasOp( tree->right );
+}
+
+
+/**
+ * @brief Connect up a find tree
+ * @param op operator to connect with
+ * If op = ML_OP_NONE, then you are connecting to a tree consisting of
+ * only SPECIAL nodes.
+ * If op = ML_OP_NOT, then right MUST be NULL
+ * op must not be ML_OP_SPECIAL, @see ml_FtreeSpec
+ * @param left part of the tree
+ * @param right part of the tree
+ * @return Pointer to new tree
+ * @note Use the helpers!
+ */
+VLC_API ml_ftree_t *ml_OpConnectChilds( ml_op_e op, ml_ftree_t* left,
+        ml_ftree_t* right );
+
+/**
+ * @brief Attaches a special node to a tree
+ * @param tree Tree to attach special node to
+ * @param crit Criteria may be SORT_ASC, SORT_DESC, LIMIT or DISTINCT
+ * @param limit Limit used if LIMIT criteria used
+ * @param Sort string used if SORT criteria is used
+ * @return Pointer to new tree
+ * @note Use the helpers
+ */
+VLC_API ml_ftree_t *ml_FtreeSpec( ml_ftree_t* tree,
+                                          ml_select_e crit,
+                                          int limit,
+                                          char* sort );
+
+/**
+ * @brief This function gives quick sequential adding capability
+ * @param left Tree to add to. This may be NULL
+ * @param right Tree to append. May not be NULL
+ * @return Pointer to new tree.*/
+static inline ml_ftree_t* ml_FtreeFastAnd( ml_ftree_t* left,
+                                           ml_ftree_t* right )
+{
+    if( ml_FtreeHasOp( left ) == 0 )
+    {
+        return ml_OpConnectChilds( ML_OP_NONE, left, right );
+    }
+    else
+    {
+        return ml_OpConnectChilds( ML_OP_AND, left, right );
+    }
+}
+#define ml_FtreeAnd( left, right ) ml_OpConnectChilds( ML_OP_AND, left, right )
+#define ml_FtreeOr( left, right )  ml_OpConnectChilds( ML_OP_OR, left, right )
+#define ml_FtreeNot( left )        ml_OpConnectChilds( ML_OP_NOT, left, NULL )
+
+#define ml_FtreeSpecAsc( tree, str )        ml_FtreeSpec( tree, ML_SORT_ASC, 0, str )
+#define ml_FtreeSpecDesc( tree, str )       ml_FtreeSpec( tree, ML_SORT_DESC, 0, str )
+#define ml_FtreeSpecLimit( tree, limit )    ml_FtreeSpec( tree, ML_LIMIT, limit, NULL )
+#define ml_FtreeSpecDistinct( tree )        ml_FtreeSpec( tree, ML_DISTINCT, 0, NULL )
+
+
+/*****************************************************************************
+ * ML Core Functions
+ *****************************************************************************/
+
+/**
+ * @brief Create input item from media
+ * @param p_media_library This ML instance.
+ * @param i_media_id ID of the media to use to create an input_item.
+ * @return The media item.
+ */
+static inline input_item_t* ml_CreateInputItem(
+        media_library_t *p_media_library, int i_media_id )
+{
+    return p_media_library->functions.pf_InputItemFromMedia( p_media_library,
+                                                             i_media_id );
+}
+
+/**
+ * @brief Search in the database according some criterias
+ *
+ * @param p_media_library the media library object
+ * @param result a pointer to a result array
+ * @param ... parameters to select the data
+ * @return VLC_SUCCESS or an error
+ */
+static inline int __ml_Find( media_library_t *p_media_library,
+                             vlc_array_t *p_result_array, ... )
+{
+    va_list args;
+    int returned;
+
+    va_start( args, p_result_array );
+    returned = p_media_library->functions.pf_Find( p_media_library,
+                                                   p_result_array, args );
+    va_end( args );
+
+    return returned;
+}
+
+
+/**
+ * @brief Search in the database according some criterias (threaded)
+ * @param p_media_library the media library object
+ * @param result_array a pointer to a result array
+ * @param result_type type of data to retrieve
+ * @param psz_lvalue This should contain any necessary lvalue/key
+ * for the given result_type. Used for ML_PEOPLE. Otherwise NULL
+ * @param args parameters to select the data
+ * @return VLC_SUCCESS or an error
+ */
+static inline int ml_FindAdv( media_library_t *p_media_library,
+                              vlc_array_t *p_result_array,
+                              ml_select_e result_type,
+                              char* psz_lvalue,
+                              ml_ftree_t *tree )
+{
+    return p_media_library->functions.pf_FindAdv( p_media_library,
+                                                  p_result_array,
+                                                  result_type,
+                                                  psz_lvalue,
+                                                  tree );
+}
+
+
+/**
+ * @brief Find a value in the ML database, fill p_result with it.
+ * @param p_media_library Media library object
+ * @param p_result Object to put result into
+ * @param Args [ SelectType [ PersonType ] Value ] ... ML_END
+ * @note Do not use this function directly.
+ */
+static inline int __ml_GetValue( media_library_t *p_media_library,
+                                  ml_result_t *p_result,
+                                  va_list args )
+{
+    vlc_array_t *p_result_array = vlc_array_new();
+    int i_ret = p_media_library->functions.pf_Find( p_media_library,
+                                                    p_result_array,
+                                                    args );
+    if( i_ret != VLC_SUCCESS )
+        goto exit;
+    if( vlc_array_count( p_result_array ) > 0 )
+        memcpy( p_result,
+                ( ml_result_t* ) vlc_array_item_at_index( p_result_array, 0 ),
+                sizeof( ml_result_t) );
+    else
+        i_ret = VLC_EGENERIC;
+
+exit:
+    /* Note: Do not free the results, because of memcpy */
+    vlc_array_destroy( p_result_array );
+    return i_ret;
+}
+
+/**
+ * @brief Search an INTEGER in the database
+ * This uses a Query but returns only one integer (>0), or an error code.
+ *
+ * @param p_media_library the media library object
+ * @param va_args parameters to select the data
+ * @return Found INTEGER >= 0 or an error
+ */
+#define ml_GetInt( ml, ... ) __ml_GetInt( ml, __VA_ARGS__, ML_LIMIT, 1, ML_END )
+static inline int __ml_GetInt( media_library_t *p_media_library, ... )
+{
+    va_list args;
+    va_start( args, p_media_library );
+    ml_result_t result;
+    int i_ret = __ml_GetValue( p_media_library, &result, args );
+    va_end( args );
+    if( i_ret != VLC_SUCCESS )
+        return i_ret;
+    else
+        return result.value.i;
+}
+
+
+/**
+ * @brief Search a string (VARCHAR) in the database
+ * This uses a Query but returns only one integer (>0), or an error code.
+ *
+ * @param p_media_library the media library object
+ * @param va_args parameters to select the data
+ * @return Found string, or NULL if not found or in case of error
+ */
+#define ml_FindPsz( ml, ... ) __ml_GetPsz( ml, __VA_ARGS__, ML_LIMIT, 1, ML_END )
+static inline char* __ml_GetPsz( media_library_t *p_media_library, ... )
+{
+    va_list args;
+    va_start( args, p_media_library );
+    ml_result_t result;
+    int i_ret = __ml_GetValue( p_media_library, &result, args );
+    va_end( args );
+    if( i_ret != VLC_SUCCESS )
+        return NULL;
+    else
+        return result.value.psz; // no need to duplicate
+}
+
+/**
+ * @brief Generic update in Media Library database
+ *
+ * @param p_media_library the media library object
+ * @param selected_type the type of the element we're selecting
+ * @param where list of ids/uris to be changed
+ * @param changes list of changes to make in the entries
+ * @return VLC_SUCCESS or VLC_EGENERIC
+ */
+static inline int ml_Update( media_library_t *p_media_library,
+                             ml_select_e selected_type,
+                             const char* psz_lvalue,
+                             ml_ftree_t *where,
+                             vlc_array_t *changes )
+{
+    return p_media_library->functions.pf_Update( p_media_library,
+                                                 selected_type, psz_lvalue,
+                                                 where, changes );
+}
+
+/**
+ * @brief Update a given table
+ * @param p_media_library The media library object
+ * @param selected_type The table to update
+ * @param psz_lvalue The role of the person if selected_type = ML_PEOPLE
+ * @param id The id of the row to update
+ * @param ... The update data. [SelectType [RoleType] Value]
+ */
+VLC_API int ml_UpdateSimple( media_library_t *p_media_library,
+                                     ml_select_e selected_type,
+                                     const char* psz_lvalue,
+                                     int id, ... );
+#define ml_UpdateSimple( ml, sel, lval, id, ... ) \
+        ml_UpdateSimple( ml, sel, lval, id, __VA_ARGS__, ML_END )
+
+/**
+ * @brief Generic DELETE function
+ * Delete a media and all its references which don't point
+ * to anything else.
+ *
+ * @param p_media_library This media_library_t object
+ * @param id the id of the media to delete
+ * @return VLC_SUCCESS or VLC_EGENERIC
+ */
+static inline int
+ml_DeleteSimple( media_library_t *p_media_library, int id )
+{
+    vlc_array_t* p_where = vlc_array_new();
+    ml_element_t* p_find = (ml_element_t *) calloc( 1, sizeof( ml_element_t ) );
+    p_find->criteria = ML_ID;
+    p_find->value.i = id;
+    vlc_array_append( p_where, p_find );
+    int i_return =  p_media_library->functions.pf_Delete( p_media_library,
+            p_where );
+    free( p_find );
+    vlc_array_destroy( p_where );
+    return i_return;
+}
+
+/**
+ * @brief Delete many medias in the media library
+ * @param p_media_library Media library object
+ * @param p_array Array of ids to delete
+ * @return VLC_SUCCESS or VLC_EGENERIC
+ */
+static inline int
+ml_Delete( media_library_t *p_media_library, vlc_array_t* p_array )
+{
+    return p_media_library->functions.pf_Delete( p_media_library,
+                                                        p_array );
+}
+
+
+/*****************************************************************************
+ * ML Person Related Functions
+ *****************************************************************************/
+
+/**
+ * @brief Create and append a person object to the given list
+ * @param pp_person pointer to person list. Set the address to null to create new list
+ * @param i_role The role of the person
+ * @param psz_name The name string. Will be strdup'd
+ * @param i_id The id in the database
+ * @note This function is NOT thread safe. Please lock any associated media
+ */
+static inline int ml_CreateAppendPersonAdv( ml_person_t **pp_person,
+        const char* psz_role, const char* psz_name, int i_id )
+{
+    if( i_id == 0 || !( psz_name && *psz_name && psz_role && *psz_role ) )
+        return VLC_SUCCESS;
+    if( !pp_person )
+        return VLC_EGENERIC;
+    if( *pp_person != NULL )
+        return ml_CreateAppendPersonAdv( &((**pp_person).p_next),
+                                         psz_role, psz_name, i_id);
+    *pp_person = ( ml_person_t * ) calloc( 1, sizeof( ml_person_t ) );
+    (*pp_person)->psz_name = (psz_name && *psz_name) ? strdup( psz_name ): NULL;
+    (*pp_person)->psz_role = (psz_role && *psz_role) ? strdup( psz_role ): NULL;
+    (*pp_person)->i_id = i_id;
+    (*pp_person)->p_next = NULL;
+    return VLC_SUCCESS;
+}
+
+/**
+ * @brief Create and append a person object to the given list
+ * @param pp_person pointer to person list.
+ * Set the address to NULL to create a new list
+ * @param personfrom Person object to copy from
+ * @note Ignores the next variable and copies only the variables.
+ * Uses ml_CreateAppendPersonAdv
+ * @note This function is NOT threadsafe
+ */
+static inline int ml_CreateAppendPerson( ml_person_t **pp_person,
+                                         ml_person_t *p_personfrom )
+{
+    return ml_CreateAppendPersonAdv( pp_person,
+                                     p_personfrom->psz_role,
+                                     p_personfrom->psz_name,
+                                     p_personfrom->i_id );
+}
+
+/**
+ * @brief Copy one person list into another
+ * @param a To list
+ * @param b From list
+ * @note On errors, you have to free any allocated persons yourself
+ * @note This function is NOT threadsafe. Please ensure your medias are locked
+ */
+static inline int ml_CopyPersons( ml_person_t** a, ml_person_t* b )
+{
+    int i_ret;
+    while( b )
+    {
+        i_ret = ml_CreateAppendPerson( a, b );
+        if( i_ret != VLC_SUCCESS )
+            return i_ret;
+        b = b->p_next;
+    }
+    return VLC_SUCCESS;
+}
+
+
+/**
+ * @brief Returns a person list of given type
+ * @param p_ml The ML object
+ * @param p_media The Media object
+ * @param i_type The person type
+ * @note This function is thread safe
+ */
+VLC_API ml_person_t *ml_GetPersonsFromMedia( media_library_t* p_ml,
+                                                    ml_media_t* p_media,
+                                                    const char *psz_role );
+
+
+#define ml_GetAlbumArtistsFromMedia( a, b ) ml_GetPersonsFromMedia( a, b, ML_PERSON_ALBUM_ARTIST );
+#define ml_GetArtistsFromMedia( a, b )      ml_GetPersonsFromMedia( a, b, ML_PERSON_ARTIST );
+#define ml_GetEncodersFromMedia( a, b )     ml_GetPersonsFromMedia( a, b, ML_PERSON_ENCODER );
+#define ml_GetPublishersFromMedia( a, b )   ml_GetPersonsFromMedia( a, b, ML_PERSON_PUBLISHER );
+
+/**
+ * @brief Delete a certain type of people from a media
+ * @param p_media Media to delete from
+ * @param i_type Type of person to delete
+ * @note This function is threadsafe
+ */
+VLC_API void ml_DeletePersonTypeFromMedia( ml_media_t* p_media,
+                                                 const char *psz_role );
+
+
+/**
+ * @brief Creates and adds the playlist based on a given find tree
+ * @param p_ml Media library object
+ * @param p_tree Find tree to create SELECT
+ */
+
+VLC_API void ml_PlaySmartPlaylistBasedOn( media_library_t* p_ml,
+                                                ml_ftree_t* p_tree );
+
+
+/**
+ * Convenience Macros
+ */
+
+/**
+ * Get information using the *media* ID. This returns only 1 information.
+ * @note You have to free the string returned (if that's a string!).
+ */
+#define ml_GetAlbumById( a, id )            ml_GetPsz( a, ML_ALBUM, ML_ID, id )
+#define ml_GetArtistById( a, id )           ml_GetPsz( a, ML_PEOPLE, ML_PERSON_ARTIST, ML_ID, id )
+#define ml_GetCoverUriById( a, id )         ml_GetPsz( a, ML_COVER, ML_ID, id )
+#define ml_GetEncoderById( a, id )          ml_GetPsz( a, ML_PEOPLE, ML_PERSON_ENCODER, ML_ID, id )
+#define ml_GetExtraById( a, id )            ml_GetPsz( a, ML_EXTRA, ML_ID, id )
+#define ml_GetGenreById( a, id )            ml_GetPsz( a, ML_GENRE, ML_ID, id )
+#define ml_GetOriginalTitleById( a, id )    ml_GetPsz( a, ML_ORIGINAL_TITLE, ML_ID, id )
+#define ml_GetPublisherById( a, id )        ml_GetPsz( a, ML_PEOPLE, ML_PERSON_PUBLISHER, ML_ID, id )
+#define ml_GetTitleById( a, id )            ml_GetPsz( a, ML_TITLE, ML_ID, id )
+#define ml_GetUriById( a, id )              ml_GetPsz( a, ML_URI, ML_ID, id )
+
+#define ml_GetAlbumIdById( a, id )          ml_GetInt( a, ML_ALBUM_ID, ML_ID, id )
+#define ml_GetArtistIdById( a, id )         ml_GetInt( a, ML_PEOPLE_ID, ML_PERSON_ARTIST, ML_ID, id )
+#define ml_GetDurationById( a, id )         ml_GetInt( a, ML_DURATION, ML_ID, id )
+#define ml_GetEncoderIdById( a, id )        ml_GetInt( a, ML_PEOPLE_ID, ML_PERSON_ENCODER, ML_ID, id )
+#define ml_GetLastPlayedById( a, id )       ml_GetInt( a, ML_LAST_PLAYED, ML_ID, id )
+#define ml_GetPlayedCountById( a, id )      ml_GetInt( a, ML_PLAYED_COUNT, ML_ID, id )
+#define ml_GetPublisherIdById( a, id )      ml_GetInt( a, ML_PEOPLE_ID, ML_PERSON_PUBLISHER, ML_ID, id )
+#define ml_GetScoreById( a, id )            ml_GetInt( a, ML_SCORE, ML_ID, id )
+#define ml_GetTrackNumberById( a, id )      ml_GetInt( a, ML_TRACK_NUMBER, ML_ID, id )
+#define ml_GetTypeById( a, id )             ml_GetInt( a, ML_TYPE, ML_ID, id )
+#define ml_GetYearById( a, id )             ml_GetInt( a, ML_YEAR, ML_ID, id )
+#define ml_GetVoteById( a, id )             ml_GetInt( a, ML_VOTE, ML_ID, id )
+
+/** Albums handling */
+#define ml_GetAlbumId( a, b )               ml_GetInt( a, ML_ALBUM_ID, ML_ALBUM, b )
+
+/** People handling */
+#define ml_GetArtistId( a, b )              ml_GetInt( a, ML_PERSON_ID, ML_PERSON_ARTIST, ML_PERSON, ML_PERSON_ARTIST, b )
+#define ml_GetEncoderId( a, b )             ml_GetInt( a, ML_PERSON_ID, ML_PERSON_ENCODER, ML_PERSON, ML_PERSON_ENCODER, b )
+#define ml_GetPublisherId( a, b )           ml_GetInt( a, ML_PERSON_ID, ML_PERSON_PUBLISHER, ML_PERSON, ML_PERSON_PUBLISHER, b )
+
+/** Counts handling */
+#define ml_GetMediaCount( a, ... )          __ml_GetInt( a, ML_COUNT_MEDIA,      __VA_ARGS__, ML_END )
+#define ml_GetAlbumCount( a, ... )          __ml_GetInt( a, ML_COUNT_ALBUM,      __VA_ARGS__, ML_END )
+#define ml_GetPeopleCount( a, ... )         __ml_GetInt( a, ML_COUNT_PEOPLE,     __VA_ARGS__, ML_END )
+
+#define ml_Find( a, b, ... )                __ml_Find( a, b, __VA_ARGS__, ML_END )
+
+#define ml_FindAlbum( a, b, ... )           __ml_Find( a, b, ML_ALBUM,           __VA_ARGS__, ML_END )
+#define ml_FindArtist( a, b, ... )          __ml_Find( a, b, ML_PERSON, ML_PERSON_ARTIST, __VA_ARGS__, ML_END )
+#define ml_FindEncoder( a, b, ... )         __ml_Find( a, b, ML_PERSON, ML_PERSON_ENCODER, __VA_ARGS__, ML_END )
+#define ml_FindGenre( a, b, ... )           __ml_Find( a, b, ML_GENRE,           __VA_ARGS__, ML_END )
+#define ml_FindMedia( a, b, ... )           __ml_Find( a, b, ML_MEDIA,           __VA_ARGS__, ML_END )
+#define ml_FindOriginalTitle( a, b, ... )   __ml_Find( a, b, ML_ORIGINAL_TITLE,  __VA_ARGS__, ML_END )
+#define ml_FindPublisher( a, b, ... )       __ml_Find( a, b, ML_PERSON, ML_PERSON_PUBLISHER, __VA_ARGS__, ML_END )
+#define ml_FindTitle( a, b, ... )           __ml_Find( a, b, ML_TITLE,           __VA_ARGS__, ML_END )
+#define ml_FindType( a, b, ... )            __ml_Find( a, b, ML_TYPE,            __VA_ARGS__, ML_END )
+#define ml_FindUri( a, b, ... )             __ml_Find( a, b, ML_URI,             __VA_ARGS__, ML_END )
+#define ml_FindYear( a, b, ... )            __ml_Find( a, b, ML_YEAR,            __VA_ARGS__, ML_END )
+
+#define ml_FindAllAlbums( a, b )            ml_FindAlbum( a, b,         ML_DISTINCT )
+#define ml_FindAllArtists( a, b )           ml_FindArtist( a, b,        ML_DISTINCT )
+#define ml_FindAllGenres( a, b )            ml_FindGenre( a, b,         ML_DISTINCT )
+#define ml_FindAllMedias( a, b )            ml_FindMedia( a, b,         ML_DISTINCT )
+#define ml_FindAllOriginalTitles( a, b )    ml_FindOriginalTitle( a, b, ML_DISTINCT )
+#define ml_FindAllPublishers( a, b, ... )   ml_FindPublisher( a, b,     ML_DISTINCT )
+#define ml_FindAllTitles( a, b )            ml_FindTitle( a, b,         ML_DISTINCT )
+#define ml_FindAllTypes( a, b )             ml_FindType( a, b,          ML_DISTINCT )
+#define ml_FindAllUris( a, b )              ml_FindUri( a, b,           ML_DISTINCT )
+#define ml_FindAllYears( a, b )             ml_FindYear( a, b,          ML_DISTINCT )
+
+#define ml_FindAlbumAdv( a, b, c )          ml_FindAdv( a, b, ML_ALBUM,         NULL, c )
+#define ml_FindArtistAdv( a, b, c )         ml_FindAdv( a, b, ML_PERSON,        ML_PERSON_ARTIST, c )
+#define ml_FindEncoderAdv( a, b, c )        ml_FindAdv( a, b, ML_PERSON,        ML_PERSON_ENCODER, c )
+#define ml_FindGenreAdv( a, b, c )          ml_FindAdv( a, b, ML_GENRE,         NULL, c )
+#define ml_FindMediaAdv( a, b, c )          ml_FindAdv( a, b, ML_MEDIA,         NULL, c )
+#define ml_FindOriginalTitleAdv( a, b, c )  ml_FindAdv( a, b, ML_ORIGINAL_TITLE,NULL, c )
+#define ml_FindPublisherAdv( a, b, c )      ml_FindAdv( a, b, ML_PUBLISHER,     ML_PERSON_PUBLISHER, c )
+#define ml_FindTitleAdv( a, b, c )          ml_FindAdv( a, b, ML_TITLE,         NULL, c )
+#define ml_FindTypeAdv( a, b, c )           ml_FindAdv( a, b, ML_TYPE,          NULL, c )
+#define ml_FindUriAdv( a, b, c )            ml_FindAdv( a, b, ML_URI,           NULL, c )
+#define ml_FindYearAdv( a, b, c )           ml_FindAdv( a, b, ML_YEAR,          NULL, c )
+
+
+
+#ifdef __cplusplus
+}
+#endif /* C++ */
+
+#endif /* VLC_MEDIA_LIBRARY_H */

=== added file 'DivCity/DivCity/vlc/plugins/vlc_messages.h'
--- DivCity/DivCity/vlc/plugins/vlc_messages.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_messages.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,197 @@
+/*****************************************************************************
+ * messages.h: messages interface
+ * This library provides basic functions for threads to interact with user
+ * interface, such as message output.
+ *****************************************************************************
+ * Copyright (C) 1999, 2000, 2001, 2002 VLC authors and VideoLAN
+ * $Id: 7a8777f56deb9859a74fed7fe5ec52365216ac95 $
+ *
+ * Authors: Vincent Seguin <seguin@via.ecp.fr>
+ *          Samuel Hocevar <sam@zoy.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_MESSAGES_H_
+#define VLC_MESSAGES_H_
+
+/**
+ * \file
+ * This file defines structures and functions to handle messages and statistics gathering
+ */
+
+#include <stdarg.h>
+
+/**
+ * \defgroup messages Messages
+ * This library provides basic functions for threads to interact with user
+ * interface, such as message output.
+ *
+ * @{
+ */
+
+/** Message types */
+enum msg_item_type
+{
+    VLC_MSG_INFO=0, /**< Important information */
+    VLC_MSG_ERR,    /**< Error */
+    VLC_MSG_WARN,   /**< Warning */
+    VLC_MSG_DBG,    /**< Debug */
+};
+
+/**
+ * Log message
+ */
+typedef struct
+{
+    uintptr_t   i_object_id; /**< Emitter (temporaly) unique object ID or 0 */
+    const char *psz_object_type; /**< Emitter object type name */
+    const char *psz_module; /**< Emitter module (source code) */
+    const char *psz_header; /**< Additional header (used by VLM media) */
+} msg_item_t;
+
+/**
+ * Used by interface plugins which subscribe to the message bank.
+ */
+typedef struct msg_subscription_t msg_subscription_t;
+
+/*****************************************************************************
+ * Prototypes
+ *****************************************************************************/
+VLC_API void vlc_Log(vlc_object_t *, int,
+                     const char *, const char *, ...) VLC_FORMAT( 4, 5 );
+VLC_API void vlc_vaLog(vlc_object_t *, int,
+                       const char *, const char *, va_list);
+#define msg_GenericVa(a, b, c, d, e) vlc_vaLog(VLC_OBJECT(a), b, c, d, e)
+
+#define msg_Info( p_this, ... ) \
+    vlc_Log( VLC_OBJECT(p_this), VLC_MSG_INFO, MODULE_STRING, __VA_ARGS__ )
+#define msg_Err( p_this, ... ) \
+    vlc_Log( VLC_OBJECT(p_this), VLC_MSG_ERR,  MODULE_STRING, __VA_ARGS__ )
+#define msg_Warn( p_this, ... ) \
+    vlc_Log( VLC_OBJECT(p_this), VLC_MSG_WARN, MODULE_STRING, __VA_ARGS__ )
+#define msg_Dbg( p_this, ... ) \
+    vlc_Log( VLC_OBJECT(p_this), VLC_MSG_DBG,  MODULE_STRING, __VA_ARGS__ )
+
+/**
+ * Message logging callback signature.
+ * Accepts one private data pointer, the message, and an overrun counter.
+ */
+typedef void (*msg_callback_t) (void *, int, const msg_item_t *,
+                                const char *, va_list);
+
+VLC_API msg_subscription_t *vlc_Subscribe(msg_callback_t, void *) VLC_USED;
+VLC_API void vlc_Unsubscribe(msg_subscription_t *);
+
+/**
+ * @}
+ */
+
+/**
+ * \defgroup statistics Statistics
+ *
+ * @{
+ */
+
+/****************************
+ * Generic stats stuff
+ ****************************/
+enum
+{
+    STATS_LAST,
+    STATS_COUNTER,
+    STATS_MAX,
+    STATS_MIN,
+    STATS_DERIVATIVE,
+    STATS_TIMER
+};
+
+struct counter_sample_t
+{
+    vlc_value_t value;
+    mtime_t     date;
+};
+
+struct counter_t
+{
+    unsigned int        i_id;
+    char              * psz_name;
+    int                 i_type;
+    void              * p_obj;
+    int                 i_compute_type;
+    int                 i_samples;
+    counter_sample_t ** pp_samples;
+
+    mtime_t             update_interval;
+    mtime_t             last_update;
+};
+
+enum
+{
+    STATS_INPUT_BITRATE,
+    STATS_READ_BYTES,
+    STATS_READ_PACKETS,
+    STATS_DEMUX_READ,
+    STATS_DEMUX_BITRATE,
+    STATS_DEMUX_CORRUPTED,
+    STATS_DEMUX_DISCONTINUITY,
+    STATS_PLAYED_ABUFFERS,
+    STATS_LOST_ABUFFERS,
+    STATS_DECODED_AUDIO,
+    STATS_DECODED_VIDEO,
+    STATS_DECODED_SUB,
+    STATS_CLIENT_CONNECTIONS,
+    STATS_ACTIVE_CONNECTIONS,
+    STATS_SOUT_SENT_PACKETS,
+    STATS_SOUT_SENT_BYTES,
+    STATS_SOUT_SEND_BITRATE,
+    STATS_DISPLAYED_PICTURES,
+    STATS_LOST_PICTURES,
+
+    STATS_TIMER_PLAYLIST_BUILD,
+    STATS_TIMER_ML_LOAD,
+    STATS_TIMER_ML_DUMP,
+    STATS_TIMER_INTERACTION,
+    STATS_TIMER_PREPARSE,
+    STATS_TIMER_INPUT_LAUNCHING,
+    STATS_TIMER_MODULE_NEED,
+    STATS_TIMER_VIDEO_FRAME_ENCODING,
+    STATS_TIMER_AUDIO_FRAME_ENCODING,
+
+    STATS_TIMER_SKINS_PLAYTREE_IMAGE,
+};
+
+/*********
+ * Timing
+ ********/
+VLC_API void stats_TimerStart(vlc_object_t*, const char *, unsigned int );
+VLC_API void stats_TimerStop(vlc_object_t*, unsigned int);
+VLC_API void stats_TimerDump(vlc_object_t*, unsigned int);
+VLC_API void stats_TimersDumpAll(vlc_object_t*);
+#define stats_TimerStart(a,b,c) stats_TimerStart( VLC_OBJECT(a), b,c )
+#define stats_TimerStop(a,b) stats_TimerStop( VLC_OBJECT(a), b )
+#define stats_TimerDump(a,b) stats_TimerDump( VLC_OBJECT(a), b )
+#define stats_TimersDumpAll(a) stats_TimersDumpAll( VLC_OBJECT(a) )
+
+VLC_API void stats_TimersCleanAll(vlc_object_t * );
+#define stats_TimersCleanAll(a) stats_TimersCleanAll( VLC_OBJECT(a) )
+
+VLC_API void stats_TimerClean(vlc_object_t *, unsigned int );
+#define stats_TimerClean(a,b) stats_TimerClean( VLC_OBJECT(a), b )
+
+/**
+ * @}
+ */
+#endif

=== added file 'DivCity/DivCity/vlc/plugins/vlc_meta.h'
--- DivCity/DivCity/vlc/plugins/vlc_meta.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_meta.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,147 @@
+/*****************************************************************************
+ * vlc_meta.h: Stream meta-data
+ *****************************************************************************
+ * Copyright (C) 2004 VLC authors and VideoLAN
+ * $Id: 3f8c091bdd0a00434c6d5689419541232f5481d5 $
+ *
+ * Authors: Laurent Aimar <fenrir@via.ecp.fr>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_META_H
+#define VLC_META_H 1
+
+/**
+ * \file
+ * This file defines functions and structures for stream meta-data in vlc
+ *
+ */
+
+typedef enum vlc_meta_type_t
+{
+    vlc_meta_Title,
+    vlc_meta_Artist,
+    vlc_meta_Genre,
+    vlc_meta_Copyright,
+    vlc_meta_Album,
+    vlc_meta_TrackNumber,
+    vlc_meta_Description,
+    vlc_meta_Rating,
+    vlc_meta_Date,
+    vlc_meta_Setting,
+    vlc_meta_URL,
+    vlc_meta_Language,
+    vlc_meta_NowPlaying,
+    vlc_meta_Publisher,
+    vlc_meta_EncodedBy,
+    vlc_meta_ArtworkURL,
+    vlc_meta_TrackID
+} vlc_meta_type_t;
+
+#define VLC_META_TYPE_COUNT 17
+
+#define ITEM_PREPARSED       1
+#define ITEM_ARTURL_FETCHED  2
+#define ITEM_ART_FETCHED     4
+#define ITEM_ART_NOTFOUND    8
+
+/**
+ * Basic function to deal with meta
+ */
+struct vlc_meta_t;
+
+VLC_API vlc_meta_t * vlc_meta_New( void ) VLC_USED;
+VLC_API void vlc_meta_Delete( vlc_meta_t *m );
+VLC_API void vlc_meta_Set( vlc_meta_t *p_meta, vlc_meta_type_t meta_type, const char *psz_val );
+VLC_API const char * vlc_meta_Get( const vlc_meta_t *p_meta, vlc_meta_type_t meta_type );
+
+VLC_API void vlc_meta_AddExtra( vlc_meta_t *m, const char *psz_name, const char *psz_value );
+VLC_API const char * vlc_meta_GetExtra( const vlc_meta_t *m, const char *psz_name );
+VLC_API unsigned vlc_meta_GetExtraCount( const vlc_meta_t *m );
+
+/**
+ * Allocate a copy of all extra meta names and a table with it.
+ * Be sure to free both the returned pointers and its name.
+ */
+VLC_API char ** vlc_meta_CopyExtraNames( const vlc_meta_t *m ) VLC_USED;
+
+VLC_API void vlc_meta_Merge( vlc_meta_t *dst, const vlc_meta_t *src );
+
+VLC_API int vlc_meta_GetStatus( vlc_meta_t *m );
+VLC_API void vlc_meta_SetStatus( vlc_meta_t *m, int status );
+
+/**
+ * Returns a localizes string describing the meta
+ */
+VLC_API const char * vlc_meta_TypeToLocalizedString( vlc_meta_type_t meta_type );
+
+enum {
+    ALBUM_ART_WHEN_ASKED,
+    ALBUM_ART_WHEN_PLAYED,
+    ALBUM_ART_ALL
+};
+
+
+typedef struct meta_export_t
+{
+    VLC_COMMON_MEMBERS
+    input_item_t *p_item;
+    const char *psz_file;
+} meta_export_t;
+
+VLC_API int input_item_WriteMeta(vlc_object_t *, input_item_t *);
+
+/* Setters for meta.
+ * Warning: Make sure to use the input_item meta setters (defined in vlc_input.h)
+ * instead of those one. */
+#define vlc_meta_SetTitle( meta, b )       vlc_meta_Set( meta, vlc_meta_Title, b )
+#define vlc_meta_SetArtist( meta, b )      vlc_meta_Set( meta, vlc_meta_Artist, b )
+#define vlc_meta_SetGenre( meta, b )       vlc_meta_Set( meta, vlc_meta_Genre, b )
+#define vlc_meta_SetCopyright( meta, b )   vlc_meta_Set( meta, vlc_meta_Copyright, b )
+#define vlc_meta_SetAlbum( meta, b )       vlc_meta_Set( meta, vlc_meta_Album, b )
+#define vlc_meta_SetTrackNum( meta, b )    vlc_meta_Set( meta, vlc_meta_TrackNumber, b )
+#define vlc_meta_SetDescription( meta, b ) vlc_meta_Set( meta, vlc_meta_Description, b )
+#define vlc_meta_SetRating( meta, b )      vlc_meta_Set( meta, vlc_meta_Rating, b )
+#define vlc_meta_SetDate( meta, b )        vlc_meta_Set( meta, vlc_meta_Date, b )
+#define vlc_meta_SetSetting( meta, b )     vlc_meta_Set( meta, vlc_meta_Setting, b )
+#define vlc_meta_SetURL( meta, b )         vlc_meta_Set( meta, vlc_meta_URL, b )
+#define vlc_meta_SetLanguage( meta, b )    vlc_meta_Set( meta, vlc_meta_Language, b )
+#define vlc_meta_SetNowPlaying( meta, b )  vlc_meta_Set( meta, vlc_meta_NowPlaying, b )
+#define vlc_meta_SetPublisher( meta, b )   vlc_meta_Set( meta, vlc_meta_Publisher, b )
+#define vlc_meta_SetEncodedBy( meta, b )   vlc_meta_Set( meta, vlc_meta_EncodedBy, b )
+#define vlc_meta_SetArtURL( meta, b )      vlc_meta_Set( meta, vlc_meta_ArtworkURL, b )
+#define vlc_meta_SetTrackID( meta, b )     vlc_meta_Set( meta, vlc_meta_TrackID, b )
+
+#define VLC_META_TITLE              vlc_meta_TypeToLocalizedString( vlc_meta_Title )
+#define VLC_META_ARTIST             vlc_meta_TypeToLocalizedString( vlc_meta_Artist )
+#define VLC_META_GENRE              vlc_meta_TypeToLocalizedString( vlc_meta_Genre )
+#define VLC_META_COPYRIGHT          vlc_meta_TypeToLocalizedString( vlc_meta_Copyright )
+#define VLC_META_ALBUM              vlc_meta_TypeToLocalizedString( vlc_meta_Album )
+#define VLC_META_TRACK_NUMBER       vlc_meta_TypeToLocalizedString( vlc_meta_TrackNumber )
+#define VLC_META_DESCRIPTION        vlc_meta_TypeToLocalizedString( vlc_meta_Description )
+#define VLC_META_RATING             vlc_meta_TypeToLocalizedString( vlc_meta_Rating )
+#define VLC_META_DATE               vlc_meta_TypeToLocalizedString( vlc_meta_Date )
+#define VLC_META_SETTING            vlc_meta_TypeToLocalizedString( vlc_meta_Setting )
+#define VLC_META_URL                vlc_meta_TypeToLocalizedString( vlc_meta_URL )
+#define VLC_META_LANGUAGE           vlc_meta_TypeToLocalizedString( vlc_meta_Language )
+#define VLC_META_NOW_PLAYING        vlc_meta_TypeToLocalizedString( vlc_meta_NowPlaying )
+#define VLC_META_PUBLISHER          vlc_meta_TypeToLocalizedString( vlc_meta_Publisher )
+#define VLC_META_ENCODED_BY         vlc_meta_TypeToLocalizedString( vlc_meta_EncodedBy )
+#define VLC_META_ART_URL            vlc_meta_TypeToLocalizedString( vlc_meta_ArtworkURL )
+#define VLC_META_TRACKID            vlc_meta_TypeToLocalizedString( vlc_meta_TrackID )
+
+
+#endif

=== added file 'DivCity/DivCity/vlc/plugins/vlc_modules.h'
--- DivCity/DivCity/vlc/plugins/vlc_modules.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_modules.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,77 @@
+/*****************************************************************************
+ * modules.h : Module descriptor and load functions
+ *****************************************************************************
+ * Copyright (C) 2001-2011 VLC authors and VideoLAN
+ * $Id: 6e0a4397d752431f7da62062df60a099f8b57303 $
+ *
+ * Authors: Samuel Hocevar <sam@zoy.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+/**
+ * \file
+ * This file defines functions for modules in vlc
+ */
+
+typedef int (*vlc_activate_t)(void *func, va_list args);
+typedef void (*vlc_deactivate_t)(void *func, va_list args);
+
+/*****************************************************************************
+ * Exported functions.
+ *****************************************************************************/
+
+VLC_API module_t * vlc_module_load( vlc_object_t *obj, const char *cap, const char *name, bool strict, vlc_activate_t probe, ... ) VLC_USED;
+#define vlc_module_load(o,c,n,s,...) \
+        vlc_module_load(VLC_OBJECT(o),c,n,s,__VA_ARGS__)
+VLC_API void vlc_module_unload( module_t *, vlc_deactivate_t deinit, ... );
+
+VLC_API module_t * module_need( vlc_object_t *, const char *, const char *, bool ) VLC_USED;
+#define module_need(a,b,c,d) module_need(VLC_OBJECT(a),b,c,d)
+VLC_API void module_unneed( vlc_object_t *, module_t * );
+#define module_unneed(a,b) module_unneed(VLC_OBJECT(a),b)
+VLC_API bool module_exists(const char *) VLC_USED;
+VLC_API module_t * module_find(const char *) VLC_USED;
+
+int module_start(vlc_object_t *, const module_t *);
+#define module_start(o, m) module_start(VLC_OBJECT(o),m)
+void module_stop(vlc_object_t *, const module_t *);
+#define module_stop(o, m) module_stop(VLC_OBJECT(o),m)
+
+VLC_API module_config_t * module_config_get( const module_t *, unsigned * ) VLC_USED;
+VLC_API void module_config_free( module_config_t * );
+
+VLC_API void module_list_free(module_t **);
+VLC_API module_t ** module_list_get(size_t *n) VLC_USED;
+
+VLC_API bool module_provides( const module_t *m, const char *cap );
+VLC_API const char * module_get_object( const module_t *m ) VLC_USED;
+VLC_API const char * module_get_name( const module_t *m, bool long_name ) VLC_USED;
+#define module_GetLongName( m ) module_get_name( m, true )
+VLC_API const char * module_get_help( const module_t *m ) VLC_USED;
+VLC_API const char * module_get_capability( const module_t *m ) VLC_USED;
+VLC_API int module_get_score( const module_t *m ) VLC_USED;
+VLC_API const char * module_gettext( const module_t *, const char * ) VLC_USED;
+
+VLC_USED static inline module_t *module_get_main (void)
+{
+    return module_find ("main");
+}
+#define module_get_main(a) module_get_main()
+
+VLC_USED static inline bool module_is_main( const module_t * p_module )
+{
+    return !strcmp( module_get_object( p_module ), "main" );
+}

=== added file 'DivCity/DivCity/vlc/plugins/vlc_mouse.h'
--- DivCity/DivCity/vlc/plugins/vlc_mouse.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_mouse.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,148 @@
+/*****************************************************************************
+ * vlc_mouse.h: mouse related structures and functions
+ *****************************************************************************
+ * Copyright (C) 2009 Laurent Aimar
+ * $Id: b48853570a09ad1d77cc95cda0c5b04b5028ee80 $
+ *
+ * Authors: Laurent Aimar <fenrir _AT_ videolan _DOT_ org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef _VLC_MOUSE_H
+#define _VLC_MOUSE_H 1
+
+/**
+ * Mouse buttons
+ */
+enum
+{
+    MOUSE_BUTTON_LEFT=0,
+    MOUSE_BUTTON_CENTER,
+    MOUSE_BUTTON_RIGHT,
+    MOUSE_BUTTON_WHEEL_UP,
+    MOUSE_BUTTON_WHEEL_DOWN,
+    MOUSE_BUTTON_WHEEL_LEFT,
+    MOUSE_BUTTON_WHEEL_RIGHT,
+    MOUSE_BUTTON_MAX
+};
+
+/**
+ * Mouse state
+ */
+typedef struct
+{
+    /* Coordinate */
+    int i_x;
+    int i_y;
+    /* Mask of pressed button */
+    int i_pressed;
+    /* Is double clicked */
+    bool b_double_click;
+} vlc_mouse_t;
+
+static inline void vlc_mouse_Init( vlc_mouse_t *p_mouse )
+{
+    p_mouse->i_x = 0;
+    p_mouse->i_y = 0;
+    p_mouse->i_pressed = 0;
+    p_mouse->b_double_click = false;
+}
+
+/* */
+static inline void vlc_mouse_SetPressed( vlc_mouse_t *p_mouse,
+                                         int i_button )
+{
+    p_mouse->i_pressed |= 1 << i_button;
+}
+static inline void vlc_mouse_SetReleased( vlc_mouse_t *p_mouse,
+                                          int i_button )
+{
+    p_mouse->i_pressed &= ~(1 << i_button);
+}
+static inline void vlc_mouse_SetPosition( vlc_mouse_t *p_mouse,
+                                          int i_x, int i_y )
+{
+    p_mouse->i_x = i_x;
+    p_mouse->i_y = i_y;
+}
+
+/* */
+static inline bool vlc_mouse_IsPressed( const vlc_mouse_t *p_mouse,
+                                        int i_button )
+{
+    return ( p_mouse->i_pressed & (1 << i_button) ) != 0;
+}
+static inline bool vlc_mouse_IsLeftPressed( const vlc_mouse_t *p_mouse )
+{
+    return vlc_mouse_IsPressed( p_mouse, MOUSE_BUTTON_LEFT );
+}
+static inline bool vlc_mouse_IsCenterPressed( const vlc_mouse_t *p_mouse )
+{
+    return vlc_mouse_IsPressed( p_mouse, MOUSE_BUTTON_CENTER );
+}
+static inline bool vlc_mouse_IsRightPressed( const vlc_mouse_t *p_mouse )
+{
+    return vlc_mouse_IsPressed( p_mouse, MOUSE_BUTTON_RIGHT );
+}
+static inline bool vlc_mouse_IsWheelUpPressed( const vlc_mouse_t *p_mouse )
+{
+    return vlc_mouse_IsPressed( p_mouse, MOUSE_BUTTON_WHEEL_UP );
+}
+static inline bool vlc_mouse_IsWheelDownPressed( const vlc_mouse_t *p_mouse )
+{
+    return vlc_mouse_IsPressed( p_mouse, MOUSE_BUTTON_WHEEL_DOWN );
+}
+static inline void vlc_mouse_GetMotion( int *pi_x, int *pi_y,
+                                        const vlc_mouse_t *p_old,
+                                        const vlc_mouse_t *p_new )
+{
+    *pi_x = p_new->i_x - p_old->i_x;
+    *pi_y = p_new->i_y - p_old->i_y;
+}
+
+/* */
+static inline bool vlc_mouse_HasChanged( const vlc_mouse_t *p_old,
+                                         const vlc_mouse_t *p_new )
+{
+    return p_old->i_x != p_new->i_x || p_old->i_y != p_new->i_y ||
+           p_old->i_pressed != p_new->i_pressed;
+}
+static inline bool vlc_mouse_HasMoved( const vlc_mouse_t *p_old,
+                                       const vlc_mouse_t *p_new )
+{
+    return p_old->i_x != p_new->i_x || p_old->i_y != p_new->i_y;
+}
+static inline bool vlc_mouse_HasButton( const vlc_mouse_t *p_old,
+                                        const vlc_mouse_t *p_new )
+{
+    return p_old->i_pressed != p_new->i_pressed;
+}
+static inline bool vlc_mouse_HasPressed( const vlc_mouse_t *p_old,
+                                         const vlc_mouse_t *p_new,
+                                         int i_button )
+{
+    const int i_mask = 1 << i_button;
+    return (p_old->i_pressed & i_mask) == 0 && (p_new->i_pressed & i_mask);
+}
+static inline bool vlc_mouse_HasReleased( const vlc_mouse_t *p_old,
+                                          const vlc_mouse_t *p_new,
+                                          int i_button )
+{
+    const int i_mask = 1 << i_button;
+    return (p_old->i_pressed & i_mask) && (p_new->i_pressed & i_mask) == 0;
+}
+#endif /* _VLC_MOUSE_H */
+

=== added file 'DivCity/DivCity/vlc/plugins/vlc_mtime.h'
--- DivCity/DivCity/vlc/plugins/vlc_mtime.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_mtime.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,79 @@
+/*****************************************************************************
+ * vlc_mtime.h: high resolution time management functions
+ *****************************************************************************
+ * This header provides portable high precision time management functions,
+ * which should be the only ones used in other segments of the program, since
+ * functions like gettimeofday() and ftime() are not always supported.
+ * Most functions are declared as inline or as macros since they are only
+ * interfaces to system calls and have to be called frequently.
+ * 'm' stands for 'micro', since maximum resolution is the microsecond.
+ * Functions prototyped are implemented in interface/mtime.c.
+ *****************************************************************************
+ * Copyright (C) 1996, 1997, 1998, 1999, 2000 VLC authors and VideoLAN
+ * $Id: ab89a972120c8ee3f45d9823994eac584f8fe527 $
+ *
+ * Authors: Vincent Seguin <seguin@via.ecp.fr>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef __VLC_MTIME_H
+# define __VLC_MTIME_H 1
+
+/*****************************************************************************
+ * LAST_MDATE: date which will never happen
+ *****************************************************************************
+ * This date can be used as a 'never' date, to mark missing events in a function
+ * supposed to return a date, such as nothing to display in a function
+ * returning the date of the first image to be displayed. It can be used in
+ * comparaison with other values: all existing dates will be earlier.
+ *****************************************************************************/
+#define LAST_MDATE ((mtime_t)((uint64_t)(-1)/2))
+
+/*****************************************************************************
+ * MSTRTIME_MAX_SIZE: maximum possible size of mstrtime
+ *****************************************************************************
+ * This values is the maximal possible size of the string returned by the
+ * mstrtime() function, including '-' and the final '\0'. It should be used to
+ * allocate the buffer.
+ *****************************************************************************/
+#define MSTRTIME_MAX_SIZE 22
+
+/*****************************************************************************
+ * Prototypes
+ *****************************************************************************/
+VLC_API char * mstrtime( char *psz_buffer, mtime_t date );
+VLC_API char * secstotimestr( char *psz_buffer, int32_t secs );
+
+/*****************************************************************************
+ * date_t: date incrementation without long-term rounding errors
+ *****************************************************************************/
+struct date_t
+{
+    mtime_t  date;
+    uint32_t i_divider_num;
+    uint32_t i_divider_den;
+    uint32_t i_remainder;
+};
+
+VLC_API void date_Init( date_t *, uint32_t, uint32_t );
+VLC_API void date_Change( date_t *, uint32_t, uint32_t );
+VLC_API void date_Set( date_t *, mtime_t );
+VLC_API mtime_t date_Get( const date_t * );
+VLC_API void date_Move( date_t *, mtime_t );
+VLC_API mtime_t date_Increment( date_t *, uint32_t );
+VLC_API mtime_t date_Decrement( date_t *, uint32_t );
+VLC_API uint64_t NTPtime64( void );
+#endif /* !__VLC_MTIME_ */

=== added file 'DivCity/DivCity/vlc/plugins/vlc_network.h'
--- DivCity/DivCity/vlc/plugins/vlc_network.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_network.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,378 @@
+/*****************************************************************************
+ * vlc_network.h: interface to communicate with network plug-ins
+ *****************************************************************************
+ * Copyright (C) 2002-2005 VLC authors and VideoLAN
+ * Copyright Â© 2006-2007 RÃ©mi Denis-Courmont
+ * $Id: 7ee51e305ed8bf62a12e1aafbfe69a0b99ebc642 $
+ *
+ * Authors: Christophe Massiot <massiot@via.ecp.fr>
+ *          Laurent Aimar <fenrir@via.ecp.fr>
+ *          RÃ©mi Denis-Courmont <rem # videolan.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_NETWORK_H
+# define VLC_NETWORK_H
+
+/**
+ * \file
+ * This file defines interface to communicate with network plug-ins
+ */
+
+#if defined( WIN32 )
+#   if !defined(UNDER_CE)
+#       define _NO_OLDNAMES 1
+#       include <io.h>
+#   endif
+#   include <winsock2.h>
+#   include <ws2tcpip.h>
+#   define ENETUNREACH WSAENETUNREACH
+#   define net_errno (WSAGetLastError())
+extern const char *net_strerror( int val );
+
+struct iovec
+{
+    void  *iov_base;
+    size_t iov_len;
+};
+
+struct msghdr
+{
+    void         *msg_name;
+    size_t        msg_namelen;
+    struct iovec *msg_iov;
+    size_t        msg_iovlen;
+    void         *msg_control;
+    size_t        msg_controllen;
+    int           msg_flags;
+};
+
+#   ifndef IPV6_V6ONLY
+#       define IPV6_V6ONLY 27
+#   endif
+#else
+#   include <sys/types.h>
+#   include <unistd.h>
+#   include <sys/socket.h>
+#   include <netinet/in.h>
+#   include <netdb.h>
+#   define net_errno errno
+#endif
+
+#if defined( __SYMBIAN32__ )
+#   undef AF_INET6
+#   undef IN6_IS_ADDR_MULTICAST
+#   undef IPV6_V6ONLY
+#   undef IPV6_MULTICAST_HOPS
+#   undef IPV6_MULTICAST_IF
+#   undef IPV6_TCLASS
+#   undef IPV6_JOIN_GROUP
+#endif
+
+VLC_API int vlc_socket (int, int, int, bool nonblock) VLC_USED;
+
+struct sockaddr;
+VLC_API int vlc_accept( int, struct sockaddr *, socklen_t *, bool ) VLC_USED;
+
+# ifdef __cplusplus
+extern "C" {
+# endif
+
+/* Portable networking layer communication */
+int net_Socket (vlc_object_t *obj, int family, int socktype, int proto);
+
+VLC_API int net_Connect(vlc_object_t *p_this, const char *psz_host, int i_port, int socktype, int protocol);
+#define net_Connect(a, b, c, d, e) net_Connect(VLC_OBJECT(a), b, c, d, e)
+
+VLC_API int * net_Listen(vlc_object_t *p_this, const char *psz_host, int i_port, int socktype, int protocol);
+
+#define net_ListenTCP(a, b, c) net_Listen(VLC_OBJECT(a), b, c, \
+                                          SOCK_STREAM, IPPROTO_TCP)
+
+static inline int net_ConnectTCP (vlc_object_t *obj, const char *host, int port)
+{
+    return net_Connect (obj, host, port, SOCK_STREAM, IPPROTO_TCP);
+}
+#define net_ConnectTCP(a, b, c) net_ConnectTCP(VLC_OBJECT(a), b, c)
+
+VLC_API int net_AcceptSingle(vlc_object_t *obj, int lfd);
+
+VLC_API int net_Accept( vlc_object_t *, int * );
+#define net_Accept(a, b) \
+        net_Accept(VLC_OBJECT(a), b)
+
+VLC_API int net_ConnectDgram( vlc_object_t *p_this, const char *psz_host, int i_port, int hlim, int proto );
+#define net_ConnectDgram(a, b, c, d, e ) \
+        net_ConnectDgram(VLC_OBJECT(a), b, c, d, e)
+
+static inline int net_ConnectUDP (vlc_object_t *obj, const char *host, int port, int hlim)
+{
+    return net_ConnectDgram (obj, host, port, hlim, IPPROTO_UDP);
+}
+
+VLC_API int net_OpenDgram( vlc_object_t *p_this, const char *psz_bind, int i_bind, const char *psz_server, int i_server, int proto );
+#define net_OpenDgram( a, b, c, d, e, g ) \
+        net_OpenDgram(VLC_OBJECT(a), b, c, d, e, g)
+
+static inline int net_ListenUDP1 (vlc_object_t *obj, const char *host, int port)
+{
+    return net_OpenDgram (obj, host, port, NULL, 0, IPPROTO_UDP);
+}
+
+VLC_API void net_ListenClose( int *fd );
+
+int net_Subscribe (vlc_object_t *obj, int fd, const struct sockaddr *addr,
+                   socklen_t addrlen);
+
+VLC_API int net_SetCSCov( int fd, int sendcov, int recvcov );
+
+/* Functions to read from or write to the networking layer */
+struct virtual_socket_t
+{
+    void *p_sys;
+    int (*pf_recv) ( void *, void *, size_t );
+    int (*pf_send) ( void *, const void *, size_t );
+};
+
+VLC_API ssize_t net_Read( vlc_object_t *p_this, int fd, const v_socket_t *, void *p_data, size_t i_data, bool b_retry );
+#define net_Read(a,b,c,d,e,f) net_Read(VLC_OBJECT(a),b,c,d,e,f)
+VLC_API ssize_t net_Write( vlc_object_t *p_this, int fd, const v_socket_t *, const void *p_data, size_t i_data );
+#define net_Write(a,b,c,d,e) net_Write(VLC_OBJECT(a),b,c,d,e)
+VLC_API char * net_Gets( vlc_object_t *p_this, int fd, const v_socket_t * );
+#define net_Gets(a,b,c) net_Gets(VLC_OBJECT(a),b,c)
+
+
+VLC_API ssize_t net_Printf( vlc_object_t *p_this, int fd, const v_socket_t *, const char *psz_fmt, ... ) VLC_FORMAT( 4, 5 );
+#define net_Printf(o,fd,vs,...) net_Printf(VLC_OBJECT(o),fd,vs, __VA_ARGS__)
+VLC_API ssize_t net_vaPrintf( vlc_object_t *p_this, int fd, const v_socket_t *, const char *psz_fmt, va_list args );
+#define net_vaPrintf(a,b,c,d,e) net_vaPrintf(VLC_OBJECT(a),b,c,d,e)
+
+struct pollfd;
+VLC_API int vlc_poll(struct pollfd *fds, unsigned nfds, int timeout);
+
+
+#ifdef WIN32
+/* Microsoft: same semantic, same value, different name... go figure */
+# define SHUT_RD SD_RECEIVE
+# define SHUT_WR SD_SEND
+# define SHUT_RDWR SD_BOTH
+# define net_Close( fd ) closesocket ((SOCKET)fd)
+#else
+# ifdef __OS2__
+#  define SHUT_RD    0
+#  define SHUT_WR    1
+#  define SHUT_RDWR  2
+# endif
+# define net_Close( fd ) (void)close (fd)
+#endif
+
+/* Portable network names/addresses resolution layer */
+
+/* GAI error codes */
+# ifndef EAI_BADFLAGS
+#  define EAI_BADFLAGS -1
+# endif
+# ifndef EAI_NONAME
+#  define EAI_NONAME -2
+# endif
+# ifndef EAI_AGAIN
+#  define EAI_AGAIN -3
+# endif
+# ifndef EAI_FAIL
+#  define EAI_FAIL -4
+# endif
+# ifndef EAI_NODATA
+#  define EAI_NODATA -5
+# endif
+# ifndef EAI_FAMILY
+#  define EAI_FAMILY -6
+# endif
+# ifndef EAI_SOCKTYPE
+#  define EAI_SOCKTYPE -7
+# endif
+# ifndef EAI_SERVICE
+#  define EAI_SERVICE -8
+# endif
+# ifndef EAI_ADDRFAMILY
+#  define EAI_ADDRFAMILY -9
+# endif
+# ifndef EAI_MEMORY
+#  define EAI_MEMORY -10
+# endif
+#ifndef EAI_OVERFLOW
+#  define EAI_OVERFLOW -11
+#endif
+# ifndef EAI_SYSTEM
+#  define EAI_SYSTEM -12
+# endif
+
+
+# ifndef NI_MAXHOST
+#  define NI_MAXHOST 1025
+#  define NI_MAXSERV 32
+# endif
+# define NI_MAXNUMERICHOST 64
+
+#ifndef AI_NUMERICSERV
+# define AI_NUMERICSERV 0
+#endif
+
+#ifdef __OS2__
+# ifndef NI_NUMERICHOST
+#  define NI_NUMERICHOST 0x01
+#  define NI_NUMERICSERV 0x02
+#  define NI_NOFQDN      0x04
+#  define NI_NAMEREQD    0x08
+#  define NI_DGRAM       0x10
+# endif
+
+struct addrinfo
+{
+    int ai_flags;
+    int ai_family;
+    int ai_socktype;
+    int ai_protocol;
+    size_t ai_addrlen;
+    struct sockaddr *ai_addr;
+    char *ai_canonname;
+    struct addrinfo *ai_next;
+};
+
+# define AI_PASSIVE     1
+# define AI_CANONNAME   2
+# define AI_NUMERICHOST 4
+
+VLC_API const char *gai_strerror( int errnum );
+
+VLC_API int  getaddrinfo ( const char *, const char *,
+                           const struct addrinfo *, struct addrinfo ** );
+VLC_API void freeaddrinfo( struct addrinfo * );
+VLC_API int  getnameinfo ( const struct sockaddr *, socklen_t,
+                           char *, int, char *, int, int );
+#endif
+
+VLC_API int vlc_getnameinfo( const struct sockaddr *, int, char *, int, int *, int );
+VLC_API int vlc_getaddrinfo( vlc_object_t *, const char *, int, const struct addrinfo *, struct addrinfo ** );
+
+
+#ifdef __OS2__
+/* OS/2 does not support IPv6, yet. But declare these only for compilation */
+struct in6_addr
+{
+    uint8_t s6_addr[16];
+};
+
+struct sockaddr_in6
+{
+    uint8_t         sin6_len;
+    uint8_t         sin6_family;
+    uint16_t        sin6_port;
+    uint32_t        sin6_flowinfo;
+    struct in6_addr sin6_addr;
+    uint32_t        sin6_scope_id;
+};
+
+# define IN6_IS_ADDR_MULTICAST(a)   (((__const uint8_t *) (a))[0] == 0xff)
+
+static const struct in6_addr in6addr_any =
+    { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } };
+#endif
+
+static inline bool
+net_SockAddrIsMulticast (const struct sockaddr *addr, socklen_t len)
+{
+    switch (addr->sa_family)
+    {
+#ifdef IN_MULTICAST
+        case AF_INET:
+        {
+            const struct sockaddr_in *v4 = (const struct sockaddr_in *)addr;
+            if ((size_t)len < sizeof (*v4))
+                return false;
+            return IN_MULTICAST (ntohl (v4->sin_addr.s_addr)) != 0;
+        }
+#endif
+
+#ifdef IN6_IS_ADDR_MULTICAST
+        case AF_INET6:
+        {
+            const struct sockaddr_in6 *v6 = (const struct sockaddr_in6 *)addr;
+            if ((size_t)len < sizeof (*v6))
+                return false;
+            return IN6_IS_ADDR_MULTICAST (&v6->sin6_addr) != 0;
+        }
+#endif
+    }
+
+    return false;
+}
+
+
+static inline int net_GetSockAddress( int fd, char *address, int *port )
+{
+    struct sockaddr_storage addr;
+    socklen_t addrlen = sizeof( addr );
+
+    return getsockname( fd, (struct sockaddr *)&addr, &addrlen )
+        || vlc_getnameinfo( (struct sockaddr *)&addr, addrlen, address,
+                            NI_MAXNUMERICHOST, port, NI_NUMERICHOST )
+        ? VLC_EGENERIC : 0;
+}
+
+static inline int net_GetPeerAddress( int fd, char *address, int *port )
+{
+    struct sockaddr_storage addr;
+    socklen_t addrlen = sizeof( addr );
+
+    return getpeername( fd, (struct sockaddr *)&addr, &addrlen )
+        || vlc_getnameinfo( (struct sockaddr *)&addr, addrlen, address,
+                            NI_MAXNUMERICHOST, port, NI_NUMERICHOST )
+        ? VLC_EGENERIC : 0;
+}
+
+static inline uint16_t net_GetPort (const struct sockaddr *addr)
+{
+    switch (addr->sa_family)
+    {
+#ifdef AF_INET6
+        case AF_INET6:
+            return ((const struct sockaddr_in6 *)addr)->sin6_port;
+#endif
+        case AF_INET:
+            return ((const struct sockaddr_in *)addr)->sin_port;
+    }
+    return 0;
+}
+
+static inline void net_SetPort (struct sockaddr *addr, uint16_t port)
+{
+    switch (addr->sa_family)
+    {
+#ifdef AF_INET6
+        case AF_INET6:
+            ((struct sockaddr_in6 *)addr)->sin6_port = port;
+        break;
+#endif
+        case AF_INET:
+            ((struct sockaddr_in *)addr)->sin_port = port;
+        break;
+    }
+}
+# ifdef __cplusplus
+}
+# endif
+
+#endif

=== added file 'DivCity/DivCity/vlc/plugins/vlc_objects.h'
--- DivCity/DivCity/vlc/plugins/vlc_objects.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_objects.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,89 @@
+/*****************************************************************************
+ * vlc_objects.h: vlc_object_t definition and manipulation methods
+ *****************************************************************************
+ * Copyright (C) 2002-2008 VLC authors and VideoLAN
+ * $Id: 06ac2bbd9e02f5a481ddc868b909c933a046d877 $
+ *
+ * Authors: Samuel Hocevar <sam@zoy.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+/**
+ * \file
+ * This file defines the vlc_object_t structure and object types.
+ */
+
+/**
+ * \defgroup vlc_object Objects
+ * @{
+ */
+
+/* Object flags */
+#define OBJECT_FLAGS_QUIET       0x0002
+#define OBJECT_FLAGS_NOINTERACT  0x0004
+
+/*****************************************************************************
+ * The vlc_object_t type. Yes, it's that simple :-)
+ *****************************************************************************/
+/** The main vlc_object_t structure */
+struct vlc_object_t
+{
+    VLC_COMMON_MEMBERS
+};
+
+/*****************************************************************************
+ * Prototypes
+ *****************************************************************************/
+VLC_API void *vlc_object_create( vlc_object_t *, size_t ) VLC_MALLOC VLC_USED;
+VLC_API vlc_object_t *vlc_object_find_name( vlc_object_t *, const char * ) VLC_USED VLC_DEPRECATED;
+VLC_API void * vlc_object_hold( vlc_object_t * );
+VLC_API void vlc_object_release( vlc_object_t * );
+VLC_API vlc_list_t *vlc_list_children( vlc_object_t * ) VLC_USED;
+VLC_API void vlc_list_release( vlc_list_t * );
+VLC_API char *vlc_object_get_name( const vlc_object_t * ) VLC_USED;
+#define vlc_object_get_name(o) vlc_object_get_name(VLC_OBJECT(o))
+
+/**}@*/
+
+#define vlc_object_create(a,b) vlc_object_create( VLC_OBJECT(a), b )
+
+#define vlc_object_find_name(a,b) \
+    vlc_object_find_name( VLC_OBJECT(a),b)
+
+#define vlc_object_hold(a) \
+    vlc_object_hold( VLC_OBJECT(a) )
+
+#define vlc_object_release(a) \
+    vlc_object_release( VLC_OBJECT(a) )
+
+#define vlc_list_children(a) \
+    vlc_list_children( VLC_OBJECT(a) )
+
+/* Objects and threading */
+VLC_API void vlc_object_kill( vlc_object_t * ) VLC_DEPRECATED;
+#define vlc_object_kill(a) \
+    vlc_object_kill( VLC_OBJECT(a) )
+
+VLC_USED VLC_DEPRECATED
+static inline bool vlc_object_alive (const vlc_object_t *obj)
+{
+    barrier ();
+    return !obj->b_die;
+}
+
+#define vlc_object_alive(a) vlc_object_alive( VLC_OBJECT(a) )
+
+/** @} */

=== added file 'DivCity/DivCity/vlc/plugins/vlc_opengl.h'
--- DivCity/DivCity/vlc/plugins/vlc_opengl.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_opengl.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,89 @@
+/*****************************************************************************
+ * vlc_gl.h: VLC GL API
+ *****************************************************************************
+ * Copyright (C) 2009 Laurent Aimar
+ * Copyright (C) 2011 RÃ©mi Denis-Courmont
+ *
+ * Authors: Laurent Aimar <fenrir _AT_ videolan _DOT_ org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_GL_H
+#define VLC_GL_H 1
+
+/**
+ * \file
+ * This file defines GL structures and functions.
+ */
+
+struct vout_window_t;
+
+/**
+ * A VLC GL context (and its underlying surface)
+ */
+typedef struct vlc_gl_t vlc_gl_t;
+
+struct vlc_gl_t
+{
+    VLC_COMMON_MEMBERS
+
+    struct vout_window_t *surface;
+    module_t *module;
+    void *sys;
+
+    int  (*makeCurrent)(vlc_gl_t *);
+    void (*swap)(vlc_gl_t *);
+    int  (*lock)(vlc_gl_t *);
+    void (*unlock)(vlc_gl_t *);
+    void*(*getProcAddress)(vlc_gl_t *, const char *);
+};
+
+enum {
+    VLC_OPENGL,
+    VLC_OPENGL_ES,
+    VLC_OPENGL_ES2,
+};
+
+VLC_API vlc_gl_t *vlc_gl_Create(struct vout_window_t *, unsigned, const char *) VLC_USED;
+VLC_API void vlc_gl_Destroy(vlc_gl_t *);
+
+static inline int vlc_gl_MakeCurrent(vlc_gl_t *gl)
+{
+    return gl->makeCurrent(gl);
+}
+
+static inline int vlc_gl_Lock(vlc_gl_t *gl)
+{
+    return (gl->lock != NULL) ? gl->lock(gl) : VLC_SUCCESS;
+}
+
+static inline void vlc_gl_Unlock(vlc_gl_t *gl)
+{
+    if (gl->unlock != NULL)
+        gl->unlock(gl);
+}
+
+static inline void vlc_gl_Swap(vlc_gl_t *gl)
+{
+    gl->swap(gl);
+}
+
+static inline void *vlc_gl_GetProcAddress(vlc_gl_t *gl, const char *name)
+{
+    return (gl->getProcAddress != NULL) ? gl->getProcAddress(gl, name) : NULL;
+}
+
+#endif /* VLC_GL_H */

=== added file 'DivCity/DivCity/vlc/plugins/vlc_picture.h'
--- DivCity/DivCity/vlc/plugins/vlc_picture.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_picture.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,334 @@
+/*****************************************************************************
+ * vlc_picture.h: picture definitions
+ *****************************************************************************
+ * Copyright (C) 1999 - 2009 VLC authors and VideoLAN
+ * $Id: 75502cab11099d73441f6912c383d0dafe91c7ba $
+ *
+ * Authors: Vincent Seguin <seguin@via.ecp.fr>
+ *          Samuel Hocevar <sam@via.ecp.fr>
+ *          Olivier Aubert <oaubert 47 videolan d07 org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_PICTURE_H
+#define VLC_PICTURE_H 1
+
+/**
+ * \file
+ * This file defines picture structures and functions in vlc
+ */
+
+#include <vlc_es.h>
+
+/** Description of a planar graphic field */
+typedef struct plane_t
+{
+    uint8_t *p_pixels;                        /**< Start of the plane's data */
+
+    /* Variables used for fast memcpy operations */
+    int i_lines;           /**< Number of lines, including margins */
+    int i_pitch;           /**< Number of bytes in a line, including margins */
+
+    /** Size of a macropixel, defaults to 1 */
+    int i_pixel_pitch;
+
+    /* Variables used for pictures with margins */
+    int i_visible_lines;            /**< How many visible lines are there ? */
+    int i_visible_pitch;            /**< How many visible pixels are there ? */
+
+} plane_t;
+
+/**
+ * Maximum number of plane for a picture
+ */
+#define PICTURE_PLANE_MAX (VOUT_MAX_PLANES)
+
+/**
+ * A private definition to help overloading picture release
+ */
+typedef struct picture_release_sys_t picture_release_sys_t;
+
+/**
+ * Video picture
+ */
+struct picture_t
+{
+    /**
+     * The properties of the picture
+     */
+    video_frame_format_t format;
+
+    void           *p_data_orig;                /**< pointer before memalign */
+    plane_t         p[PICTURE_PLANE_MAX];     /**< description of the planes */
+    int             i_planes;                /**< number of allocated planes */
+
+    /** \name Picture management properties
+     * These properties can be modified using the video output thread API,
+     * but should never be written directly */
+    /**@{*/
+    unsigned        i_refcount;                  /**< link reference counter */
+    mtime_t         date;                                  /**< display date */
+    bool            b_force;
+    /**@}*/
+
+    /** \name Picture dynamic properties
+     * Those properties can be changed by the decoder
+     * @{
+     */
+    bool            b_progressive;          /**< is it a progressive frame ? */
+    bool            b_top_field_first;             /**< which field is first */
+    unsigned int    i_nb_fields;                  /**< # of displayed fields */
+    int8_t         *p_q;                           /**< quantification table */
+    int             i_qstride;                    /**< quantification stride */
+    int             i_qtype;                       /**< quantification style */
+    /**@}*/
+
+    /** Private data - the video output plugin might want to put stuff here to
+     * keep track of the picture */
+    picture_sys_t * p_sys;
+
+    /** This way the picture_Release can be overloaded */
+    void (*pf_release)( picture_t * );
+    picture_release_sys_t *p_release_sys;
+
+    /** Next picture in a FIFO a pictures */
+    struct picture_t *p_next;
+};
+
+/**
+ * This function will create a new picture.
+ * The picture created will implement a default release management compatible
+ * with picture_Hold and picture_Release. This default management will release
+ * p_sys, p_q, p_data_orig fields if non NULL.
+ */
+VLC_API picture_t * picture_New( vlc_fourcc_t i_chroma, int i_width, int i_height, int i_sar_num, int i_sar_den ) VLC_USED;
+
+/**
+ * This function will create a new picture using the given format.
+ *
+ * When possible, it is preferred to use this function over picture_New
+ * as more information about the format is kept.
+ */
+VLC_API picture_t * picture_NewFromFormat( const video_format_t *p_fmt ) VLC_USED;
+
+/**
+ * Resource for a picture.
+ */
+typedef struct
+{
+    picture_sys_t *p_sys;
+
+    /* Plane resources
+     * XXX all fields MUST be set to the right value.
+     */
+    struct
+    {
+        uint8_t *p_pixels;  /**< Start of the plane's data */
+        int i_lines;        /**< Number of lines, including margins */
+        int i_pitch;        /**< Number of bytes in a line, including margins */
+    } p[PICTURE_PLANE_MAX];
+
+} picture_resource_t;
+
+/**
+ * This function will create a new picture using the provided resource.
+ *
+ * If the resource is NULL then a plain picture_NewFromFormat is returned.
+ */
+VLC_API picture_t * picture_NewFromResource( const video_format_t *, const picture_resource_t * ) VLC_USED;
+
+/**
+ * This function will force the destruction a picture.
+ * The value of the picture reference count should be 0 before entering this
+ * function.
+ * Unless used for reimplementing pf_release, you should not use this
+ * function but picture_Release.
+ */
+VLC_API void picture_Delete( picture_t * );
+
+/**
+ * This function will increase the picture reference count.
+ * It will not have any effect on picture obtained from vout
+ *
+ * It returns the given picture for convenience.
+ */
+static inline picture_t *picture_Hold( picture_t *p_picture )
+{
+    if( p_picture->pf_release )
+        p_picture->i_refcount++;
+    return p_picture;
+}
+/**
+ * This function will release a picture.
+ * It will not have any effect on picture obtained from vout
+ */
+static inline void picture_Release( picture_t *p_picture )
+{
+    /* FIXME why do we let pf_release handle the i_refcount ? */
+    if( p_picture->pf_release )
+        p_picture->pf_release( p_picture );
+}
+
+/**
+ * This function will return true if you are not the only owner of the
+ * picture.
+ *
+ * It is only valid if it is created using picture_New.
+ */
+static inline bool picture_IsReferenced( picture_t *p_picture )
+{
+    return p_picture->i_refcount > 1;
+}
+
+/**
+ * Cleanup quantization matrix data and set to 0
+ */
+static inline void picture_CleanupQuant( picture_t *p_pic )
+{
+    free( p_pic->p_q );
+    p_pic->p_q = NULL;
+    p_pic->i_qstride = 0;
+    p_pic->i_qtype = 0;
+}
+
+/**
+ * This function will copy all picture dynamic properties.
+ */
+static inline void picture_CopyProperties( picture_t *p_dst, const picture_t *p_src )
+{
+    p_dst->date = p_src->date;
+    p_dst->b_force = p_src->b_force;
+
+    p_dst->b_progressive = p_src->b_progressive;
+    p_dst->i_nb_fields = p_src->i_nb_fields;
+    p_dst->b_top_field_first = p_src->b_top_field_first;
+
+    /* FIXME: copy ->p_q and ->p_qstride */
+}
+
+/**
+ * This function will reset a picture information (properties and quantizers).
+ * It is sometimes useful for reusing pictures (like from a pool).
+ */
+VLC_API void picture_Reset( picture_t * );
+
+/**
+ * This function will copy the picture pixels.
+ * You can safely copy between pictures that do not have the same size,
+ * only the compatible(smaller) part will be copied.
+ */
+VLC_API void picture_CopyPixels( picture_t *p_dst, const picture_t *p_src );
+VLC_API void plane_CopyPixels( plane_t *p_dst, const plane_t *p_src );
+
+/**
+ * This function will copy both picture dynamic properties and pixels.
+ * You have to notice that sometime a simple picture_Hold may do what
+ * you want without the copy overhead.
+ * Provided for convenience.
+ *
+ * \param p_dst pointer to the destination picture.
+ * \param p_src pointer to the source picture.
+ */
+static inline void picture_Copy( picture_t *p_dst, const picture_t *p_src )
+{
+    picture_CopyPixels( p_dst, p_src );
+    picture_CopyProperties( p_dst, p_src );
+}
+
+/**
+ * This function will export a picture to an encoded bitstream.
+ *
+ * pp_image will contain the encoded bitstream in psz_format format.
+ *
+ * p_fmt can be NULL otherwise it will be set with the format used for the
+ * picture before encoding.
+ *
+ * i_override_width/height allow to override the width and/or the height of the
+ * picture to be encoded:
+ *  - if strictly lower than 0, the original dimension will be used.
+ *  - if equal to 0, it will be deduced from the other dimension which must be
+ *  different to 0.
+ *  - if strictly higher than 0, it will override the dimension.
+ * If at most one of them is > 0 then the picture aspect ratio will be kept.
+ */
+VLC_API int picture_Export( vlc_object_t *p_obj, block_t **pp_image, video_format_t *p_fmt, picture_t *p_picture, vlc_fourcc_t i_format, int i_override_width, int i_override_height );
+
+/**
+ * This function will setup all fields of a picture_t without allocating any
+ * memory.
+ * XXX The memory must already be initialized.
+ * It does not need to be released.
+ *
+ * It will return VLC_EGENERIC if the core does not understand the requested
+ * format.
+ *
+ * It can be useful to get the properties of planes.
+ */
+VLC_API int picture_Setup( picture_t *, vlc_fourcc_t i_chroma, int i_width, int i_height, int i_sar_num, int i_sar_den );
+
+
+/**
+ * This function will blend a given subpicture onto a picture.
+ *
+ * The subpicture and all its region must:
+ *  - be absolute.
+ *  - not be ephemere.
+ *  - not have the fade flag.
+ *  - contains only picture (no text rendering).
+ */
+VLC_API void picture_BlendSubpicture( picture_t *, filter_t *p_blend, subpicture_t * );
+
+
+/*****************************************************************************
+ * Flags used to describe the status of a picture
+ *****************************************************************************/
+
+/* Quantification type */
+enum
+{
+    QTYPE_NONE,
+
+    QTYPE_MPEG1,
+    QTYPE_MPEG2,
+    QTYPE_H264,
+};
+
+/*****************************************************************************
+ * Shortcuts to access image components
+ *****************************************************************************/
+
+/* Plane indices */
+enum
+{
+    Y_PLANE = 0,
+    U_PLANE = 1,
+    V_PLANE = 2,
+    A_PLANE = 3,
+};
+
+/* Shortcuts */
+#define Y_PIXELS     p[Y_PLANE].p_pixels
+#define Y_PITCH      p[Y_PLANE].i_pitch
+#define U_PIXELS     p[U_PLANE].p_pixels
+#define U_PITCH      p[U_PLANE].i_pitch
+#define V_PIXELS     p[V_PLANE].p_pixels
+#define V_PITCH      p[V_PLANE].i_pitch
+#define A_PIXELS     p[A_PLANE].p_pixels
+#define A_PITCH      p[A_PLANE].i_pitch
+
+/**@}*/
+
+#endif /* VLC_PICTURE_H */

=== added file 'DivCity/DivCity/vlc/plugins/vlc_picture_fifo.h'
--- DivCity/DivCity/vlc/plugins/vlc_picture_fifo.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_picture_fifo.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,89 @@
+/*****************************************************************************
+ * vlc_picture_fifo.h: picture fifo definitions
+ *****************************************************************************
+ * Copyright (C) 2009 VLC authors and VideoLAN
+ * $Id: 73d1b20c279f628cf94bc7cfc83b2548878bcc07 $
+ *
+ * Authors: Laurent Aimar <fenrir _AT_ videolan _DOT_ org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_PICTURE_FIFO_H
+#define VLC_PICTURE_FIFO_H 1
+
+/**
+ * \file
+ * This file defines picture fifo structures and functions in vlc
+ */
+
+#include <vlc_picture.h>
+
+/**
+ * Picture fifo handle
+ *
+ * It is thread safe (push/pop).
+ */
+typedef struct picture_fifo_t picture_fifo_t;
+
+/**
+ * It creates an empty picture_fifo_t.
+ */
+VLC_API picture_fifo_t * picture_fifo_New( void ) VLC_USED;
+
+/**
+ * It destroys a fifo created by picture_fifo_New.
+ *
+ * All pictures inside the fifo will be released by picture_Release.
+ */
+VLC_API void picture_fifo_Delete( picture_fifo_t * );
+
+/**
+ * It retreives a picture_t from the fifo.
+ *
+ * If the fifo is empty, it return NULL without waiting.
+ */
+VLC_API picture_t * picture_fifo_Pop( picture_fifo_t * ) VLC_USED;
+
+/**
+ * It returns the first picture_t pointer from the fifo but does not
+ * remove it. The picture returned has been hold for you so you
+ * must call picture_Release on it.
+ *
+ * If the fifo is empty, it return NULL without waiting.
+ */
+VLC_API picture_t * picture_fifo_Peek( picture_fifo_t * ) VLC_USED;
+
+/**
+ * It saves a picture_t into the fifo.
+ */
+VLC_API void picture_fifo_Push( picture_fifo_t *, picture_t * );
+
+/**
+ * It release all picture inside the fifo that have a lower or equal date
+ * if flush_before or higher or equal to if not flush_before than the given one.
+ *
+ * All pictures inside the fifo will be released by picture_Release.
+ */
+VLC_API void picture_fifo_Flush( picture_fifo_t *, mtime_t date, bool flush_before );
+
+/**
+ * It applies a delta on all the picture timestamp.
+ */
+VLC_API void picture_fifo_OffsetDate( picture_fifo_t *, mtime_t delta );
+
+
+#endif /* VLC_PICTURE_FIFO_H */
+

=== added file 'DivCity/DivCity/vlc/plugins/vlc_picture_pool.h'
--- DivCity/DivCity/vlc/plugins/vlc_picture_pool.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_picture_pool.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,126 @@
+/*****************************************************************************
+ * vlc_picture_pool.h: picture pool definitions
+ *****************************************************************************
+ * Copyright (C) 2009 VLC authors and VideoLAN
+ * $Id: d4574dc5a1dfd2d873c6f286ee612462f886bb33 $
+ *
+ * Authors: Laurent Aimar <fenrir _AT_ videolan _DOT_ org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_PICTURE_POOL_H
+#define VLC_PICTURE_POOL_H 1
+
+/**
+ * \file
+ * This file defines picture pool structures and functions in vlc
+ */
+
+#include <vlc_picture.h>
+
+/**
+ * Picture pool handle
+ *
+ * XXX it is not thread safe, all pool manipulations and picture_Release
+ * must be properly locked if needed.
+ */
+typedef struct picture_pool_t picture_pool_t;
+
+/**
+ * Picture pool configuration
+ */
+typedef struct {
+    int       picture_count;
+    picture_t **picture;
+
+    int       (*lock)(picture_t *);
+    void      (*unlock)(picture_t *);
+} picture_pool_configuration_t;
+
+/**
+ * It creates a picture_pool_t wrapping the given configuration.
+ *
+ * It avoids useless picture creations/destructions.
+ * The given picture must not have a reference count greater than 1.
+ * The pool takes ownership of the picture and MUST not be used directly.
+ * When deleted, the pool will release the pictures using picture_Release.
+ * If defined, picture_pool_configuration_t::lock will be called before
+ * a picture is used, and picture_pool_configuration_t::unlock will be called
+ * as soon as a picture is unused. They are allowed to modify picture_t::p and
+ * access picture_t::p_sys.
+ */
+VLC_API picture_pool_t * picture_pool_NewExtended( const picture_pool_configuration_t * ) VLC_USED;
+
+/**
+ * It creates a picture_pool_t wrapping the given arrays of picture.
+ *
+ * It is provided as convenience.
+ */
+VLC_API picture_pool_t * picture_pool_New( int picture_count, picture_t *picture[] ) VLC_USED;
+
+/**
+ * It creates a picture_pool_t creating images using the given format.
+ *
+ * Provided for convenience.
+ */
+VLC_API picture_pool_t * picture_pool_NewFromFormat( const video_format_t *, int picture_count ) VLC_USED;
+
+/**
+ * It destroys a pool created by picture_pool_New.
+ *
+ * All pictures must already be released to the pool. The pool will then
+ * released them.
+ */
+VLC_API void picture_pool_Delete( picture_pool_t * );
+
+/**
+ * It retreives a picture_t from a pool.
+ *
+ * The picture must be release by using picture_Release.
+ */
+VLC_API picture_t * picture_pool_Get( picture_pool_t * ) VLC_USED;
+
+/**
+ * It forces the next picture_pool_Get to return a picture even if no
+ * pictures are free.
+ *
+ * If b_reset is true, all pictures will be marked as free.
+ *
+ * It does it by releasing itself the oldest used picture if none is
+ * available.
+ * XXX it should be used with great care, the only reason you may need
+ * it is to workaround a bug.
+ */
+VLC_API void picture_pool_NonEmpty( picture_pool_t *, bool reset );
+
+/**
+ * It reserves picture_count pictures from the given pool and returns
+ * a new pool with thoses pictures.
+ *
+ * The master pool must be full.
+ * The returned pool must be deleted before the master pool.
+ * When deleted, all pictures return to the master pool.
+ */
+VLC_API picture_pool_t * picture_pool_Reserve(picture_pool_t *, int picture_count) VLC_USED;
+
+/**
+ * It returns the size of the given pool.
+ */
+VLC_API int picture_pool_GetSize(picture_pool_t *);
+
+
+#endif /* VLC_PICTURE_POOL_H */
+

=== added file 'DivCity/DivCity/vlc/plugins/vlc_playlist.h'
--- DivCity/DivCity/vlc/plugins/vlc_playlist.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_playlist.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,396 @@
+/*****************************************************************************
+ * vlc_playlist.h : Playlist functions
+ *****************************************************************************
+ * Copyright (C) 1999-2004 VLC authors and VideoLAN
+ * $Id: ca422608889bdea7adfa1dbe03a1f580e9b92e0c $
+ *
+ * Authors: Samuel Hocevar <sam@zoy.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_PLAYLIST_H_
+#define VLC_PLAYLIST_H_
+
+# ifdef __cplusplus
+extern "C" {
+# endif
+
+#include <vlc_input.h>
+#include <vlc_events.h>
+
+TYPEDEF_ARRAY(playlist_item_t*, playlist_item_array_t)
+
+/**
+ * \file
+ * This file contain structures and function prototypes related
+ * to the playlist in vlc
+ *
+ * \defgroup vlc_playlist Playlist
+ *
+ * The VLC playlist system has a tree structure. This allows advanced
+ * categorization, like for SAP streams (which are grouped by "sap groups").
+ *
+ * The base structure for all playlist operations is the input_item_t. This
+ * contains all information needed to play a stream and get info, ie, mostly,
+ * mrl and metadata. This structure contains a unique i_id field. ids are
+ * not recycled when an item is destroyed.
+ *
+ * Input items are not used directly, but through playlist items.
+ * The playlist items are themselves in a tree structure. They only contain
+ * a link to the input item, a unique id and a few flags. the playlist
+ * item id is NOT the same as the input item id.
+ * Several playlist items can be attached to a single input item. The input
+ * item is refcounted and is automatically destroyed when it is not used
+ * anymore.
+ *
+ * The top-level items are the main media sources and include:
+ * playlist, media library, SAP, Shoutcast, devices, ...
+ *
+ * It is envisioned that a third tree will appear: VLM, but it's not done yet
+ *
+ * The playlist also stores, for utility purposes, an array of all input
+ * items, an array of all playlist items and an array of all playlist items
+ * and nodes (both are represented by the same structure).
+ *
+ * So, here is an example:
+ * \verbatim
+ * Inputs array
+ *  - input 1 -> name = foo 1 uri = ...
+ *  - input 2 -> name = foo 2 uri = ...
+ *
+ * Playlist items tree
+ * - playlist (id 1)
+ *    - category 1 (id 2)
+ *      - foo 2 (id 6 - input 2)
+ * - media library (id 2)
+ *    - foo 1 (id 5 - input 1)
+ * \endverbatim
+ *
+ * Sometimes, an item creates subitems. This happens for the directory access
+ * for example. In that case, if the item is under the "playlist" top-level item
+ * and playlist is configured to be flat then the item will be deleted and
+ * replaced with new subitems. If the item is under another top-level item, it
+ * will be transformed to a node and removed from the list of all items without
+ * nodes.
+ *
+ * For "standard" item addition, you can use playlist_Add, playlist_AddExt
+ * (more options) or playlist_AddInput if you already created your input
+ * item. This will add the item at the root of "Playlist" or of "Media library"
+ * in each of the two trees.
+ *
+ * You can create nodes with playlist_NodeCreate and can create items from
+ * existing input items to be placed under any node with playlist_NodeAddInput.
+ *
+ * To delete an item, use playlist_DeleteFromInput( p_item ) which will
+ * remove all occurrences of the input.
+ *
+ *
+ * The playlist defines the following event variables:
+ *
+ * - "item-change": It will contain the input_item_t->i_id of a changed input
+ * item monitored by the playlist.
+ * - "item-current": It will contain a input_item_t->i_id of the current
+ * item being played.
+ *
+ * - "playlist-item-append": It will contain a pointer to a playlist_add_t.
+ * - "playlist-item-deleted": It will contain the playlist_item_t->i_id of a
+ * deleted playlist_item_t.
+ *
+ * - "leaf-to-parent": It will contain the playlist_item_t->i_id of an item that is transformed
+ *   into a node.
+ *
+ * The playlist contains rate-variable which is propagated to current input if available
+ * also rate-slower/rate-faster is in use
+ *
+ * XXX Be really carefull, playlist_item_t->i_id and input_item_t->i_id are not
+ * the same. Yes, the situation is pretty bad.
+ *
+ * @{
+ */
+
+/** Helper structure to export to file part of the playlist */
+typedef struct playlist_export_t
+{
+    VLC_COMMON_MEMBERS
+    const char *psz_filename;
+    FILE *p_file;
+    playlist_item_t *p_root;
+} playlist_export_t;
+
+/** playlist item / node */
+struct playlist_item_t
+{
+    input_item_t           *p_input;    /**< Linked input item */
+
+    playlist_item_t      **pp_children; /**< Children nodes/items */
+    playlist_item_t       *p_parent;    /**< Item parent */
+    int                    i_children;  /**< Number of children, -1 if not a node */
+
+    int                    i_id;        /**< Playlist item specific id */
+    uint8_t                i_flags;     /**< Flags \see playlist_item_flags_e */
+
+    playlist_t            *p_playlist;  /**< Parent playlist */
+};
+
+typedef enum {
+    PLAYLIST_SAVE_FLAG         = 0x0001,  /**< Must it be saved */
+    PLAYLIST_SKIP_FLAG         = 0x0002,  /**< Must playlist skip after it ? */
+    PLAYLIST_DBL_FLAG          = 0x0004,  /**< Is it disabled ? */
+    PLAYLIST_RO_FLAG           = 0x0008,  /**< Write-enabled ? */
+    PLAYLIST_REMOVE_FLAG       = 0x0010,  /**< Remove this item at the end */
+    PLAYLIST_EXPANDED_FLAG     = 0x0020,  /**< Expanded node */
+    PLAYLIST_SUBITEM_STOP_FLAG = 0x0040,  /**< Must playlist stop if the item gets subitems ?*/
+} playlist_item_flags_e;
+
+/** Playlist status */
+typedef enum
+{ PLAYLIST_STOPPED,PLAYLIST_RUNNING,PLAYLIST_PAUSED } playlist_status_t;
+
+/** Structure containing information about the playlist */
+struct playlist_t
+{
+    VLC_COMMON_MEMBERS
+
+    playlist_item_array_t items; /**< Arrays of items */
+    playlist_item_array_t all_items; /**< Array of items and nodes */
+
+    playlist_item_array_t current; /**< Items currently being played */
+    int                   i_current_index; /**< Index in current array */
+
+    /* Predefined items */
+    playlist_item_t *     p_root;
+    playlist_item_t *     p_playing;
+    playlist_item_t *     p_media_library;
+
+    //Phony ones, point to those above;
+    playlist_item_t *     p_root_category; /**< Root of category tree */
+    playlist_item_t *     p_root_onelevel; /**< Root of onelevel tree */
+    playlist_item_t *     p_local_category; /** < "Playlist" in CATEGORY view */
+    playlist_item_t *     p_ml_category; /** < "Library" in CATEGORY view */
+    playlist_item_t *     p_local_onelevel; /** < "Playlist" in ONELEVEL view */
+    playlist_item_t *     p_ml_onelevel; /** < "Library" in ONELEVEL view */
+};
+
+/** Helper to add an item */
+struct playlist_add_t
+{
+    int i_node; /**< Playist id of the parent node */
+    int i_item; /**< Playist id of the playlist_item_t */
+};
+
+/* A bit of macro magic to generate an enum out of the following list,
+ * and later, to generate a list of static functions out of the same list.
+ * There is also SORT_RANDOM, which is always last and handled specially.
+ */
+#define VLC_DEFINE_SORT_FUNCTIONS \
+    DEF( SORT_ID )\
+    DEF( SORT_TITLE )\
+    DEF( SORT_TITLE_NODES_FIRST )\
+    DEF( SORT_ARTIST )\
+    DEF( SORT_GENRE )\
+    DEF( SORT_DURATION )\
+    DEF( SORT_TITLE_NUMERIC )\
+    DEF( SORT_ALBUM )\
+    DEF( SORT_TRACK_NUMBER )\
+    DEF( SORT_DESCRIPTION )\
+    DEF( SORT_RATING )\
+    DEF( SORT_URI )
+
+#define DEF( s ) s,
+enum
+{
+    VLC_DEFINE_SORT_FUNCTIONS
+    SORT_RANDOM,
+    NUM_SORT_FNS=SORT_RANDOM
+};
+#undef  DEF
+#ifndef VLC_INTERNAL_PLAYLIST_SORT_FUNCTIONS
+#undef  VLC_DEFINE_SORT_FUNCTIONS
+#endif
+
+enum
+{
+    ORDER_NORMAL = 0,
+    ORDER_REVERSE = 1,
+};
+
+/* Used by playlist_Import */
+#define PLAYLIST_INSERT          0x0001
+#define PLAYLIST_APPEND          0x0002
+#define PLAYLIST_GO              0x0004
+#define PLAYLIST_PREPARSE        0x0008
+#define PLAYLIST_SPREPARSE       0x0010
+#define PLAYLIST_NO_REBUILD      0x0020
+
+#define PLAYLIST_END           -666
+
+enum pl_locked_state
+{
+    pl_Locked = true,
+    pl_Unlocked = false
+};
+
+/*****************************************************************************
+ * Prototypes
+ *****************************************************************************/
+
+/* Helpers */
+#define PL_LOCK playlist_Lock( p_playlist )
+#define PL_UNLOCK playlist_Unlock( p_playlist )
+#define PL_ASSERT_LOCKED playlist_AssertLocked( p_playlist )
+
+VLC_API playlist_t * pl_Get( vlc_object_t * ) VLC_USED;
+#define pl_Get( a ) pl_Get( VLC_OBJECT(a) )
+
+/* Playlist control */
+#define playlist_Play(p) playlist_Control(p,PLAYLIST_PLAY, pl_Unlocked )
+#define playlist_Pause(p) playlist_Control(p,PLAYLIST_PAUSE, pl_Unlocked )
+#define playlist_Stop(p) playlist_Control(p,PLAYLIST_STOP, pl_Unlocked )
+#define playlist_Next(p) playlist_Control(p,PLAYLIST_SKIP, pl_Unlocked, 1)
+#define playlist_Prev(p) playlist_Control(p,PLAYLIST_SKIP, pl_Unlocked, -1)
+#define playlist_Skip(p,i) playlist_Control(p,PLAYLIST_SKIP, pl_Unlocked,  (i) )
+
+VLC_API void playlist_Lock( playlist_t * );
+VLC_API void playlist_Unlock( playlist_t * );
+VLC_API void playlist_AssertLocked( playlist_t * );
+
+/**
+ * Do a playlist action.
+ * If there is something in the playlist then you can do playlist actions.
+ * Possible queries are listed in vlc_common.h
+ * \param p_playlist the playlist to do the command on
+ * \param i_query the command to do
+ * \param b_locked TRUE if playlist is locked when entering this function
+ * \param variable number of arguments
+ * \return VLC_SUCCESS or an error
+ */
+VLC_API int playlist_Control( playlist_t *p_playlist, int i_query, bool b_locked, ...  );
+
+/** Get current playing input. The object is retained.
+ */
+VLC_API input_thread_t * playlist_CurrentInput( playlist_t *p_playlist ) VLC_USED;
+
+/** Clear the playlist
+ * \param b_locked TRUE if playlist is locked when entering this function
+ */
+VLC_API void playlist_Clear( playlist_t *, bool );
+
+/** Enqueue an input item for preparsing */
+VLC_API int playlist_PreparseEnqueue(playlist_t *, input_item_t * );
+
+/** Request the art for an input item to be fetched */
+VLC_API int playlist_AskForArtEnqueue(playlist_t *, input_item_t * );
+
+/* Playlist sorting */
+VLC_API int playlist_TreeMove( playlist_t *, playlist_item_t *, playlist_item_t *, int );
+VLC_API int playlist_TreeMoveMany( playlist_t *, int, playlist_item_t **, playlist_item_t *, int );
+VLC_API int playlist_RecursiveNodeSort( playlist_t *, playlist_item_t *,int, int );
+
+VLC_API playlist_item_t * playlist_CurrentPlayingItem( playlist_t * ) VLC_USED;
+VLC_API int playlist_Status( playlist_t * );
+
+/**
+ * Export a node of the playlist to a certain type of playlistfile
+ * \param p_playlist the playlist to export
+ * \param psz_filename the location where the exported file will be saved
+ * \param p_export_root the root node to export
+ * \param psz_type the type of playlist file to create (m3u, pls, ..)
+ * \return VLC_SUCCESS on success
+ */
+VLC_API int playlist_Export( playlist_t *p_playlist, const char *psz_name, playlist_item_t *p_export_root, const char *psz_type );
+
+/**
+ * Open a playlist file, add its content to the current playlist
+ */
+VLC_API int playlist_Import( playlist_t *p_playlist, const char *psz_file );
+
+/********************** Services discovery ***********************/
+
+/** Add a list of comma-separated service discovery modules */
+VLC_API int playlist_ServicesDiscoveryAdd(playlist_t *, const char *);
+/** Remove a services discovery module by name */
+VLC_API int playlist_ServicesDiscoveryRemove(playlist_t *, const char *);
+/** Check whether a given SD is loaded */
+VLC_API bool playlist_IsServicesDiscoveryLoaded( playlist_t *,const char *) VLC_DEPRECATED;
+/** Query a services discovery */
+VLC_API int playlist_ServicesDiscoveryControl( playlist_t *, const char *, int, ... );
+
+
+
+/********************************************************
+ * Item management
+ ********************************************************/
+
+/*************************** Item deletion **************************/
+VLC_API int playlist_DeleteFromInput( playlist_t *, input_item_t *, bool );
+
+/******************** Item addition ********************/
+VLC_API int playlist_Add( playlist_t *, const char *, const char *, int, int, bool, bool );
+VLC_API int playlist_AddExt( playlist_t *, const char *, const char *, int, int, mtime_t, int, const char *const *, unsigned, bool, bool );
+VLC_API int playlist_AddInput( playlist_t *, input_item_t *, int, int, bool, bool );
+VLC_API playlist_item_t * playlist_NodeAddInput( playlist_t *, input_item_t *, playlist_item_t *, int, int, bool );
+VLC_API int playlist_NodeAddCopy( playlist_t *, playlist_item_t *, playlist_item_t *, int );
+
+/********************************** Item search *************************/
+VLC_API playlist_item_t * playlist_ItemGetById(playlist_t *, int ) VLC_USED;
+VLC_API playlist_item_t * playlist_ItemGetByInput(playlist_t *,input_item_t * ) VLC_USED;
+
+VLC_API int playlist_LiveSearchUpdate(playlist_t *, playlist_item_t *, const char *, bool );
+
+/********************************************************
+ * Tree management
+ ********************************************************/
+/* Node management */
+VLC_API playlist_item_t * playlist_NodeCreate( playlist_t *, const char *, playlist_item_t * p_parent, int i_pos, int i_flags, input_item_t * );
+VLC_API int playlist_NodeAppend(playlist_t *,playlist_item_t*,playlist_item_t *);
+VLC_API int playlist_NodeInsert(playlist_t *,playlist_item_t*,playlist_item_t *, int);
+VLC_API int playlist_NodeRemoveItem(playlist_t *,playlist_item_t*,playlist_item_t *);
+VLC_API playlist_item_t * playlist_ChildSearchName(playlist_item_t*, const char* ) VLC_USED;
+VLC_API int playlist_NodeDelete( playlist_t *, playlist_item_t *, bool , bool );
+
+VLC_API playlist_item_t * playlist_GetNextLeaf( playlist_t *p_playlist, playlist_item_t *p_root, playlist_item_t *p_item, bool b_ena, bool b_unplayed ) VLC_USED;
+VLC_API playlist_item_t * playlist_GetPrevLeaf( playlist_t *p_playlist, playlist_item_t *p_root, playlist_item_t *p_item, bool b_ena, bool b_unplayed ) VLC_USED;
+
+/***********************************************************************
+ * Inline functions
+ ***********************************************************************/
+/** Small helper tp get current playing input or NULL. Release the input after use. */
+#define pl_CurrentInput(a) __pl_CurrentInput( VLC_OBJECT(a) )
+static  inline input_thread_t * __pl_CurrentInput( vlc_object_t * p_this )
+{
+    return playlist_CurrentInput( pl_Get( p_this ) );
+}
+
+/** Tell if the playlist is empty */
+static inline bool playlist_IsEmpty( playlist_t *p_playlist )
+{
+    PL_ASSERT_LOCKED;
+    return p_playlist->items.i_size == 0;
+}
+
+/** Tell the number of items in the current playing context */
+static inline int playlist_CurrentSize( playlist_t *p_playlist )
+{
+    PL_ASSERT_LOCKED;
+    return p_playlist->current.i_size;
+}
+
+/** @} */
+# ifdef __cplusplus
+}
+# endif
+
+#endif

=== added file 'DivCity/DivCity/vlc/plugins/vlc_plugin.h'
--- DivCity/DivCity/vlc/plugins/vlc_plugin.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_plugin.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,455 @@
+/*****************************************************************************
+ * vlc_plugin.h : Macros used from within a module.
+ *****************************************************************************
+ * Copyright (C) 2001-2006 VLC authors and VideoLAN
+ * Copyright Â© 2007-2009 RÃ©mi Denis-Courmont
+ *
+ * Authors: Samuel Hocevar <sam@zoy.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef LIBVLC_MODULES_MACROS_H
+# define LIBVLC_MODULES_MACROS_H 1
+
+/**
+ * \file
+ * This file implements plugin (module) macros used to define a vlc module.
+ */
+
+enum vlc_module_properties
+{
+    VLC_MODULE_CREATE,
+    VLC_CONFIG_CREATE,
+
+    /* DO NOT EVER REMOVE, INSERT OR REPLACE ANY ITEM! It would break the ABI!
+     * Append new items at the end ONLY. */
+    VLC_MODULE_CPU_REQUIREMENT=0x100,
+    VLC_MODULE_SHORTCUT,
+    VLC_MODULE_CAPABILITY,
+    VLC_MODULE_SCORE,
+    VLC_MODULE_CB_OPEN,
+    VLC_MODULE_CB_CLOSE,
+    VLC_MODULE_NO_UNLOAD,
+    VLC_MODULE_NAME,
+    VLC_MODULE_SHORTNAME,
+    VLC_MODULE_DESCRIPTION,
+    VLC_MODULE_HELP,
+    VLC_MODULE_TEXTDOMAIN,
+    /* Insert new VLC_MODULE_* here */
+
+    /* DO NOT EVER REMOVE, INSERT OR REPLACE ANY ITEM! It would break the ABI!
+     * Append new items at the end ONLY. */
+    VLC_CONFIG_NAME=0x1000,
+    /* command line name (args=const char *) */
+
+    VLC_CONFIG_VALUE,
+    /* actual value (args=int/double/const char *) */
+
+    VLC_CONFIG_RANGE,
+    /* minimum value (args=int/double/const char * twice) */
+
+    VLC_CONFIG_ADVANCED,
+    /* enable advanced flag (args=none) */
+
+    VLC_CONFIG_VOLATILE,
+    /* don't write variable to storage (args=none) */
+
+    VLC_CONFIG_PERSISTENT_OBSOLETE,
+    /* unused (ignored) */
+
+    VLC_CONFIG_PRIVATE,
+    /* hide from user (args=none) */
+
+    VLC_CONFIG_REMOVED,
+    /* tag as no longer supported (args=none) */
+
+    VLC_CONFIG_CAPABILITY,
+    /* capability for a module or list thereof (args=const char*) */
+
+    VLC_CONFIG_SHORTCUT,
+    /* one-character (short) command line option name (args=char) */
+
+    VLC_CONFIG_OLDNAME_OBSOLETE,
+    /* unused (ignored) */
+
+    VLC_CONFIG_SAFE,
+    /* tag as modifiable by untrusted input item "sources" (args=none) */
+
+    VLC_CONFIG_DESC,
+    /* description (args=const char *, const char *, const char *) */
+
+    VLC_CONFIG_LIST,
+    /* possible values list
+     * (args=const char *, size_t, const <type> *, const char *const *) */
+
+    VLC_CONFIG_ADD_ACTION,
+    /* add value change callback
+     * (args=const char *, vlc_callback_t, const char *) */
+
+    /* Insert new VLC_CONFIG_* here */
+};
+
+/**
+ * Current plugin ABI version
+ */
+# define MODULE_SYMBOL 1_2_0l
+# define MODULE_SUFFIX "__1_2_0l"
+
+/*****************************************************************************
+ * Add a few defines. You do not want to read this section. Really.
+ *****************************************************************************/
+
+/* Explanation:
+ *
+ * if linking a module statically, we will need:
+ * #define MODULE_FUNC( zog ) module_foo_zog
+ *
+ * this can't easily be done with the C preprocessor, thus a few ugly hacks.
+ */
+
+/* I need to do _this_ to change Â« foo bar Â» to Â« module_foo_bar Â» ! */
+#define CONCATENATE( y, z ) CRUDE_HACK( y, z )
+#define CRUDE_HACK( y, z )  y##__##z
+
+/* If the module is built-in, then we need to define foo_InitModule instead
+ * of InitModule. Same for Activate- and DeactivateModule. */
+#ifdef __PLUGIN__
+#   define __VLC_SYMBOL( symbol  ) CONCATENATE( symbol, MODULE_SYMBOL )
+#else
+#   define __VLC_SYMBOL( symbol )  CONCATENATE( symbol, MODULE_NAME )
+#endif
+
+#define CDECL_SYMBOL
+#if defined (__PLUGIN__)
+# if defined (WIN32)
+#   define DLL_SYMBOL              __declspec(dllexport)
+#   undef CDECL_SYMBOL
+#   define CDECL_SYMBOL            __cdecl
+# elif VLC_GCC_VERSION(4,0)
+#   define DLL_SYMBOL              __attribute__((visibility("default")))
+# else
+#  define DLL_SYMBOL
+# endif
+#else
+# define DLL_SYMBOL
+#endif
+
+#if defined( __cplusplus )
+#   define EXTERN_SYMBOL           extern "C"
+#else
+#   define EXTERN_SYMBOL
+#endif
+
+typedef int (*vlc_set_cb) (void *, void *, int, ...);
+
+#define vlc_plugin_set(...) vlc_set (opaque,   NULL, __VA_ARGS__)
+#define vlc_module_set(...) vlc_set (opaque, module, __VA_ARGS__)
+#define vlc_config_set(...) vlc_set (opaque, config, __VA_ARGS__)
+
+/*
+ * InitModule: this function is called once and only once, when the module
+ * is looked at for the first time. We get the useful data from it, for
+ * instance the module name, its shortcuts, its capabilities... we also create
+ * a copy of its config because the module can be unloaded at any time.
+ */
+#define vlc_module_begin() \
+EXTERN_SYMBOL DLL_SYMBOL \
+int CDECL_SYMBOL __VLC_SYMBOL(vlc_entry) (vlc_set_cb, void *); \
+EXTERN_SYMBOL DLL_SYMBOL \
+int CDECL_SYMBOL __VLC_SYMBOL(vlc_entry) (vlc_set_cb vlc_set, void *opaque) \
+{ \
+    module_t *module; \
+    module_config_t *config = NULL; \
+    if (vlc_plugin_set (VLC_MODULE_CREATE, &module)) \
+        goto error; \
+    if (vlc_module_set (VLC_MODULE_NAME, (MODULE_STRING))) \
+        goto error;
+
+#define vlc_module_end() \
+    (void) config; \
+    return 0; \
+error: \
+    return -1; \
+} \
+VLC_METADATA_EXPORTS
+
+#define add_submodule( ) \
+    if (vlc_plugin_set (VLC_MODULE_CREATE, &module)) \
+        goto error;
+
+#define add_shortcut( ... ) \
+{ \
+    const char *shortcuts[] = { __VA_ARGS__ }; \
+    if (vlc_module_set (VLC_MODULE_SHORTCUT, \
+                        sizeof(shortcuts)/sizeof(shortcuts[0]), shortcuts)) \
+        goto error; \
+}
+
+#define set_shortname( shortname ) \
+    if (vlc_module_set (VLC_MODULE_SHORTNAME, (const char *)(shortname))) \
+        goto error;
+
+#define set_description( desc ) \
+    if (vlc_module_set (VLC_MODULE_DESCRIPTION, (const char *)(desc))) \
+        goto error;
+
+#define set_help( help ) \
+    if (vlc_module_set (VLC_MODULE_HELP, (const char *)(help))) \
+        goto error;
+
+#define set_capability( cap, score ) \
+    if (vlc_module_set (VLC_MODULE_CAPABILITY, (const char *)(cap)) \
+     || vlc_module_set (VLC_MODULE_SCORE, (int)(score))) \
+        goto error;
+
+#define set_callbacks( activate, deactivate ) \
+    if (vlc_module_set (VLC_MODULE_CB_OPEN, activate) \
+     || vlc_module_set (VLC_MODULE_CB_CLOSE, deactivate)) \
+        goto error;
+
+#define cannot_unload_broken_library( ) \
+    if (vlc_module_set (VLC_MODULE_NO_UNLOAD)) \
+        goto error;
+
+#define set_text_domain( dom ) \
+    if (vlc_plugin_set (VLC_MODULE_TEXTDOMAIN, (dom))) \
+        goto error;
+
+/*****************************************************************************
+ * Macros used to build the configuration structure.
+ *
+ * Note that internally we support only 3 types of config data: int, float
+ *   and string.
+ *   The other types declared here just map to one of these 3 basic types but
+ *   have the advantage of also providing very good hints to a configuration
+ *   interface so as to make it more user friendly.
+ * The configuration structure also includes category hints. These hints can
+ *   provide a configuration interface with some very useful data and again
+ *   allow for a more user friendly interface.
+ *****************************************************************************/
+
+#define add_type_inner( type ) \
+    vlc_plugin_set (VLC_CONFIG_CREATE, (type), &config);
+
+#define add_typedesc_inner( type, text, longtext ) \
+    add_type_inner( type ) \
+    vlc_config_set (VLC_CONFIG_DESC, \
+                    (const char *)(text), (const char *)(longtext));
+
+#define add_typeadv_inner( type, text, longtext, advc ) \
+    add_typedesc_inner( type, text, longtext ) \
+    if (advc) vlc_config_set (VLC_CONFIG_ADVANCED);
+
+#define add_typename_inner( type, name, text, longtext, advc ) \
+    add_typeadv_inner( type, text, longtext, advc ) \
+    vlc_config_set (VLC_CONFIG_NAME, (const char *)(name));
+
+#define add_string_inner( type, name, text, longtext, advc, v ) \
+    add_typename_inner( type, name, text, longtext, advc ) \
+    vlc_config_set (VLC_CONFIG_VALUE, (const char *)(v));
+
+#define add_int_inner( type, name, text, longtext, advc, v ) \
+    add_typename_inner( type, name, text, longtext, advc ) \
+    vlc_config_set (VLC_CONFIG_VALUE, (int64_t)(v));
+
+
+#define set_category( i_id ) \
+    add_type_inner( CONFIG_CATEGORY ) \
+    vlc_config_set (VLC_CONFIG_VALUE, (int64_t)(i_id));
+
+#define set_subcategory( i_id ) \
+    add_type_inner( CONFIG_SUBCATEGORY ) \
+    vlc_config_set (VLC_CONFIG_VALUE, (int64_t)(i_id));
+
+#define set_section( text, longtext ) \
+    add_typedesc_inner( CONFIG_SECTION, text, longtext )
+
+#define add_category_hint( text, longtext, advc ) \
+    add_typeadv_inner( CONFIG_HINT_CATEGORY, text, longtext, advc )
+
+#define add_subcategory_hint( text, longtext ) \
+    add_typedesc_inner( CONFIG_HINT_SUBCATEGORY, text, longtext )
+
+#define end_subcategory_hint \
+    add_type_inner( CONFIG_HINT_SUBCATEGORY_END )
+
+#define add_usage_hint( text ) \
+    add_typedesc_inner( CONFIG_HINT_USAGE, text, NULL )
+
+#define add_string( name, value, text, longtext, advc ) \
+    add_string_inner( CONFIG_ITEM_STRING, name, text, longtext, advc, \
+                      value )
+
+#define add_password( name, value, text, longtext, advc ) \
+    add_string_inner( CONFIG_ITEM_PASSWORD, name, text, longtext, advc, \
+                      value )
+
+#define add_loadfile( name, value, text, longtext, advc ) \
+    add_string_inner( CONFIG_ITEM_LOADFILE, name, text, longtext, advc, \
+                      value )
+
+#define add_savefile( name, value, text, longtext, advc ) \
+    add_string_inner( CONFIG_ITEM_SAVEFILE, name, text, longtext, advc, \
+                      value )
+
+#define add_directory( name, value, text, longtext, advc ) \
+    add_string_inner( CONFIG_ITEM_DIRECTORY, name, text, longtext, advc, \
+                      value )
+
+#define add_font( name, value, text, longtext, advc )\
+    add_string_inner( CONFIG_ITEM_FONT, name, text, longtext, advc, \
+                      value )
+
+#define add_module( name, psz_caps, value, text, longtext, advc ) \
+    add_string_inner( CONFIG_ITEM_MODULE, name, text, longtext, advc, \
+                      value ) \
+    vlc_config_set (VLC_CONFIG_CAPABILITY, (const char *)(psz_caps));
+
+#define add_module_list( name, psz_caps, value, text, longtext, advc ) \
+    add_string_inner( CONFIG_ITEM_MODULE_LIST, name, text, longtext, advc, \
+                      value ) \
+    vlc_config_set (VLC_CONFIG_CAPABILITY, (const char *)(psz_caps));
+
+#ifndef __PLUGIN__
+#define add_module_cat( name, i_subcategory, value, text, longtext, advc ) \
+    add_string_inner( CONFIG_ITEM_MODULE_CAT, name, text, longtext, advc, \
+                      value ) \
+    change_integer_range (i_subcategory /* gruik */, 0);
+
+#define add_module_list_cat( name, i_subcategory, value, text, longtext, advc ) \
+    add_string_inner( CONFIG_ITEM_MODULE_LIST_CAT, name, text, longtext, \
+                      advc, value ) \
+    change_integer_range (i_subcategory /* gruik */, 0);
+#endif
+
+#define add_integer( name, value, text, longtext, advc ) \
+    add_int_inner( CONFIG_ITEM_INTEGER, name, text, longtext, advc, value )
+
+#define add_rgb( name, value, text, longtext, advc ) \
+    add_int_inner( CONFIG_ITEM_RGB, name, text, longtext, advc, value ) \
+    change_integer_range( 0, 0xFFFFFF )
+
+#define add_key( name, value, text, longtext, advc ) \
+    add_string_inner( CONFIG_ITEM_KEY, "global-" name, text, longtext, advc, \
+                   KEY_UNSET ) \
+    add_string_inner( CONFIG_ITEM_KEY, name, text, longtext, advc, value )
+
+#define add_integer_with_range( name, value, i_min, i_max, text, longtext, advc ) \
+    add_integer( name, value, text, longtext, advc ) \
+    change_integer_range( i_min, i_max )
+
+#define add_float( name, v, text, longtext, advc ) \
+    add_typename_inner( CONFIG_ITEM_FLOAT, name, text, longtext, advc ) \
+    vlc_config_set (VLC_CONFIG_VALUE, (double)(v));
+
+#define add_float_with_range( name, value, f_min, f_max, text, longtext, advc ) \
+    add_float( name, value, text, longtext, advc ) \
+    change_float_range( f_min, f_max )
+
+#define add_bool( name, v, text, longtext, advc ) \
+    add_typename_inner( CONFIG_ITEM_BOOL, name, text, longtext, advc ) \
+    if (v) vlc_config_set (VLC_CONFIG_VALUE, (int64_t)true);
+
+/* For removed option */
+#define add_obsolete_inner( name, type ) \
+    add_type_inner( type ) \
+    vlc_config_set (VLC_CONFIG_NAME, (const char *)(name)); \
+    vlc_config_set (VLC_CONFIG_REMOVED);
+
+#define add_obsolete_bool( name ) \
+        add_obsolete_inner( name, CONFIG_ITEM_BOOL )
+
+#define add_obsolete_integer( name ) \
+        add_obsolete_inner( name, CONFIG_ITEM_INTEGER )
+
+#define add_obsolete_float( name ) \
+        add_obsolete_inner( name, CONFIG_ITEM_FLOAT )
+
+#define add_obsolete_string( name ) \
+        add_obsolete_inner( name, CONFIG_ITEM_STRING )
+
+/* Modifier macros for the config options (used for fine tuning) */
+
+#define change_short( ch ) \
+    vlc_config_set (VLC_CONFIG_SHORTCUT, (int)(ch));
+
+#define change_string_list( list, list_text, list_update_func ) \
+    vlc_config_set (VLC_CONFIG_LIST, \
+                    (size_t)(sizeof (list) / sizeof (char *)), \
+                    (const char *const *)(list), \
+                    (const char *const *)(list_text), \
+                    (vlc_callback_t)(list_update_func));
+
+#define change_integer_list( list, list_text ) \
+    vlc_config_set (VLC_CONFIG_LIST, \
+                    (size_t)(sizeof (list) / sizeof (int)), \
+                    (const int *)(list), \
+                    (const char *const *)(list_text), \
+                    (vlc_callback_t)(NULL));
+
+#define change_integer_range( minv, maxv ) \
+    vlc_config_set (VLC_CONFIG_RANGE, (int64_t)(minv), (int64_t)(maxv));
+
+#define change_float_range( minv, maxv ) \
+    vlc_config_set (VLC_CONFIG_RANGE, (double)(minv), (double)(maxv));
+
+#define change_action_add( pf_action, text ) \
+    vlc_config_set (VLC_CONFIG_ADD_ACTION, \
+                    (vlc_callback_t)(pf_action), (const char *)(text));
+
+/* For options that are saved but hidden from the preferences panel */
+#define change_private() \
+    vlc_config_set (VLC_CONFIG_PRIVATE);
+
+/* For options that cannot be saved in the configuration */
+#define change_volatile() \
+    change_private() \
+    vlc_config_set (VLC_CONFIG_VOLATILE);
+
+#define change_safe() \
+    vlc_config_set (VLC_CONFIG_SAFE);
+
+/* Meta data plugin exports */
+#define VLC_META_EXPORT( name, value ) \
+    EXTERN_SYMBOL DLL_SYMBOL const char * CDECL_SYMBOL \
+    __VLC_SYMBOL(vlc_entry_ ## name) (void); \
+    EXTERN_SYMBOL DLL_SYMBOL const char * CDECL_SYMBOL \
+    __VLC_SYMBOL(vlc_entry_ ## name) (void) \
+    { \
+         return value; \
+    }
+
+#if defined (__LIBVLC__)
+# define VLC_COPYRIGHT_EXPORT VLC_META_EXPORT (copyright, \
+    "\x43\x6f\x70\x79\x72\x69\x67\x68\x74\x20\x28\x43\x29\x20\x74\x68" \
+    "\x65\x20\x56\x69\x64\x65\x6f\x4c\x41\x4e\x20\x56\x4c\x43\x20\x6d" \
+    "\x65\x64\x69\x61\x20\x70\x6c\x61\x79\x65\x72\x20\x64\x65\x76\x65" \
+    "\x6c\x6f\x70\x65\x72\x73" )
+#elif !defined (VLC_COPYRIGHT_EXPORT)
+# define VLC_COPYRIGHT_EXPORT
+#endif
+#define VLC_LICENSE_EXPORT VLC_META_EXPORT (license, \
+    "\x4c\x69\x63\x65\x6e\x73\x65\x64\x20\x75\x6e\x64\x65\x72\x20\x74" \
+    "\x68\x65\x20\x74\x65\x72\x6d\x73\x20\x6f\x66\x20\x74\x68\x65\x20" \
+    "\x47\x4e\x55\x20\x47\x65\x6e\x65\x72\x61\x6c\x20\x50\x75\x62\x6c" \
+    "\x69\x63\x20\x4c\x69\x63\x65\x6e\x73\x65\x2c\x20\x76\x65\x72\x73" \
+    "\x69\x6f\x6e\x20\x32\x20\x6f\x72\x20\x6c\x61\x74\x65\x72\x2e" )
+
+#define VLC_METADATA_EXPORTS \
+    VLC_COPYRIGHT_EXPORT \
+    VLC_LICENSE_EXPORT
+
+#endif

=== added file 'DivCity/DivCity/vlc/plugins/vlc_probe.h'
--- DivCity/DivCity/vlc/plugins/vlc_probe.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_probe.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,69 @@
+/*****************************************************************************
+ * vlc_probe.h: service probing interface
+ *****************************************************************************
+ * Copyright (C) 2009 RÃ©mi Denis-Courmont
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_PROBE_H
+# define VLC_PROBE_H 1
+
+# include <stdlib.h>
+
+/**
+ * \file
+ * This file defines functions and structures to run-time probe VLC extensions
+ */
+
+# ifdef __cplusplus
+extern "C" {
+# endif
+
+void *vlc_probe (vlc_object_t *, const char *, size_t *restrict);
+#define vlc_probe(obj, cap, pcount) \
+        vlc_probe(VLC_OBJECT(obj), cap, pcount)
+
+struct vlc_probe_t
+{
+    VLC_COMMON_MEMBERS
+
+    void  *list;
+    size_t count;
+};
+
+typedef struct vlc_probe_t vlc_probe_t;
+
+static inline int vlc_probe_add(vlc_probe_t *obj, const void *data,
+                                size_t len)
+{
+    char *tab = (char *)realloc (obj->list, (obj->count + 1) * len);
+
+    if (unlikely(tab == NULL))
+        return VLC_ENOMEM;
+    memcpy(tab + (obj->count * len), data, len);
+    obj->list = tab;
+    obj->count++;
+    return VLC_SUCCESS;
+}
+
+# define VLC_PROBE_CONTINUE VLC_EGENERIC
+# define VLC_PROBE_STOP     VLC_SUCCESS
+
+# ifdef __cplusplus
+}
+# endif
+
+#endif

=== added file 'DivCity/DivCity/vlc/plugins/vlc_rand.h'
--- DivCity/DivCity/vlc/plugins/vlc_rand.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_rand.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,37 @@
+/*****************************************************************************
+ * vlc_rand.h: RNG
+ *****************************************************************************
+ * Copyright Â© 2007 RÃ©mi Denis-Courmont
+ * $Id: 3ae95ac04c55f46d116481eb89255b013f6d1c32 $
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_RAND_H
+# define VLC_RAND_H
+
+/**
+ * \file
+ * This file defined random number generator function in vlc
+ */
+
+VLC_API void vlc_rand_bytes(void *buf, size_t len);
+
+/* Interlocked (but not reproducible) functions for the POSIX PRNG */
+VLC_API double vlc_drand48(void) VLC_USED;
+VLC_API long vlc_lrand48(void) VLC_USED;
+VLC_API long vlc_mrand48(void) VLC_USED;
+
+#endif

=== added file 'DivCity/DivCity/vlc/plugins/vlc_services_discovery.h'
--- DivCity/DivCity/vlc/plugins/vlc_services_discovery.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_services_discovery.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,184 @@
+/*****************************************************************************
+ * vlc_services_discovery.h : Services Discover functions
+ *****************************************************************************
+ * Copyright (C) 1999-2004 VLC authors and VideoLAN
+ * $Id: 22df2fc8fd77c2036763a6202c784006dd6c44d7 $
+ *
+ * Authors: Pierre d'Herbemont <pdherbemont # videolan.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_SERVICES_DISCOVERY_H_
+#define VLC_SERVICES_DISCOVERY_H_
+
+#include <vlc_input.h>
+#include <vlc_events.h>
+#include <vlc_probe.h>
+
+/**
+ * \file
+ * This file lists functions and structures for service discovery (SD) in vlc
+ */
+
+# ifdef __cplusplus
+extern "C" {
+# endif
+
+/**
+ * @{
+ */
+
+/**
+ * Main service discovery structure to build a SD module
+ */
+struct services_discovery_t
+{
+    VLC_COMMON_MEMBERS
+    module_t *          p_module;             /**< Loaded module */
+
+    /**< Event manager
+     * You should access it through setters, outside of the core */
+    vlc_event_manager_t event_manager;
+
+    char *psz_name;                           /**< Main name of the SD */
+    config_chain_t *p_cfg;                    /**< Configuration for the SD */
+
+    /** Control function
+     * \see services_discovery_command_e
+     */
+    int ( *pf_control ) ( services_discovery_t *, int, va_list );
+
+    services_discovery_sys_t *p_sys;          /**< Custom private data */
+};
+
+/**
+ * Service discovery categories
+ * \see vlc_sd_probe_Add
+ */
+enum services_discovery_category_e
+{
+    SD_CAT_DEVICES = 1,           /**< Devices, like portable music players */
+    SD_CAT_LAN,                   /**< LAN/WAN services, like Upnp or SAP */
+    SD_CAT_INTERNET,              /**< Internet or Website channels services */
+    SD_CAT_MYCOMPUTER             /**< Computer services, like Discs or Apps */
+};
+
+/**
+ * Service discovery control commands
+ */
+enum services_discovery_command_e
+{
+    SD_CMD_SEARCH = 1,          /**< arg1 = query */
+    SD_CMD_DESCRIPTOR           /**< arg1 = services_discovery_descriptor_t* */
+};
+
+/**
+ * Service discovery capabilities
+ */
+enum services_discovery_capability_e
+{
+    SD_CAP_SEARCH = 1           /**< One can search in the SD */
+};
+
+/**
+ * Service discovery descriptor
+ * \see services_discovery_command_e
+ */
+typedef struct
+{
+    char *psz_short_desc;       /**< The short description, human-readable */
+    char *psz_icon_url;         /**< URL to the icon that represents it */
+    char *psz_url;              /**< URL for the service */
+    int   i_capabilities;       /**< \see services_discovery_capability_e */
+} services_discovery_descriptor_t;
+
+
+/***********************************************************************
+ * Service Discovery
+ ***********************************************************************/
+
+/**
+ * Ask for a research in the SD
+ * @param p_sd: the Service Discovery
+ * @param i_control: the command to issue
+ * @param args: the argument list
+ * @return VLC_SUCCESS in case of success, the error code overwise
+ */
+static inline int vlc_sd_control( services_discovery_t *p_sd, int i_control, va_list args )
+{
+    if( p_sd->pf_control )
+        return p_sd->pf_control( p_sd, i_control, args );
+    else
+        return VLC_EGENERIC;
+}
+
+/* Get the services discovery modules names to use in Create(), in a null
+ * terminated string array. Array and string must be freed after use. */
+VLC_API char ** vlc_sd_GetNames( vlc_object_t *, char ***, int ** ) VLC_USED;
+#define vlc_sd_GetNames(obj, pln, pcat ) \
+        vlc_sd_GetNames(VLC_OBJECT(obj), pln, pcat)
+
+/* Creation of a services_discovery object */
+VLC_API services_discovery_t * vlc_sd_Create( vlc_object_t *, const char * ) VLC_USED;
+VLC_API bool vlc_sd_Start( services_discovery_t * );
+VLC_API void vlc_sd_Stop( services_discovery_t * );
+VLC_API void vlc_sd_Destroy( services_discovery_t * );
+
+/**
+ * Helper to stop and destroy the Service Discovery
+ */
+static inline void vlc_sd_StopAndDestroy( services_discovery_t * p_this )
+{
+    vlc_sd_Stop( p_this );
+    vlc_sd_Destroy( p_this );
+}
+
+/* Read info from discovery object */
+VLC_API char * services_discovery_GetLocalizedName( services_discovery_t * p_this ) VLC_USED;
+
+/* Receive event notification (preferred way to get new items) */
+VLC_API vlc_event_manager_t * services_discovery_EventManager( services_discovery_t * p_this ) VLC_USED;
+
+/* Used by services_discovery to post update about their items */
+    /* About the psz_category, it is a legacy way to add info to the item,
+     * for more options, directly set the (meta) data on the input item */
+VLC_API void services_discovery_AddItem( services_discovery_t * p_this, input_item_t * p_item, const char * psz_category );
+VLC_API void services_discovery_RemoveItem( services_discovery_t * p_this, input_item_t * p_item );
+
+
+/* SD probing */
+
+VLC_API int vlc_sd_probe_Add(vlc_probe_t *, const char *, const char *, int category);
+
+#define VLC_SD_PROBE_SUBMODULE \
+    add_submodule() \
+        set_capability( "services probe", 100 ) \
+        set_callbacks( vlc_sd_probe_Open, NULL )
+
+#define VLC_SD_PROBE_HELPER(name, longname, cat) \
+static int vlc_sd_probe_Open (vlc_object_t *obj) \
+{ \
+    return vlc_sd_probe_Add ((struct vlc_probe_t *)obj, \
+                             name "{longname=\"" longname "\"}", \
+                             longname, cat); \
+}
+
+/** @} */
+# ifdef __cplusplus
+}
+# endif
+
+#endif

=== added file 'DivCity/DivCity/vlc/plugins/vlc_sout.h'
--- DivCity/DivCity/vlc/plugins/vlc_sout.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_sout.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,265 @@
+/*****************************************************************************
+ * stream_output.h : stream output module
+ *****************************************************************************
+ * Copyright (C) 2002-2008 VLC authors and VideoLAN
+ * $Id: 8c2e3428113a4900fc9ec197027fa808ff5b267f $
+ *
+ * Authors: Christophe Massiot <massiot@via.ecp.fr>
+ *          Laurent Aimar <fenrir@via.ecp.fr>
+ *          Eric Petit <titer@videolan.org>
+ *          Jean-Paul Saman <jpsaman #_at_# m2x.nl>
+ *          RÃ©mi Denis-Courmont
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_SOUT_H_
+#define VLC_SOUT_H_
+
+/**
+ * \file
+ * This file defines structures and functions for stream output in vlc
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <sys/types.h>
+#include <vlc_es.h>
+
+/** Stream output instance */
+struct sout_instance_t
+{
+    VLC_COMMON_MEMBERS
+
+    char *psz_sout;
+
+    /* meta data (Read only) XXX it won't be set before the first packet received */
+    vlc_meta_t          *p_meta;
+
+    /** count of output that can't control the space */
+    int                 i_out_pace_nocontrol;
+
+    vlc_mutex_t         lock;
+    sout_stream_t       *p_stream;
+
+    /** Private */
+    sout_instance_sys_t *p_sys;
+};
+
+/****************************************************************************
+ * sout_stream_id_t: opaque (private for all sout_stream_t)
+ ****************************************************************************/
+typedef struct sout_stream_id_t  sout_stream_id_t;
+
+/** Stream output access_output */
+struct sout_access_out_t
+{
+    VLC_COMMON_MEMBERS
+
+    module_t                *p_module;
+    char                    *psz_access;
+
+    int                      i_writes;
+    /** Local counter reset each time it is transferred to stats */
+    int64_t                  i_sent_bytes;
+
+    char                    *psz_path;
+    sout_access_out_sys_t   *p_sys;
+    int                     (*pf_seek)( sout_access_out_t *, off_t );
+    ssize_t                 (*pf_read)( sout_access_out_t *, block_t * );
+    ssize_t                 (*pf_write)( sout_access_out_t *, block_t * );
+    int                     (*pf_control)( sout_access_out_t *, int, va_list );
+
+    config_chain_t          *p_cfg;
+};
+
+enum access_out_query_e
+{
+    ACCESS_OUT_CONTROLS_PACE, /* arg1=bool *, can fail (assume true) */
+};
+
+VLC_API sout_access_out_t * sout_AccessOutNew( vlc_object_t *, const char *psz_access, const char *psz_name ) VLC_USED;
+#define sout_AccessOutNew( obj, access, name ) \
+        sout_AccessOutNew( VLC_OBJECT(obj), access, name )
+VLC_API void sout_AccessOutDelete( sout_access_out_t * );
+VLC_API int sout_AccessOutSeek( sout_access_out_t *, off_t );
+VLC_API ssize_t sout_AccessOutRead( sout_access_out_t *, block_t * );
+VLC_API ssize_t sout_AccessOutWrite( sout_access_out_t *, block_t * );
+VLC_API int sout_AccessOutControl( sout_access_out_t *, int, ... );
+
+static inline bool sout_AccessOutCanControlPace( sout_access_out_t *p_ao )
+{
+    bool b;
+    if( sout_AccessOutControl( p_ao, ACCESS_OUT_CONTROLS_PACE, &b ) )
+        return true;
+    return b;
+}
+
+/** Muxer structure */
+struct  sout_mux_t
+{
+    VLC_COMMON_MEMBERS
+    module_t            *p_module;
+
+    sout_instance_t     *p_sout;
+
+    char                *psz_mux;
+    config_chain_t          *p_cfg;
+
+    sout_access_out_t   *p_access;
+
+    int                 (*pf_addstream)( sout_mux_t *, sout_input_t * );
+    int                 (*pf_delstream)( sout_mux_t *, sout_input_t * );
+    int                 (*pf_mux)      ( sout_mux_t * );
+    int                 (*pf_control)  ( sout_mux_t *, int, va_list );
+
+    /* here are all inputs accepted by muxer */
+    int                 i_nb_inputs;
+    sout_input_t        **pp_inputs;
+
+    /* mux private */
+    sout_mux_sys_t      *p_sys;
+
+    /* XXX private to stream_output.c */
+    /* if muxer doesn't support adding stream at any time then we first wait
+     *  for stream then we refuse all stream and start muxing */
+    bool  b_add_stream_any_time;
+    bool  b_waiting_stream;
+    /* we wait one second after first stream added */
+    mtime_t     i_add_stream_start;
+};
+
+enum sout_mux_query_e
+{
+    /* capabilities */
+    MUX_CAN_ADD_STREAM_WHILE_MUXING,    /* arg1= bool *,      res=cannot fail */
+    /* properties */
+    MUX_GET_ADD_STREAM_WAIT,            /* arg1= bool *,      res=cannot fail */
+    MUX_GET_MIME,                       /* arg1= char **            res=can fail    */
+};
+
+struct sout_input_t
+{
+    sout_instance_t *p_sout;
+
+    es_format_t     *p_fmt;
+    block_fifo_t    *p_fifo;
+
+    void            *p_sys;
+};
+
+
+VLC_API sout_mux_t * sout_MuxNew( sout_instance_t*, const char *, sout_access_out_t * ) VLC_USED;
+VLC_API sout_input_t * sout_MuxAddStream( sout_mux_t *, es_format_t * ) VLC_USED;
+VLC_API void sout_MuxDeleteStream( sout_mux_t *, sout_input_t * );
+VLC_API void sout_MuxDelete( sout_mux_t * );
+VLC_API void sout_MuxSendBuffer( sout_mux_t *, sout_input_t  *, block_t * );
+VLC_API int sout_MuxGetStream(sout_mux_t *, int , mtime_t *);
+
+static inline int sout_MuxControl( sout_mux_t *p_mux, int i_query, ... )
+{
+    va_list args;
+    int     i_result;
+
+    va_start( args, i_query );
+    i_result = p_mux->pf_control( p_mux, i_query, args );
+    va_end( args );
+    return i_result;
+}
+
+/****************************************************************************
+ * sout_stream:
+ ****************************************************************************/
+struct sout_stream_t
+{
+    VLC_COMMON_MEMBERS
+
+    module_t          *p_module;
+    sout_instance_t   *p_sout;
+
+    char              *psz_name;
+    config_chain_t        *p_cfg;
+    sout_stream_t     *p_next;
+
+    /* Subpicture unit */
+    spu_t             *p_spu;
+
+    /* add, remove a stream */
+    sout_stream_id_t *(*pf_add)( sout_stream_t *, es_format_t * );
+    int               (*pf_del)( sout_stream_t *, sout_stream_id_t * );
+    /* manage a packet */
+    int               (*pf_send)( sout_stream_t *, sout_stream_id_t *, block_t* );
+
+    /* private */
+    sout_stream_sys_t *p_sys;
+};
+
+VLC_API void sout_StreamChainDelete(sout_stream_t *p_first, sout_stream_t *p_last );
+VLC_API sout_stream_t *sout_StreamChainNew(sout_instance_t *p_sout,
+        char *psz_chain, sout_stream_t *p_next, sout_stream_t **p_last) VLC_USED;
+
+static inline sout_stream_id_t *sout_StreamIdAdd( sout_stream_t *s, es_format_t *fmt )
+{
+    return s->pf_add( s, fmt );
+}
+static inline int sout_StreamIdDel( sout_stream_t *s, sout_stream_id_t *id )
+{
+    return s->pf_del( s, id );
+}
+static inline int sout_StreamIdSend( sout_stream_t *s, sout_stream_id_t *id, block_t *b )
+{
+    return s->pf_send( s, id, b );
+}
+
+/****************************************************************************
+ * Encoder
+ ****************************************************************************/
+
+VLC_API encoder_t * sout_EncoderCreate( vlc_object_t *obj );
+#define sout_EncoderCreate(o) sout_EncoderCreate(VLC_OBJECT(o))
+
+/****************************************************************************
+ * Announce handler
+ ****************************************************************************/
+VLC_API session_descriptor_t* sout_AnnounceRegisterSDP( vlc_object_t *, const char *, const char * ) VLC_USED;
+VLC_API int sout_AnnounceUnRegister(vlc_object_t *,session_descriptor_t* );
+#define sout_AnnounceRegisterSDP(o, sdp, addr) \
+        sout_AnnounceRegisterSDP(VLC_OBJECT (o), sdp, addr)
+#define sout_AnnounceUnRegister(o, a) \
+        sout_AnnounceUnRegister(VLC_OBJECT (o), a)
+
+/** SDP */
+
+struct sockaddr;
+
+VLC_API char * vlc_sdp_Start( vlc_object_t *obj, const char *cfgpref, const struct sockaddr *src, size_t srclen, const struct sockaddr *addr, size_t addrlen ) VLC_USED;
+VLC_API char * sdp_AddMedia(char **sdp, const char *type, const char *protocol, int dport, unsigned pt, bool bw_indep, unsigned bw, const char *ptname, unsigned clockrate, unsigned channels, const char *fmtp);
+VLC_API char * sdp_AddAttribute(char **sdp, const char *name, const char *fmt, ...) VLC_FORMAT( 3, 4 );
+
+/** Description module */
+typedef struct sout_description_data_t
+{
+    int i_es;
+    es_format_t **es;
+    vlc_sem_t *sem;
+} sout_description_data_t;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif

=== added file 'DivCity/DivCity/vlc/plugins/vlc_spu.h'
--- DivCity/DivCity/vlc/plugins/vlc_spu.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_spu.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,112 @@
+/*****************************************************************************
+ * vlc_spu.h: spu_t definition and functions.
+ *****************************************************************************
+ * Copyright (C) 1999-2010 VLC authors and VideoLAN
+ * Copyright (C) 2010 Laurent Aimar
+ * $Id: d448d06f8c9f9c91d70239ff0d07cb5ceac06423 $
+ *
+ * Authors: Gildas Bazin <gbazin@videolan.org>
+ *          Laurent Aimar <fenrir _AT_ videolan _DOT_ org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_SPU_H
+#define VLC_SPU_H 1
+
+#include <vlc_subpicture.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**********************************************************************
+ * Base SPU structures
+ **********************************************************************/
+/**
+ * \defgroup spu Subpicture Unit
+ * This module describes the programming interface for the subpicture unit.
+ * It includes functions allowing to create/destroy an spu, and render
+ * subpictures.
+ * @{
+ */
+
+typedef struct spu_private_t spu_private_t;
+
+/* Default subpicture channel ID */
+#define SPU_DEFAULT_CHANNEL (1)
+
+/**
+ * Subpicture unit descriptor
+ */
+struct spu_t
+{
+    VLC_COMMON_MEMBERS
+
+    spu_private_t *p;
+};
+
+VLC_API spu_t * spu_Create( vlc_object_t * );
+#define spu_Create(a) spu_Create(VLC_OBJECT(a))
+VLC_API void spu_Destroy( spu_t * );
+
+/**
+ * This function sends a subpicture to the spu_t core.
+ * 
+ * You cannot use the provided subpicture anymore. The spu_t core
+ * will destroy it at its convenience.
+ */
+VLC_API void spu_PutSubpicture( spu_t *, subpicture_t * );
+
+/**
+ * This function will return an unique subpicture containing the OSD and
+ * subtitles visibles at the requested date.
+ *
+ * \param p_chroma_list is a list of supported chroma for the output (can be NULL)
+ * \param p_fmt_dst is the format of the picture on which the return subpicture will be rendered.
+ * \param p_fmt_src is the format of the original(source) video.
+ *
+ * The returned value if non NULL must be released by subpicture_Delete().
+ */
+VLC_API subpicture_t * spu_Render( spu_t *, const vlc_fourcc_t *p_chroma_list, const video_format_t *p_fmt_dst, const video_format_t *p_fmt_src, mtime_t render_subtitle_date, mtime_t render_osd_date, bool ignore_osd );
+
+/**
+ * It registers a new SPU channel.
+ */
+VLC_API int spu_RegisterChannel( spu_t * );
+
+/**
+ * It clears all subpictures associated to a SPU channel.
+ */
+VLC_API void spu_ClearChannel( spu_t *, int );
+
+/**
+ * It changes the sub sources list
+ */
+VLC_API void spu_ChangeSources( spu_t *, const char * );
+
+/**
+ * It changes the sub filters list
+ */
+VLC_API void spu_ChangeFilters( spu_t *, const char * );
+
+/** @}*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* VLC_SPU_H */
+

=== added file 'DivCity/DivCity/vlc/plugins/vlc_sql.h'
--- DivCity/DivCity/vlc/plugins/vlc_sql.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_sql.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,576 @@
+/*****************************************************************************
+ * vlc_sql.h: SQL abstraction layer
+ *****************************************************************************
+ * Copyright (C) 2009 VLC authors and VideoLAN
+ * $Id: 39e9ad4f0f5721db7d717242cb61c9dcbe249f5f $
+ *
+ * Authors: Antoine Lejeune <phytos@videolan.org>
+ *          Jean-Philippe AndrÃ© <jpeg@videolan.org>
+ *          Srikanth Raju <srikiraju@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_SQL_H
+# define VLC_SQL_H
+
+# ifdef __cplusplus
+extern "C" {
+# endif
+
+
+/*****************************************************************************
+ * General structure: SQL object.
+ *****************************************************************************/
+
+/**
+ * Return values for the function @see sql_Run()
+ */
+#define VLC_SQL_ROW 1
+#define VLC_SQL_DONE 2
+
+typedef struct sql_t sql_t;
+typedef struct sql_sys_t sql_sys_t;
+typedef struct sql_stmt_t sql_stmt_t;
+
+typedef int ( *sql_query_callback_t ) ( void*, int, char**, char** );
+
+typedef enum {
+    SQL_NULL,
+    SQL_INT,
+    SQL_DOUBLE,
+    SQL_TEXT,
+    SQL_BLOB
+} sql_type_e;
+
+typedef struct
+{
+    int length;
+    union
+    {
+        int i;
+        double dbl;
+        char* psz;
+        void* ptr;
+    } value;
+} sql_value_t;
+
+struct sql_t
+{
+    VLC_COMMON_MEMBERS
+
+    /** Module properties */
+    module_t  *p_module;
+
+    /** Connection Data */
+    char *psz_host;         /**< Location or host of the database */
+    char *psz_user;         /**< Username used to connect to database */
+    char *psz_pass;         /**< Password used to connect to database */
+    int i_port;             /**< Port on which database is running */
+
+    /** Internal data */
+    sql_sys_t *p_sys;
+
+    /** All the functions are implemented as threadsafe functions */
+    /** Perform a query with a row-by-row callback function */
+    int (*pf_query_callback) ( sql_t *, const char *, sql_query_callback_t, void * );
+
+    /** Perform a query and return result directly */
+    int (*pf_query) ( sql_t *, const char *, char ***, int *, int * );
+
+    /** Get database tables */
+    int (*pf_get_tables) ( sql_t *, char *** );
+
+    /** Free result of a call to sql_Query or sql_GetTables */
+    void (*pf_free) ( sql_t *, char ** );
+
+    /** vmprintf replacement for SQL */
+    char* (*pf_vmprintf) ( const char*, va_list args );
+
+    /** Begin transaction */
+    int (*pf_begin) ( sql_t* );
+
+    /** Commit transaction */
+    int (*pf_commit) ( sql_t* );
+
+    /** Rollback transaction */
+    void (*pf_rollback) ( sql_t* );
+
+    /** Create a statement object */
+    sql_stmt_t* (*pf_prepare) ( sql_t* p_sql, const char* p_fmt,
+                                int i_length );
+
+    /** Bind parameters to a statement */
+    int (*pf_bind) ( sql_t* p_sql, sql_stmt_t* p_stmt, int i_pos,
+                    unsigned int type, const sql_value_t* p_value );
+
+    /** Run the prepared statement */
+    int (*pf_run) ( sql_t* p_sql, sql_stmt_t* p_stmt );
+
+    /** Reset the prepared statement */
+    int (*pf_reset) ( sql_t* p_sql, sql_stmt_t* p_stmt );
+
+    /** Destroy the statement object */
+    int (*pf_finalize) ( sql_t* p_sql, sql_stmt_t* p_stmt );
+
+    /** Get the datatype for a specified column */
+    int (*pf_gettype) ( sql_t* p_sql, sql_stmt_t* p_stmt, int i_col,
+                        int* type );
+
+    /** Get the data from a specified column */
+    int (*pf_getcolumn) ( sql_t* p_sql, sql_stmt_t* p_stmt, int i_col,
+                          int type, sql_value_t *p_res );
+
+    /** Get column size of a specified column */
+    int (*pf_getcolumnsize) ( sql_t* p_sql, sql_stmt_t* p_stmt, int i_col );
+};
+
+/*****************************************************************************
+ * SQL Function headers
+ *****************************************************************************/
+
+/**
+ * @brief Create a new SQL object.
+ * @param p_this Parent object to attach the SQL object to.
+ * @param psz_host URL to the database
+ * @param i_port Port on which the database is running
+ * @param psz_user Username to access the database
+ * @param psz_pass Password for the database
+ * @return The VLC SQL object, type sql_t.
+ **/
+VLC_API sql_t *sql_Create( vlc_object_t *p_this, const char *psz_name,
+            const char* psz_host, int i_port,
+            const char* psz_user, const char* psz_pass );
+#define sql_Create( a, b, c, d, e, f ) sql_Create( VLC_OBJECT(a), b, c, d, e, f )
+
+
+/**
+ * @brief Destructor for p_sql object
+ * @param obj This p_sql object
+ * @return Nothing
+ */
+VLC_API void sql_Destroy( vlc_object_t *obj );
+#define sql_Destroy( a ) sql_Destroy( VLC_OBJECT( a ) )
+
+
+/**
+ * @brief Perform a query using a callback function
+ * @param p_sql This SQL object.
+ * @param psz_query The SQL query string.
+ * @param pf_callback A callback function that will be called for each row of
+ * the result: 1st argument is be p_opaque,
+ *             2nd argument is the number of columns,
+ *             3rd is the result columns (array of strings),
+ *             4th is the columns names (array of strings).
+ * @param p_opaque Any pointer to an object you may need in the callback.
+ * @return VLC_SUCCESS or VLC_EGENERIC.
+ * @note The query will not necessarily be processed in a separate thread, but
+ * it is threadsafe
+ **/
+static inline int sql_QueryCallback( sql_t *p_sql, const char *psz_query,
+                                     sql_query_callback_t pf_callback,
+                                     void *p_opaque )
+{
+    return p_sql->pf_query_callback( p_sql, psz_query, pf_callback, p_opaque );
+}
+
+/**
+ * @brief Perform a query directly
+ * @param p_sql This SQL object.
+ * @param psz_query The SQL query string.
+ * @param pppsz_result A pointer to a array of strings: result of the query.
+ * Dynamically allocated.
+ * @param pi_rows Pointer to an integer that will receive the number of result
+ * rows written.
+ * @param pi_cols Pointer to an integer that will receive the number of result
+ * columns written.
+ * @return VLC_SUCCESS or VLC_EGENERIC.
+ * @note pppsz_result will point to an array of strings, ppsz_result.
+ * This array of strings contains actually a 2D-matrix of strings where the
+ * first row (row 0) contains the SQL table header names.
+ * *pi_rows will be the number of result rows, so that the number of text rows
+ * in ppsz_result will be (*pi_rows + 1) (because of row 0).
+ * To get result[row,col] use (*pppsz_result)[ (row+1) * (*pi_cols) + col ].
+ * This function is threadsafe
+ **/
+static inline int sql_Query( sql_t *p_sql, const char *psz_query,
+                             char ***pppsz_result, int *pi_rows, int *pi_cols )
+{
+    return p_sql->pf_query( p_sql, psz_query, pppsz_result, pi_rows, pi_cols );
+}
+
+/**
+ * @brief Get database table name list
+ * @param p_sql This SQL object.
+ * @param pppsz_tables Pointer to an array of strings. Dynamically allocated.
+ * Similar to pppsz_result of sql_Query but with only one row.
+ * @return Number of tables or <0 in case of error.
+ * @note This function is threadsafe
+ **/
+static inline int sql_GetTables( sql_t *p_sql, char ***pppsz_tables )
+{
+    return p_sql->pf_get_tables( p_sql, pppsz_tables );
+}
+
+/**
+ * @brief Free the result of a query.
+ * @param p_sql This SQL object.
+ * @param ppsz_result The result of sql_Query or sql_GetTables. See above.
+ * @return Nothing.
+ * @note This function is threadsafe
+ **/
+static inline void sql_Free( sql_t *p_sql, char **ppsz_result )
+{
+    p_sql->pf_free( p_sql, ppsz_result );
+}
+
+/**
+ * @brief printf-like function that can escape forbidden/reserved characters.
+ * @param p_sql This SQL object.
+ * @param psz_fmt Format of the string (with %q, %Q and %z enabled).
+ * @param ... Printf arguments
+ * @return Dynamically allocated string or NULL in case of error.
+ * @note Refer to SQLite documentation for more details about %q, %Q and %z.
+ **/
+static inline char* sql_Printf( sql_t *p_sql, const char *psz_fmt, ... )
+{
+    va_list args;
+    va_start( args, psz_fmt );
+    char *r = p_sql->pf_vmprintf( psz_fmt, args );
+    va_end( args );
+    return r;
+}
+
+/**
+ * @brief vprintf replacement for SQL queries, escaping forbidden characters
+ * @param p_sql This SQL object
+ * @param psz_fmt Format of the string
+ * @param arg Variable list of arguments
+ * @return Dynamically allocated string or NULL in case of error.
+ **/
+static inline char* sql_VPrintf( sql_t *p_sql, const char *psz_fmt,
+                                 va_list arg )
+{
+    return p_sql->pf_vmprintf( psz_fmt, arg );
+}
+
+/**
+ * @brief Begin a SQL transaction
+ * @param p_sql The SQL object
+ * @return VLC error code or success
+ * @note This function is threadsafe
+ **/
+static inline int sql_BeginTransaction( sql_t *p_sql )
+{
+    return p_sql->pf_begin( p_sql );
+}
+
+/**
+ * @brief Commit a SQL transaction
+ * @param p_sql The SQL object
+ * @return VLC error code or success
+ * @note This function is threadsafe
+ **/
+static inline int sql_CommitTransaction( sql_t *p_sql )
+{
+    return p_sql->pf_commit( p_sql );
+}
+
+/**
+ * @brief Rollback a SQL transaction
+ * @param p_sql The SQL object
+ * @return VLC error code or success
+ * @note This function is threadsafe
+ **/
+static inline void sql_RollbackTransaction( sql_t *p_sql )
+{
+    p_sql->pf_rollback( p_sql );
+}
+
+/**
+ * @brief Prepare an sql statement
+ * @param p_sql The SQL object
+ * @param p_fmt SQL query string
+ * @param i_length length of the string. If negative, length will be
+ * considered upto the first \0 character equivalent to strlen(p_fmt).
+ * Otherwise the first i_length bytes will be used
+ * @return a sql_stmt_t pointer or NULL on failure
+ */
+static inline sql_stmt_t* sql_Prepare( sql_t* p_sql, const char* p_fmt,
+        int i_length )
+{
+    return p_sql->pf_prepare( p_sql, p_fmt, i_length );
+}
+
+/**
+ * @brief Bind arguments to a sql_stmt_t object
+ * @param p_sql The SQL object
+ * @param p_stmt Statement Object
+ * @param type Data type of the value
+ * @param p_value Value to be bound
+ * @param i_pos Position at which the parameter should be bound
+ * @return VLC_SUCCESS or VLC_EGENERIC
+ */
+static inline int sql_BindGeneric( sql_t* p_sql, sql_stmt_t* p_stmt,
+        int i_pos, int type, const sql_value_t* p_value )
+{
+    return p_sql->pf_bind( p_sql, p_stmt, i_pos, type, p_value );
+}
+
+/**
+ * @brief Bind a NULL value to a position
+ * @param p_sql The SQL object
+ * @param p_stmt Statement Object
+ * @param i_pos Position at which the parameter should be bound
+ * @return VLC_SUCCESS or VLC_EGENERIC
+ */
+static inline int sql_BindNull( sql_t *p_sql, sql_stmt_t* p_stmt, int i_pos )
+{
+    int i_ret = sql_BindGeneric( p_sql, p_stmt, i_pos, SQL_NULL, NULL );
+    return i_ret;
+}
+
+/**
+ * @brief Bind an integer to the statement object at some position
+ * @param p_sql The SQL object
+ * @param p_stmt Statement Object
+ * @param i_pos Position at which the parameter should be bound
+ * @param i_int Value to be bound
+ * @return VLC_SUCCESS or VLC_EGENERIC
+ */
+static inline int sql_BindInteger( sql_t *p_sql, sql_stmt_t* p_stmt,
+                                   int i_pos, int i_int )
+{
+    sql_value_t value;
+    value.length = 0;
+    value.value.i = i_int;
+    int i_ret = sql_BindGeneric( p_sql, p_stmt, i_pos, SQL_INT, &value );
+    return i_ret;
+}
+
+/**
+ * @brief Bind a double to the statement object at some position
+ * @param p_sql The SQL object
+ * @param p_stmt Statement Object
+ * @param i_pos Position at which the parameter should be bound
+ * @param d_dbl Value to be bound
+ * @return VLC_SUCCESS or VLC_EGENERIC
+ */
+static inline int sql_BindDouble( sql_t *p_sql, sql_stmt_t* p_stmt,
+                                  int i_pos, double d_dbl )
+{
+    sql_value_t value;
+    value.length = 0;
+    value.value.dbl = d_dbl;
+    int i_ret = sql_BindGeneric( p_sql, p_stmt, i_pos, SQL_INT, &value );
+    return i_ret;
+}
+
+/**
+ * @brief Bind Text to the statement
+ * @param p_sql The SQL object
+ * @param p_stmt Statement Object
+ * @param i_pos Position at which the parameter should be bound
+ * @param p_fmt Value to be bound
+ * @param i_length Length of text. If -ve text upto the first null char
+ * will be selected.
+ * @return VLC_SUCCESS or VLC_EGENERIC
+ */
+static inline int sql_BindText( sql_t *p_sql, sql_stmt_t* p_stmt, int i_pos,
+                                   char* p_fmt, int i_length )
+{
+    sql_value_t value;
+    value.length = i_length;
+    value.value.psz = p_fmt;
+    int i_ret = sql_BindGeneric( p_sql, p_stmt, i_pos, SQL_TEXT, &value );
+    return i_ret;
+}
+
+/**
+ * @brief Bind a binary object to the statement
+ * @param p_sql The SQL object
+ * @param p_stmt Statement Object
+ * @param i_pos Position at which the parameter should be bound
+ * @param p_ptr Value to be bound
+ * @param i_length Size of the blob to read
+ * @return VLC_SUCCESS or VLC_EGENERIC
+ */
+static inline int sql_BindBlob( sql_t *p_sql, sql_stmt_t* p_stmt, int i_pos,
+                                   void* p_ptr, int i_length )
+{
+    sql_value_t value;
+    value.length = i_length;
+    value.value.ptr = p_ptr;
+    int i_ret = sql_BindGeneric( p_sql, p_stmt, i_pos, SQL_INT, &value );
+    return i_ret;
+}
+
+/**
+ * @brief Run the SQL statement. If the statement fetches data, then only
+ * one row of the data is fetched at a time. Run this function again to
+ * fetch the next row.
+ * @param p_sql The SQL object
+ * @param p_stmt The statement
+ * @return VLC_SQL_DONE if done fetching all rows or there are no rows to fetch
+ * VLC_SQL_ROW if a row was fetched for this statement.
+ * VLC_EGENERIC if this function failed
+ */
+static inline int sql_Run( sql_t* p_sql, sql_stmt_t* p_stmt )
+{
+    return p_sql->pf_run( p_sql, p_stmt );
+}
+
+/**
+ * @brief Reset the SQL statement. Resetting the statement will unbind all
+ * the values that were bound on this statement
+ * @param p_sql The SQL object
+ * @param p_stmt The sql statement object
+ * @return VLC_SUCCESS or VLC_EGENERIC
+ */
+static inline int sql_Reset( sql_t* p_sql, sql_stmt_t* p_stmt )
+{
+    return p_sql->pf_reset( p_sql, p_stmt );
+}
+
+/**
+ * @brief Destroy the sql statement object. This will free memory.
+ * @param p_sql The SQL object
+ * @param p_stmt The statement object
+ * @return VLC_SUCCESS or VLC_EGENERIC
+ */
+static inline int sql_Finalize( sql_t* p_sql, sql_stmt_t* p_stmt )
+{
+    return p_sql->pf_finalize( p_sql, p_stmt );
+}
+
+/**
+ * @brief Get the datatype of the result of the column
+ * @param p_sql The SQL object
+ * @param p_stmt The sql statement object
+ * @param i_col The column
+ * @param type pointer to datatype of the given column
+ * @return VLC_SUCCESS or VLC_EGENERIC
+ */
+static inline int sql_GetColumnType( sql_t* p_sql, sql_stmt_t* p_stmt,
+        int i_col, int* type )
+{
+    return p_sql->pf_gettype( p_sql, p_stmt, i_col, type );
+}
+
+/**
+ * @brief Get the column data
+ * @param p_sql The SQL object
+ * @param p_stmt The statement object
+ * @param i_col The column number
+ * @param type Datatype of result
+ * @param p_res The structure which contains the value of the result
+ * @return VLC_SUCCESS or VLC_EGENERIC
+ */
+static inline int sql_GetColumn( sql_t* p_sql, sql_stmt_t* p_stmt,
+        int i_col, int type, sql_value_t *p_res )
+{
+    return p_sql->pf_getcolumn( p_sql, p_stmt, i_col, type, p_res );
+}
+
+/**
+ * @brief Get an integer from the results of a statement
+ * @param p_sql The SQL object
+ * @param p_stmt The statement object
+ * @param i_col The column number
+ * @param i_res Pointer of the location for result to be stored
+ * @return VLC_SUCCESS or VLC_EGENERIC
+ */
+static inline int sql_GetColumnInteger( sql_t* p_sql, sql_stmt_t* p_stmt,
+        int i_col, int* pi_res )
+{
+    sql_value_t tmp;
+    int i_ret = p_sql->pf_getcolumn( p_sql, p_stmt, i_col, SQL_INT, &tmp );
+    if( i_ret == VLC_SUCCESS )
+        *pi_res = tmp.value.i;
+    return i_ret;
+}
+
+/**
+ * @brief Get a double from the results of a statement
+ * @param p_sql The SQL object
+ * @param p_stmt The statement object
+ * @param i_col The column number
+ * @param d_res Pointer of the location for result to be stored
+ * @return VLC_SUCCESS or VLC_EGENERIC
+ */
+static inline int sql_GetColumnDouble( sql_t* p_sql, sql_stmt_t* p_stmt,
+        int i_col, double* pd_res )
+{
+    sql_value_t tmp;
+    int i_ret = p_sql->pf_getcolumn( p_sql, p_stmt, i_col, SQL_DOUBLE, &tmp );
+    if( i_ret == VLC_SUCCESS )
+        *pd_res = tmp.value.dbl;
+    return i_ret;
+}
+
+/**
+ * @brief Get some text from the results of a statement
+ * @param p_sql The SQL object
+ * @param p_stmt The statement object
+ * @param i_col The column number
+ * @param pp_res Pointer of the location for result to be stored
+ * @return VLC_SUCCESS or VLC_EGENERIC
+ */
+static inline int sql_GetColumnText( sql_t* p_sql, sql_stmt_t* p_stmt,
+        int i_col, char** pp_res )
+{
+    sql_value_t tmp;
+    int i_ret = p_sql->pf_getcolumn( p_sql, p_stmt, i_col, SQL_TEXT, &tmp );
+    if( i_ret == VLC_SUCCESS )
+        *pp_res = tmp.value.psz;
+    return i_ret;
+}
+
+/**
+ * @brief Get a blob from the results of a statement
+ * @param p_sql The SQL object
+ * @param p_stmt The statement object
+ * @param i_col The column number
+ * @param pp_res Pointer of the location for result to be stored
+ * @return VLC_SUCCESS or VLC_EGENERIC
+ */
+static inline int sql_GetColumnBlob( sql_t* p_sql, sql_stmt_t* p_stmt,
+        int i_col, void** pp_res )
+{
+    sql_value_t tmp;
+    int i_ret = p_sql->pf_getcolumn( p_sql, p_stmt, i_col, SQL_BLOB, &tmp );
+    if( i_ret == VLC_SUCCESS )
+        *pp_res = tmp.value.ptr;
+    return i_ret;
+}
+
+/**
+ * @brief Get the size of the column in bytes
+ * @param p_sql The SQL object
+ * @param p_stmt The sql statement object
+ * @param i_col The column
+ * @return Size of the column in bytes, excluding the zero terminator
+ */
+static inline int sql_GetColumnSize( sql_t* p_sql, sql_stmt_t* p_stmt,
+        int i_col )
+{
+    return p_sql->pf_getcolumnsize( p_sql, p_stmt, i_col );
+}
+
+# ifdef __cplusplus
+}
+# endif /* C++ extern "C" */
+
+#endif /* VLC_SQL_H */

=== added file 'DivCity/DivCity/vlc/plugins/vlc_stream.h'
--- DivCity/DivCity/vlc/plugins/vlc_stream.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_stream.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,205 @@
+/*****************************************************************************
+ * vlc_stream.h: Stream (between access and demux) descriptor and methods
+ *****************************************************************************
+ * Copyright (C) 1999-2004 VLC authors and VideoLAN
+ * $Id: c9298367b3249ea233e62262695d09bc450a28e4 $
+ *
+ * Authors: Laurent Aimar <fenrir@via.ecp.fr>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_STREAM_H
+#define VLC_STREAM_H 1
+
+#include <vlc_block.h>
+
+/**
+ * \file
+ * This file defines structures and functions for stream (between access and demux) descriptor in vlc
+ */
+
+# ifdef __cplusplus
+extern "C" {
+# endif
+
+/**
+ * \defgroup stream Stream
+ *
+ *  This will allow you to easily handle read/seek in demuxer modules.
+ * @{
+ */
+
+/* Opaque definition for text reader context */
+typedef struct stream_text_t stream_text_t;
+
+/**
+ * stream_t definition
+ */
+
+struct stream_t
+{
+    VLC_COMMON_MEMBERS
+    bool        b_error;
+
+    /* Module properties for stream filter */
+    module_t    *p_module;
+
+    char        *psz_access;
+    /* Real or virtual path (it can only be changed during stream_t opening) */
+    char        *psz_path;
+
+    /* Stream source for stream filter */
+    stream_t *p_source;
+
+    /* */
+    int      (*pf_read)   ( stream_t *, void *p_read, unsigned int i_read );
+    int      (*pf_peek)   ( stream_t *, const uint8_t **pp_peek, unsigned int i_peek );
+    int      (*pf_control)( stream_t *, int i_query, va_list );
+
+    /* */
+    void     (*pf_destroy)( stream_t *);
+
+    /* Private data for module */
+    stream_sys_t *p_sys;
+
+    /* Text reader state */
+    stream_text_t *p_text;
+
+    /* Weak link to parent input */
+    input_thread_t *p_input;
+};
+
+/**
+ * Possible commands to send to stream_Control() and stream_vaControl()
+ */
+enum stream_query_e
+{
+    /* capabilities */
+    STREAM_CAN_SEEK,            /**< arg1= bool *   res=cannot fail*/
+    STREAM_CAN_FASTSEEK,        /**< arg1= bool *   res=cannot fail*/
+
+    /* */
+    STREAM_SET_POSITION,        /**< arg1= uint64_t       res=can fail  */
+    STREAM_GET_POSITION,        /**< arg1= uint64_t *     res=cannot fail*/
+
+    STREAM_GET_SIZE,            /**< arg1= uint64_t *     res=cannot fail (0 if no sense)*/
+
+    /* Special for direct access control from demuxer.
+     * XXX: avoid using it by all means */
+    STREAM_CONTROL_ACCESS,  /* arg1= int i_access_query, args   res: can fail
+                             if access unreachable or access control answer */
+
+    /* You should update size of source if any and then update size 
+     * FIXME find a way to avoid it */
+    STREAM_UPDATE_SIZE,
+
+    /* */
+    STREAM_GET_CONTENT_TYPE,    /**< arg1= char **         res=can fail */
+
+    /* XXX only data read through stream_Read/Block will be recorded */
+    STREAM_SET_RECORD_STATE,     /**< arg1=bool, arg2=const char *psz_ext (if arg1 is true)  res=can fail */
+};
+
+VLC_API int stream_Read( stream_t *s, void *p_read, int i_read );
+VLC_API int stream_Peek( stream_t *s, const uint8_t **pp_peek, int i_peek );
+VLC_API int stream_vaControl( stream_t *s, int i_query, va_list args );
+VLC_API void stream_Delete( stream_t *s );
+VLC_API int stream_Control( stream_t *s, int i_query, ... );
+VLC_API block_t * stream_Block( stream_t *s, int i_size );
+VLC_API block_t * stream_BlockRemaining( stream_t *s, int i_max_size );
+VLC_API char * stream_ReadLine( stream_t * );
+
+/**
+ * Get the current position in a stream
+ */
+static inline int64_t stream_Tell( stream_t *s )
+{
+    uint64_t i_pos;
+    stream_Control( s, STREAM_GET_POSITION, &i_pos );
+    if( i_pos >> 62 )
+        return (int64_t)1 << 62;
+    return i_pos;
+}
+
+/**
+ * Get the size of the stream.
+ */
+static inline int64_t stream_Size( stream_t *s )
+{
+    uint64_t i_pos;
+    stream_Control( s, STREAM_GET_SIZE, &i_pos );
+    if( i_pos >> 62 )
+        return (int64_t)1 << 62;
+    return i_pos;
+}
+
+static inline int stream_Seek( stream_t *s, uint64_t i_pos )
+{
+    return stream_Control( s, STREAM_SET_POSITION, i_pos );
+}
+
+/**
+ * Get the Content-Type of a stream, or NULL if unknown.
+ * Result must be free()'d.
+ */
+static inline char *stream_ContentType( stream_t *s )
+{
+    char *res;
+    if( stream_Control( s, STREAM_GET_CONTENT_TYPE, &res ) )
+        return NULL;
+    return res;
+}
+
+/**
+ * Create a special stream and a demuxer, this allows chaining demuxers
+ * You must delete it using stream_Delete.
+ */
+VLC_API stream_t * stream_DemuxNew( demux_t *p_demux, const char *psz_demux, es_out_t *out );
+
+/**
+ * Send data to a stream_t handle created by stream_DemuxNew.
+ */
+VLC_API void stream_DemuxSend( stream_t *s, block_t *p_block );
+
+/**
+ * Create a stream_t reading from memory.
+ * You must delete it using stream_Delete.
+ */
+VLC_API stream_t * stream_MemoryNew(vlc_object_t *p_obj, uint8_t *p_buffer, uint64_t i_size, bool b_preserve_memory );
+#define stream_MemoryNew( a, b, c, d ) stream_MemoryNew( VLC_OBJECT(a), b, c, d )
+
+/**
+ * Create a stream_t reading from a URL.
+ * You must delete it using stream_Delete.
+ */
+VLC_API stream_t * stream_UrlNew(vlc_object_t *p_this, const char *psz_url );
+#define stream_UrlNew( a, b ) stream_UrlNew( VLC_OBJECT(a), b )
+
+
+/**
+ * Try to add a stream filter to an open stream.
+ * @return New stream to use, or NULL if the filter could not be added.
+ **/
+VLC_API stream_t* stream_FilterNew( stream_t *p_source, const char *psz_stream_filter );
+/**
+ * @}
+ */
+
+# ifdef __cplusplus
+}
+# endif
+
+#endif

=== added file 'DivCity/DivCity/vlc/plugins/vlc_strings.h'
--- DivCity/DivCity/vlc/plugins/vlc_strings.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_strings.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,62 @@
+/*****************************************************************************
+ * vlc_strings.h: String functions
+ *****************************************************************************
+ * Copyright (C) 2006 VLC authors and VideoLAN
+ * $Id: 9b4d0944cf94b6c4208fe26f2d92caee8fb7459c $
+ *
+ * Authors: Antoine Cellerier <dionoea at videolan dot org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_STRINGS_H
+#define VLC_STRINGS_H 1
+
+/**
+ * \file
+ * This file defines functions and structures handling misc strings
+ */
+
+/**
+ * \defgroup strings Strings
+ * @{
+ */
+
+VLC_API void resolve_xml_special_chars( char *psz_value );
+VLC_API char * convert_xml_special_chars( const char *psz_content );
+
+VLC_API char * vlc_b64_encode_binary( const uint8_t *, size_t );
+VLC_API char * vlc_b64_encode( const char * );
+
+VLC_API size_t vlc_b64_decode_binary_to_buffer( uint8_t *p_dst, size_t i_dst_max, const char *psz_src );
+VLC_API size_t vlc_b64_decode_binary( uint8_t **pp_dst, const char *psz_src );
+VLC_API char * vlc_b64_decode( const char *psz_src );
+
+VLC_API char * str_format_time( const char * );
+VLC_API char * str_format_meta( vlc_object_t *, const char * );
+#define str_format_meta( a, b ) str_format_meta( VLC_OBJECT( a ), b )
+VLC_API char * str_format( vlc_object_t *, const char * );
+#define str_format( a, b ) str_format( VLC_OBJECT( a ), b )
+
+VLC_API void filename_sanitize( char * );
+VLC_API void path_sanitize( char * );
+
+VLC_API time_t str_duration( const char * );
+
+/**
+ * @}
+ */
+
+#endif

=== added file 'DivCity/DivCity/vlc/plugins/vlc_subpicture.h'
--- DivCity/DivCity/vlc/plugins/vlc_subpicture.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_subpicture.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,206 @@
+/*****************************************************************************
+ * vlc_subpicture.h: subpicture definitions
+ *****************************************************************************
+ * Copyright (C) 1999 - 2009 VLC authors and VideoLAN
+ * $Id: 797f22ab3e39787a4af758af7546336e22a639cc $
+ *
+ * Authors: Vincent Seguin <seguin@via.ecp.fr>
+ *          Samuel Hocevar <sam@via.ecp.fr>
+ *          Olivier Aubert <oaubert 47 videolan d07 org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_SUBPICTURE_H
+#define VLC_SUBPICTURE_H 1
+
+/**
+ * \file
+ * This file defines subpicture structures and functions in vlc
+ */
+
+#include <vlc_picture.h>
+#include <vlc_text_style.h>
+
+/**
+ * \defgroup subpicture Video Subpictures
+ * Subpictures are pictures that should be displayed on top of the video, like
+ * subtitles and OSD
+ * \ingroup video_output
+ * @{
+ */
+
+/**
+ * Video subtitle region spu core private
+ */
+typedef struct subpicture_region_private_t subpicture_region_private_t;
+
+/**
+ * Video subtitle region
+ *
+ * A subtitle region is defined by a picture (graphic) and its rendering
+ * coordinates.
+ * Subtitles contain a list of regions.
+ */
+struct subpicture_region_t
+{
+    video_format_t  fmt;                          /**< format of the picture */
+    picture_t       *p_picture;          /**< picture comprising this region */
+
+    int             i_x;                             /**< position of region */
+    int             i_y;                             /**< position of region */
+    int             i_align;                  /**< alignment within a region */
+    int             i_alpha;                               /**< transparency */
+
+    char            *psz_text;       /**< text string comprising this region */
+    char            *psz_html;       /**< HTML version of subtitle (NULL = use psz_text) */
+    text_style_t    *p_style;        /**< a description of the text style formatting */
+
+    subpicture_region_t *p_next;                /**< next region in the list */
+    subpicture_region_private_t *p_private;  /**< Private data for spu_t *only* */
+};
+
+/* Subpicture region position flags */
+#define SUBPICTURE_ALIGN_LEFT 0x1
+#define SUBPICTURE_ALIGN_RIGHT 0x2
+#define SUBPICTURE_ALIGN_TOP 0x4
+#define SUBPICTURE_ALIGN_BOTTOM 0x8
+#define SUBPICTURE_ALIGN_MASK ( SUBPICTURE_ALIGN_LEFT|SUBPICTURE_ALIGN_RIGHT| \
+                                SUBPICTURE_ALIGN_TOP |SUBPICTURE_ALIGN_BOTTOM )
+
+/**
+ * This function will create a new subpicture region.
+ *
+ * You must use subpicture_region_Delete to destroy it.
+ */
+VLC_API subpicture_region_t * subpicture_region_New( const video_format_t *p_fmt );
+
+/**
+ * This function will destroy a subpicture region allocated by
+ * subpicture_region_New.
+ *
+ * You may give it NULL.
+ */
+VLC_API void subpicture_region_Delete( subpicture_region_t *p_region );
+
+/**
+ * This function will destroy a list of subpicture regions allocated by
+ * subpicture_region_New.
+ *
+ * Provided for convenience.
+ */
+VLC_API void subpicture_region_ChainDelete( subpicture_region_t *p_head );
+
+/**
+ *
+ */
+typedef struct subpicture_updater_sys_t subpicture_updater_sys_t;
+typedef struct
+{
+    int  (*pf_validate)( subpicture_t *,
+                         bool has_src_changed, const video_format_t *p_fmt_src,
+                         bool has_dst_changed, const video_format_t *p_fmt_dst,
+                         mtime_t);
+    void (*pf_update)  ( subpicture_t *,
+                         const video_format_t *p_fmt_src,
+                         const video_format_t *p_fmt_dst,
+                         mtime_t );
+    void (*pf_destroy) ( subpicture_t * );
+    subpicture_updater_sys_t *p_sys;
+} subpicture_updater_t;
+
+typedef struct subpicture_private_t subpicture_private_t;
+
+/**
+ * Video subtitle
+ *
+ * Any subtitle destined to be displayed by a video output thread should
+ * be stored in this structure from it's creation to it's effective display.
+ * Subtitle type and flags should only be modified by the output thread. Note
+ * that an empty subtitle MUST have its flags set to 0.
+ */
+struct subpicture_t
+{
+    /** \name Channel ID */
+    /**@{*/
+    int             i_channel;                    /**< subpicture channel ID */
+    /**@}*/
+
+    /** \name Type and flags
+       Should NOT be modified except by the vout thread */
+    /**@{*/
+    int64_t         i_order;                 /** an increasing unique number */
+    subpicture_t *  p_next;               /**< next subtitle to be displayed */
+    /**@}*/
+
+    subpicture_region_t *p_region;  /**< region list composing this subtitle */
+
+    /** \name Date properties */
+    /**@{*/
+    mtime_t         i_start;                  /**< beginning of display date */
+    mtime_t         i_stop;                         /**< end of display date */
+    bool            b_ephemer;    /**< If this flag is set to true the subtitle
+                                will be displayed untill the next one appear */
+    bool            b_fade;                               /**< enable fading */
+    /**@}*/
+
+    /** \name Display properties
+     * These properties are only indicative and may be
+     * changed by the video output thread, or simply ignored depending of the
+     * subtitle type. */
+    /**@{*/
+    bool         b_subtitle;            /**< the picture is a movie subtitle */
+    bool         b_absolute;                       /**< position is absolute */
+    int          i_original_picture_width;  /**< original width of the movie */
+    int          i_original_picture_height;/**< original height of the movie */
+    int          i_alpha;                                  /**< transparency */
+     /**@}*/
+
+    subpicture_updater_t updater;
+
+    subpicture_private_t *p_private;    /* Reserved to the core */
+};
+
+/**
+ * This function create a new empty subpicture.
+ *
+ * You must use subpicture_Delete to destroy it.
+ */
+VLC_API subpicture_t * subpicture_New( const subpicture_updater_t * );
+
+/**
+ * This function delete a subpicture created by subpicture_New.
+ * You may give it NULL.
+ */
+VLC_API void subpicture_Delete( subpicture_t *p_subpic );
+
+/**
+ * This function will create a subpicture having one region in the requested
+ * chroma showing the given picture.
+ *
+ * The picture_t given is not released nor used inside the
+ * returned subpicture_t.
+ */
+VLC_API subpicture_t * subpicture_NewFromPicture( vlc_object_t *, picture_t *, vlc_fourcc_t i_chroma );
+
+/**
+ * This function will update the content of a subpicture created with
+ * a non NULL subpicture_updater_t.
+ */
+VLC_API void subpicture_Update( subpicture_t *, const video_format_t *src, const video_format_t *, mtime_t );
+
+/**@}*/
+
+#endif /* _VLC_VIDEO_H */

=== added file 'DivCity/DivCity/vlc/plugins/vlc_text_style.h'
--- DivCity/DivCity/vlc/plugins/vlc_text_style.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_text_style.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,104 @@
+/*****************************************************************************
+ * vlc_text_style.h: text_style_t definition and helpers.
+ *****************************************************************************
+ * Copyright (C) 1999-2010 VLC authors and VideoLAN
+ * $Id: 531411ae607308ad632cd90c63bd70756ebb51df $
+ *
+ * Authors: Derk-Jan Hartman <hartman _AT_ videolan _DOT_ org>
+ *          basOS G <noxelia 4t gmail , com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_TEXT_STYLE_H
+#define VLC_TEXT_STYLE_H 1
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * Text style
+ *
+ * A text style is used to specify the formatting of text.
+ * A font renderer can use the supplied information to render the
+ * text specified.
+ */
+typedef struct
+{
+    char *     psz_fontname;      /**< The name of the font */
+    int        i_font_size;       /**< The font size in pixels */
+    int        i_font_color;      /**< The color of the text 0xRRGGBB
+                                       (native endianness) */
+    int        i_font_alpha;      /**< The transparency of the text.
+                                       0x00 is fully opaque,
+                                       0xFF fully transparent */
+    int        i_style_flags;     /**< Formatting style flags */
+    int        i_outline_color;   /**< The color of the outline 0xRRGGBB */
+    int        i_outline_alpha;   /**< The transparency of the outline.
+                                       0x00 is fully opaque,
+                                       0xFF fully transparent */
+    int        i_shadow_color;    /**< The color of the shadow 0xRRGGBB */
+    int        i_shadow_alpha;    /**< The transparency of the shadow.
+                                        0x00 is fully opaque,
+                                        0xFF fully transparent */
+    int        i_background_color;/**< The color of the background 0xRRGGBB */
+    int        i_background_alpha;/**< The transparency of the background.
+                                       0x00 is fully opaque,
+                                       0xFF fully transparent */
+    int        i_karaoke_background_color;/**< Background color for karaoke 0xRRGGBB */
+    int        i_karaoke_background_alpha;/**< The transparency of the karaoke bg.
+                                       0x00 is fully opaque,
+                                       0xFF fully transparent */
+    int        i_outline_width;   /**< The width of the outline in pixels */
+    int        i_shadow_width;    /**< The width of the shadow in pixels */
+    int        i_spacing;         /**< The spaceing between glyphs in pixels */
+} text_style_t;
+
+/* Style flags for \ref text_style_t */
+#define STYLE_BOLD        1
+#define STYLE_ITALIC      2
+#define STYLE_OUTLINE     4
+#define STYLE_SHADOW      8
+#define STYLE_BACKGROUND  16
+#define STYLE_UNDERLINE   32
+#define STYLE_STRIKEOUT   64
+
+/**
+ * Create a default text style
+ */
+VLC_API text_style_t * text_style_New( void );
+
+/**
+ * Copy a text style into another
+ */
+VLC_API text_style_t * text_style_Copy( text_style_t *, const text_style_t * );
+
+/**
+ * Duplicate a text style
+ */
+VLC_API text_style_t * text_style_Duplicate( const text_style_t * );
+
+/**
+ * Delete a text style created by text_style_New or text_style_Duplicate
+ */
+VLC_API void text_style_Delete( text_style_t * );
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* VLC_TEXT_STYLE_H */
+

=== added file 'DivCity/DivCity/vlc/plugins/vlc_threads.h'
--- DivCity/DivCity/vlc/plugins/vlc_threads.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_threads.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,558 @@
+/*****************************************************************************
+ * vlc_threads.h : threads implementation for the VideoLAN client
+ * This header provides portable declarations for mutexes & conditions
+ *****************************************************************************
+ * Copyright (C) 1999, 2002 VLC authors and VideoLAN
+ * Copyright Â© 2007-2008 RÃ©mi Denis-Courmont
+ *
+ * Authors: Jean-Marc Dressler <polux@via.ecp.fr>
+ *          Samuel Hocevar <sam@via.ecp.fr>
+ *          Gildas Bazin <gbazin@netcourrier.com>
+ *          Christophe Massiot <massiot@via.ecp.fr>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_THREADS_H_
+#define VLC_THREADS_H_
+
+/**
+ * \file
+ * This file defines structures and functions for handling threads in vlc
+ *
+ */
+
+#if defined( UNDER_CE )
+#elif defined( WIN32 )
+#   include <process.h>                                         /* Win32 API */
+
+#elif defined( __OS2__ )                                        /* OS/2 API  */
+#   include <errno.h>
+
+#   define pthread_sigmask  sigprocmask
+
+#else                                         /* pthreads (like Linux & BSD) */
+#   define LIBVLC_USE_PTHREAD 1
+#   define LIBVLC_USE_PTHREAD_CANCEL 1
+#   define _APPLE_C_SOURCE    1 /* Proper pthread semantics on OSX */
+
+#   include <unistd.h> /* _POSIX_SPIN_LOCKS */
+#   include <pthread.h>
+
+/* Unnamed POSIX semaphores not supported on Mac OS X, use Mach semaphores instead */
+#   if defined (__APPLE__)
+#      include <mach/semaphore.h>
+#      include <mach/task.h>
+#   else
+#      include <semaphore.h>
+#   endif
+
+#endif
+
+/*****************************************************************************
+ * Constants
+ *****************************************************************************/
+
+/* Thread priorities */
+#ifdef __APPLE__
+#   define VLC_THREAD_PRIORITY_LOW      0
+#   define VLC_THREAD_PRIORITY_INPUT   22
+#   define VLC_THREAD_PRIORITY_AUDIO   22
+#   define VLC_THREAD_PRIORITY_VIDEO    0
+#   define VLC_THREAD_PRIORITY_OUTPUT  22
+#   define VLC_THREAD_PRIORITY_HIGHEST 22
+
+#elif defined(LIBVLC_USE_PTHREAD)
+#   define VLC_THREAD_PRIORITY_LOW      0
+#   define VLC_THREAD_PRIORITY_INPUT   10
+#   define VLC_THREAD_PRIORITY_AUDIO    5
+#   define VLC_THREAD_PRIORITY_VIDEO    0
+#   define VLC_THREAD_PRIORITY_OUTPUT  15
+#   define VLC_THREAD_PRIORITY_HIGHEST 20
+
+#elif defined(WIN32) || defined(UNDER_CE)
+/* Define different priorities for WinNT/2K/XP and Win9x/Me */
+#   define VLC_THREAD_PRIORITY_LOW 0
+#   define VLC_THREAD_PRIORITY_INPUT \
+        THREAD_PRIORITY_ABOVE_NORMAL
+#   define VLC_THREAD_PRIORITY_AUDIO \
+        THREAD_PRIORITY_HIGHEST
+#   define VLC_THREAD_PRIORITY_VIDEO 0
+#   define VLC_THREAD_PRIORITY_OUTPUT \
+        THREAD_PRIORITY_ABOVE_NORMAL
+#   define VLC_THREAD_PRIORITY_HIGHEST \
+        THREAD_PRIORITY_TIME_CRITICAL
+
+#elif defined(__OS2__)
+#   define VLC_THREAD_PRIORITY_LOW      0
+#   define VLC_THREAD_PRIORITY_INPUT    MAKESHORT( PRTYD_MAXIMUM / 2, PRTYC_REGULAR )
+#   define VLC_THREAD_PRIORITY_AUDIO    MAKESHORT( PRTYD_MAXIMUM, PRTYC_REGULAR )
+#   define VLC_THREAD_PRIORITY_VIDEO    0
+#   define VLC_THREAD_PRIORITY_OUTPUT   MAKESHORT( PRTYD_MAXIMUM / 2, PRTYC_REGULAR )
+#   define VLC_THREAD_PRIORITY_HIGHEST  MAKESHORT( 0, PRTYC_TIMECRITICAL )
+
+#else
+#   define VLC_THREAD_PRIORITY_LOW 0
+#   define VLC_THREAD_PRIORITY_INPUT 0
+#   define VLC_THREAD_PRIORITY_AUDIO 0
+#   define VLC_THREAD_PRIORITY_VIDEO 0
+#   define VLC_THREAD_PRIORITY_OUTPUT 0
+#   define VLC_THREAD_PRIORITY_HIGHEST 0
+
+#endif
+
+/*****************************************************************************
+ * Type definitions
+ *****************************************************************************/
+
+#if defined (LIBVLC_USE_PTHREAD)
+typedef pthread_t       vlc_thread_t;
+typedef pthread_mutex_t vlc_mutex_t;
+#define VLC_STATIC_MUTEX PTHREAD_MUTEX_INITIALIZER
+typedef pthread_cond_t  vlc_cond_t;
+#define VLC_STATIC_COND  PTHREAD_COND_INITIALIZER
+typedef pthread_rwlock_t vlc_rwlock_t;
+#define VLC_STATIC_RWLOCK PTHREAD_RWLOCK_INITIALIZER
+typedef pthread_key_t   vlc_threadvar_t;
+typedef struct vlc_timer *vlc_timer_t;
+
+#if defined (__APPLE__)
+typedef semaphore_t     vlc_sem_t;
+#else
+typedef sem_t           vlc_sem_t;
+#endif
+
+#elif defined( WIN32 )
+typedef struct vlc_thread *vlc_thread_t;
+
+typedef struct
+{
+    bool dynamic;
+    union
+    {
+        struct
+        {
+            bool locked;
+            unsigned long contention;
+        };
+        CRITICAL_SECTION mutex;
+    };
+} vlc_mutex_t;
+#define VLC_STATIC_MUTEX { false, { { false, 0 } } }
+
+typedef struct
+{
+    HANDLE   handle;
+    unsigned clock;
+} vlc_cond_t;
+#define VLC_STATIC_COND { 0, 0 }
+
+typedef HANDLE  vlc_sem_t;
+
+typedef struct
+{
+    vlc_mutex_t   mutex;
+    vlc_cond_t    wait;
+    unsigned long readers;
+    unsigned long writers;
+    DWORD         writer;
+} vlc_rwlock_t;
+#define VLC_STATIC_RWLOCK \
+    { VLC_STATIC_MUTEX, VLC_STATIC_COND, 0, 0, 0 }
+
+typedef struct vlc_threadvar *vlc_threadvar_t;
+typedef struct vlc_timer *vlc_timer_t;
+
+#elif defined( __OS2__ )
+typedef struct vlc_thread *vlc_thread_t;
+
+typedef struct
+{
+    bool dynamic;
+    union
+    {
+        struct
+        {
+            bool locked;
+            unsigned long contention;
+        };
+        HMTX hmtx;
+    };
+} vlc_mutex_t;
+
+#define VLC_STATIC_MUTEX { false, { { false, 0 } } }
+
+typedef struct
+{
+    HEV      hev;
+    unsigned clock;
+} vlc_cond_t;
+
+#define VLC_STATIC_COND { 0, 0 }
+
+typedef struct
+{
+    HEV  hev;
+    HMTX wait_mutex;
+    HMTX count_mutex;
+    int  count;
+} vlc_sem_t;
+
+typedef struct
+{
+    vlc_mutex_t   mutex;
+    vlc_cond_t    wait;
+    unsigned long readers;
+    unsigned long writers;
+    int           writer;
+} vlc_rwlock_t;
+#define VLC_STATIC_RWLOCK \
+    { VLC_STATIC_MUTEX, VLC_STATIC_COND, 0, 0, 0 }
+
+typedef struct vlc_threadvar *vlc_threadvar_t;
+typedef struct vlc_timer *vlc_timer_t;
+
+#endif
+
+#if defined( WIN32 ) && !defined ETIMEDOUT
+#  define ETIMEDOUT 10060 /* This is the value in winsock.h. */
+#endif
+
+/*****************************************************************************
+ * Function definitions
+ *****************************************************************************/
+VLC_API void vlc_mutex_init( vlc_mutex_t * );
+VLC_API void vlc_mutex_init_recursive( vlc_mutex_t * );
+VLC_API void vlc_mutex_destroy( vlc_mutex_t * );
+VLC_API void vlc_mutex_lock( vlc_mutex_t * );
+VLC_API int vlc_mutex_trylock( vlc_mutex_t * ) VLC_USED;
+VLC_API void vlc_mutex_unlock( vlc_mutex_t * );
+VLC_API void vlc_cond_init( vlc_cond_t * );
+VLC_API void vlc_cond_init_daytime( vlc_cond_t * );
+VLC_API void vlc_cond_destroy( vlc_cond_t * );
+VLC_API void vlc_cond_signal(vlc_cond_t *);
+VLC_API void vlc_cond_broadcast(vlc_cond_t *);
+VLC_API void vlc_cond_wait(vlc_cond_t *, vlc_mutex_t *);
+VLC_API int vlc_cond_timedwait(vlc_cond_t *, vlc_mutex_t *, mtime_t);
+VLC_API void vlc_sem_init(vlc_sem_t *, unsigned);
+VLC_API void vlc_sem_destroy(vlc_sem_t *);
+VLC_API int vlc_sem_post(vlc_sem_t *);
+VLC_API void vlc_sem_wait(vlc_sem_t *);
+
+VLC_API void vlc_rwlock_init(vlc_rwlock_t *);
+VLC_API void vlc_rwlock_destroy(vlc_rwlock_t *);
+VLC_API void vlc_rwlock_rdlock(vlc_rwlock_t *);
+VLC_API void vlc_rwlock_wrlock(vlc_rwlock_t *);
+VLC_API void vlc_rwlock_unlock(vlc_rwlock_t *);
+VLC_API int vlc_threadvar_create(vlc_threadvar_t * , void (*) (void *) );
+VLC_API void vlc_threadvar_delete(vlc_threadvar_t *);
+VLC_API int vlc_threadvar_set(vlc_threadvar_t, void *);
+VLC_API void * vlc_threadvar_get(vlc_threadvar_t);
+
+VLC_API int vlc_clone(vlc_thread_t *, void * (*) (void *), void *, int) VLC_USED;
+VLC_API void vlc_cancel(vlc_thread_t);
+VLC_API void vlc_join(vlc_thread_t, void **);
+VLC_API void vlc_control_cancel (int cmd, ...);
+
+VLC_API mtime_t mdate(void);
+VLC_API void mwait(mtime_t deadline);
+VLC_API void msleep(mtime_t delay);
+
+#define VLC_HARD_MIN_SLEEP   10000 /* 10 milliseconds = 1 tick at 100Hz */
+#define VLC_SOFT_MIN_SLEEP 9000000 /* 9 seconds */
+
+#if VLC_GCC_VERSION(4,3)
+/* Linux has 100, 250, 300 or 1000Hz
+ *
+ * HZ=100 by default on FreeBSD, but some architectures use a 1000Hz timer
+ */
+
+static
+__attribute__((unused))
+__attribute__((noinline))
+__attribute__((error("sorry, cannot sleep for such short a time")))
+mtime_t impossible_delay( mtime_t delay )
+{
+    (void) delay;
+    return VLC_HARD_MIN_SLEEP;
+}
+
+static
+__attribute__((unused))
+__attribute__((noinline))
+__attribute__((warning("use proper event handling instead of short delay")))
+mtime_t harmful_delay( mtime_t delay )
+{
+    return delay;
+}
+
+# define check_delay( d ) \
+    ((__builtin_constant_p(d < VLC_HARD_MIN_SLEEP) \
+   && (d < VLC_HARD_MIN_SLEEP)) \
+       ? impossible_delay(d) \
+       : ((__builtin_constant_p(d < VLC_SOFT_MIN_SLEEP) \
+       && (d < VLC_SOFT_MIN_SLEEP)) \
+           ? harmful_delay(d) \
+           : d))
+
+static
+__attribute__((unused))
+__attribute__((noinline))
+__attribute__((error("deadlines can not be constant")))
+mtime_t impossible_deadline( mtime_t deadline )
+{
+    return deadline;
+}
+
+# define check_deadline( d ) \
+    (__builtin_constant_p(d) ? impossible_deadline(d) : d)
+#else
+# define check_delay(d) (d)
+# define check_deadline(d) (d)
+#endif
+
+#define msleep(d) msleep(check_delay(d))
+#define mwait(d) mwait(check_deadline(d))
+
+VLC_API int vlc_timer_create(vlc_timer_t *, void (*) (void *), void *) VLC_USED;
+VLC_API void vlc_timer_destroy(vlc_timer_t);
+VLC_API void vlc_timer_schedule(vlc_timer_t, bool, mtime_t, mtime_t);
+VLC_API unsigned vlc_timer_getoverrun(vlc_timer_t) VLC_USED;
+
+VLC_API unsigned vlc_GetCPUCount(void);
+
+#ifndef LIBVLC_USE_PTHREAD_CANCEL
+enum {
+    VLC_CLEANUP_PUSH,
+    VLC_CLEANUP_POP,
+};
+#endif
+
+VLC_API int vlc_savecancel(void);
+VLC_API void vlc_restorecancel(int state);
+VLC_API void vlc_testcancel(void);
+
+#if defined (LIBVLC_USE_PTHREAD_CANCEL)
+/**
+ * Registers a new procedure to run if the thread is cancelled (or otherwise
+ * exits prematurely). Any call to vlc_cleanup_push() <b>must</b> paired with a
+ * call to either vlc_cleanup_pop() or vlc_cleanup_run(). Branching into or out
+ * of the block between these two function calls is not allowed (read: it will
+ * likely crash the whole process). If multiple procedures are registered,
+ * they are handled in last-in first-out order.
+ *
+ * @param routine procedure to call if the thread ends
+ * @param arg argument for the procedure
+ */
+# define vlc_cleanup_push( routine, arg ) pthread_cleanup_push (routine, arg)
+
+/**
+ * Removes a cleanup procedure that was previously registered with
+ * vlc_cleanup_push().
+ */
+# define vlc_cleanup_pop( ) pthread_cleanup_pop (0)
+
+/**
+ * Removes a cleanup procedure that was previously registered with
+ * vlc_cleanup_push(), and executes it.
+ */
+# define vlc_cleanup_run( ) pthread_cleanup_pop (1)
+#else
+typedef struct vlc_cleanup_t vlc_cleanup_t;
+
+struct vlc_cleanup_t
+{
+    vlc_cleanup_t *next;
+    void         (*proc) (void *);
+    void          *data;
+};
+
+/* This macros opens a code block on purpose. This is needed for multiple
+ * calls within a single function. This also prevent Win32 developers from
+ * writing code that would break on POSIX (POSIX opens a block as well). */
+# define vlc_cleanup_push( routine, arg ) \
+    do { \
+        vlc_cleanup_t vlc_cleanup_data = { NULL, routine, arg, }; \
+        vlc_control_cancel (VLC_CLEANUP_PUSH, &vlc_cleanup_data)
+
+# define vlc_cleanup_pop( ) \
+        vlc_control_cancel (VLC_CLEANUP_POP); \
+    } while (0)
+
+# define vlc_cleanup_run( ) \
+        vlc_control_cancel (VLC_CLEANUP_POP); \
+        vlc_cleanup_data.proc (vlc_cleanup_data.data); \
+    } while (0)
+
+#endif /* LIBVLC_USE_PTHREAD_CANCEL */
+
+static inline void vlc_cleanup_lock (void *lock)
+{
+    vlc_mutex_unlock ((vlc_mutex_t *)lock);
+}
+#define mutex_cleanup_push( lock ) vlc_cleanup_push (vlc_cleanup_lock, lock)
+
+# if defined (_POSIX_SPIN_LOCKS) && ((_POSIX_SPIN_LOCKS - 0) > 0)
+typedef pthread_spinlock_t vlc_spinlock_t;
+
+/**
+ * Initializes a spinlock.
+ */
+static inline void vlc_spin_init (vlc_spinlock_t *spin)
+{
+    if (pthread_spin_init (spin, PTHREAD_PROCESS_PRIVATE))
+        abort ();
+}
+
+/**
+ * Acquires a spinlock.
+ */
+static inline void vlc_spin_lock (vlc_spinlock_t *spin)
+{
+    pthread_spin_lock (spin);
+}
+
+/**
+ * Releases a spinlock.
+ */
+static inline void vlc_spin_unlock (vlc_spinlock_t *spin)
+{
+    pthread_spin_unlock (spin);
+}
+
+/**
+ * Deinitializes a spinlock.
+ */
+static inline void vlc_spin_destroy (vlc_spinlock_t *spin)
+{
+    pthread_spin_destroy (spin);
+}
+
+#elif defined (WIN32) && !defined (UNDER_CE)
+
+typedef CRITICAL_SECTION vlc_spinlock_t;
+
+/**
+ * Initializes a spinlock.
+ */
+static inline void vlc_spin_init (vlc_spinlock_t *spin)
+{
+    if (!InitializeCriticalSectionAndSpinCount(spin, 4000))
+        abort ();
+}
+
+/**
+ * Acquires a spinlock.
+ */
+static inline void vlc_spin_lock (vlc_spinlock_t *spin)
+{
+    EnterCriticalSection(spin);
+}
+
+/**
+ * Releases a spinlock.
+ */
+static inline void vlc_spin_unlock (vlc_spinlock_t *spin)
+{
+    LeaveCriticalSection(spin);
+}
+
+/**
+ * Deinitializes a spinlock.
+ */
+static inline void vlc_spin_destroy (vlc_spinlock_t *spin)
+{
+    DeleteCriticalSection(spin);
+}
+
+#else
+
+/* Fallback to plain mutexes if spinlocks are not available */
+typedef vlc_mutex_t vlc_spinlock_t;
+
+static inline void vlc_spin_init (vlc_spinlock_t *spin)
+{
+    vlc_mutex_init (spin);
+}
+
+# define vlc_spin_lock    vlc_mutex_lock
+# define vlc_spin_unlock  vlc_mutex_unlock
+# define vlc_spin_destroy vlc_mutex_destroy
+#endif
+
+/**
+ * Issues a full memory barrier.
+ */
+#if defined (__APPLE__)
+# include <libkern/OSAtomic.h> /* OSMemoryBarrier() */
+#endif
+static inline void barrier (void)
+{
+#if defined (__GNUC__) && !defined (__APPLE__) && \
+            ((__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 1))
+    __sync_synchronize ();
+#elif defined(__APPLE__)
+    OSMemoryBarrier ();
+#elif defined(__powerpc__)
+    asm volatile ("sync":::"memory");
+#elif 0 // defined(__i386__) /*  Requires SSE2 support */
+    asm volatile ("mfence":::"memory");
+#else
+    vlc_spinlock_t spin;
+    vlc_spin_init (&spin);
+    vlc_spin_lock (&spin);
+    vlc_spin_unlock (&spin);
+    vlc_spin_destroy (&spin);
+#endif
+}
+
+#ifdef __cplusplus
+/**
+ * Helper C++ class to lock a mutex.
+ * The mutex is locked when the object is created, and unlocked when the object
+ * is destroyed.
+ */
+class vlc_mutex_locker
+{
+    private:
+        vlc_mutex_t *lock;
+    public:
+        vlc_mutex_locker (vlc_mutex_t *m) : lock (m)
+        {
+            vlc_mutex_lock (lock);
+        }
+
+        ~vlc_mutex_locker (void)
+        {
+            vlc_mutex_unlock (lock);
+        }
+};
+#endif
+
+enum {
+   VLC_AVCODEC_MUTEX = 0,
+   VLC_GCRYPT_MUTEX,
+   VLC_XLIB_MUTEX,
+   VLC_MOSAIC_MUTEX,
+   VLC_HIGHLIGHT_MUTEX,
+   /* Insert new entry HERE */
+   VLC_MAX_MUTEX
+};
+
+VLC_API void vlc_global_mutex( unsigned, bool );
+#define vlc_global_lock( n ) vlc_global_mutex( n, true )
+#define vlc_global_unlock( n ) vlc_global_mutex( n, false )
+
+#endif /* !_VLC_THREADS_H */

=== added file 'DivCity/DivCity/vlc/plugins/vlc_tls.h'
--- DivCity/DivCity/vlc/plugins/vlc_tls.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_tls.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,84 @@
+/*****************************************************************************
+ * vlc_tls.h: Transport Layer Security API
+ *****************************************************************************
+ * Copyright (C) 2004-2011 RÃ©mi Denis-Courmont
+ * Copyright (C) 2005-2006 VLC authors and VideoLAN
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_TLS_H
+# define VLC_TLS_H
+
+/**
+ * \file
+ * This file defines Transport Layer Security API (TLS) in vlc
+ */
+
+# include <vlc_network.h>
+
+typedef struct vlc_tls_sys vlc_tls_sys_t;
+
+typedef struct vlc_tls
+{
+    VLC_COMMON_MEMBERS
+
+    union {
+        module_t *module; /**< Plugin handle (client) */
+        void    (*close) (struct vlc_tls *); /**< Close callback (server) */
+    } u;
+    vlc_tls_sys_t *sys;
+
+    struct virtual_socket_t sock;
+    int  (*handshake) (struct vlc_tls *);
+} vlc_tls_t;
+
+VLC_API vlc_tls_t *vlc_tls_ClientCreate (vlc_object_t *, int fd,
+                                         const char *hostname);
+VLC_API void vlc_tls_ClientDelete (vlc_tls_t *);
+
+/* NOTE: It is assumed that a->sock.p_sys = a */
+# define tls_Send( a, b, c ) (((vlc_tls_t *)a)->sock.pf_send (a, b, c))
+
+# define tls_Recv( a, b, c ) (((vlc_tls_t *)a)->sock.pf_recv (a, b, c))
+
+
+typedef struct vlc_tls_creds_sys vlc_tls_creds_sys_t;
+
+/** TLS (server-side) credentials */
+typedef struct vlc_tls_creds
+{
+    VLC_COMMON_MEMBERS
+
+    module_t  *module;
+    vlc_tls_creds_sys_t *sys;
+
+    int (*add_CA) (struct vlc_tls_creds *, const char *path);
+    int (*add_CRL) (struct vlc_tls_creds *, const char *path);
+
+    vlc_tls_t *(*open) (struct vlc_tls_creds *, int fd);
+} vlc_tls_creds_t;
+
+vlc_tls_creds_t *vlc_tls_ServerCreate (vlc_object_t *,
+                                       const char *cert, const char *key);
+void vlc_tls_ServerDelete (vlc_tls_creds_t *);
+int vlc_tls_ServerAddCA (vlc_tls_creds_t *srv, const char *path);
+int vlc_tls_ServerAddCRL (vlc_tls_creds_t *srv, const char *path);
+
+vlc_tls_t *vlc_tls_ServerSessionCreate (vlc_tls_creds_t *, int fd);
+int vlc_tls_ServerSessionHandshake (vlc_tls_t *);
+void vlc_tls_ServerSessionDelete (vlc_tls_t *);
+
+#endif

=== added file 'DivCity/DivCity/vlc/plugins/vlc_url.h'
--- DivCity/DivCity/vlc/plugins/vlc_url.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_url.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,226 @@
+/*****************************************************************************
+ * vlc_url.h: URL related macros
+ *****************************************************************************
+ * Copyright (C) 2002-2006 VLC authors and VideoLAN
+ * $Id: 994d8ff24e3e897bc19e02476842b3d4cd29a336 $
+ *
+ * Authors: Christophe Massiot <massiot@via.ecp.fr>
+ *          RÃ©mi Denis-Courmont <rem # videolan.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_URL_H
+# define VLC_URL_H
+
+/**
+ * \file
+ * This file defines functions for manipulating URL in vlc
+ */
+
+struct vlc_url_t
+{
+    char *psz_protocol;
+    char *psz_username;
+    char *psz_password;
+    char *psz_host;
+    int  i_port;
+
+    char *psz_path;
+
+    char *psz_option;
+
+    char *psz_buffer; /* to be freed */
+};
+
+VLC_API char * decode_URI_duplicate( const char *psz );
+VLC_API char * decode_URI( char *psz );
+VLC_API char * encode_URI_component( const char *psz );
+VLC_API char * make_URI( const char *path, const char *scheme );
+VLC_API char * make_path( const char *url );
+
+/*****************************************************************************
+ * vlc_UrlParse:
+ *****************************************************************************
+ * option : if != 0 then path is split at this char
+ *
+ * format [protocol://[login[:password]@]][host[:port]]/path[OPTIONoption]
+ *****************************************************************************/
+static inline void vlc_UrlParse( vlc_url_t *url, const char *psz_url,
+                                 char option )
+{
+    char *psz_dup;
+    char *psz_parse;
+    char *p;
+    char *p2;
+
+    url->psz_protocol = NULL;
+    url->psz_username = NULL;
+    url->psz_password = NULL;
+    url->psz_host     = NULL;
+    url->i_port       = 0;
+    url->psz_path     = NULL;
+    url->psz_option   = NULL;
+
+    if( psz_url == NULL )
+    {
+        url->psz_buffer = NULL;
+        return;
+    }
+    url->psz_buffer = psz_parse = psz_dup = strdup( psz_url );
+
+    /* Search a valid protocol */
+    p  = strstr( psz_parse, ":/" );
+    if( p != NULL )
+    {
+        for( p2 = psz_parse; p2 < p; p2++ )
+        {
+#define I(i,a,b) ( (a) <= (i) && (i) <= (b) )
+            if( !I(*p2, 'a', 'z' ) && !I(*p2, 'A', 'Z') && !I(*p2, '0', '9') && *p2 != '+' && *p2 != '-' && *p2 != '.' )
+            {
+                p = NULL;
+                break;
+            }
+#undef I
+        }
+    }
+
+    if( p != NULL )
+    {
+        /* we have a protocol */
+
+        /* skip :// */
+        *p++ = '\0';
+        if( p[1] == '/' )
+            p += 2;
+        url->psz_protocol = psz_parse;
+        psz_parse = p;
+    }
+    p = strchr( psz_parse, '@' );
+    p2 = strchr( psz_parse, '/' );
+    if( p != NULL && ( p2 != NULL ? p < p2 : 1 ) )
+    {
+        /* We have a login */
+        url->psz_username = psz_parse;
+        *p++ = '\0';
+
+        psz_parse = strchr( psz_parse, ':' );
+        if( psz_parse != NULL )
+        {
+            /* We have a password */
+            *psz_parse++ = '\0';
+            url->psz_password = psz_parse;
+            decode_URI( url->psz_password );
+        }
+        decode_URI( url->psz_username );
+        psz_parse = p;
+    }
+
+    p = strchr( psz_parse, '/' );
+    if( !p || psz_parse < p )
+    {
+        /* We have a host[:port] */
+        url->psz_host = strdup( psz_parse );
+        if( p )
+        {
+            url->psz_host[p - psz_parse] = '\0';
+        }
+
+        if( *url->psz_host == '[' )
+        {
+            /* Ipv6 address */
+            p2 = strchr( url->psz_host, ']' );
+            if( p2 )
+            {
+                p2 = strchr( p2, ':' );
+            }
+        }
+        else
+        {
+            p2 = strchr( url->psz_host, ':' );
+        }
+        if( p2 )
+        {
+            *p2++ = '\0';
+            url->i_port = atoi( p2 );
+        }
+    }
+    psz_parse = p;
+
+    /* Now parse psz_path and psz_option */
+    if( psz_parse )
+    {
+        url->psz_path = psz_parse;
+        if( option != '\0' )
+        {
+            p = strchr( url->psz_path, option );
+            if( p )
+            {
+                *p++ = '\0';
+                url->psz_option = p;
+            }
+        }
+    }
+}
+
+/*****************************************************************************
+ * vlc_UrlClean:
+ *****************************************************************************/
+static inline void vlc_UrlClean( vlc_url_t *url )
+{
+    free( url->psz_buffer );
+    free( url->psz_host );
+
+    url->psz_protocol = NULL;
+    url->psz_username = NULL;
+    url->psz_password = NULL;
+    url->psz_host     = NULL;
+    url->i_port       = 0;
+    url->psz_path     = NULL;
+    url->psz_option   = NULL;
+
+    url->psz_buffer   = NULL;
+}
+
+#include <ctype.h>
+
+/** Check whether a given string is not a valid URL and must hence be
+ *  encoded */
+static inline int vlc_UrlIsNotEncoded( const char *psz_url )
+{
+    const char *ptr;
+
+    for( ptr = psz_url; *ptr; ptr++ )
+    {
+        unsigned char c = *ptr;
+
+        if( c == '%' )
+        {
+            if( !isxdigit( (unsigned char)ptr[1] )
+             || !isxdigit( (unsigned char)ptr[2] ) )
+                return 1; /* not encoded */
+            ptr += 2;
+        }
+        else
+        if(  ( (unsigned char)( c - 'a' ) < 26 )
+          || ( (unsigned char)( c - 'A' ) < 26 )
+          || ( (unsigned char)( c - '0' ) < 10 )
+          || ( strchr( "-_.", c ) != NULL ) )
+            return 1;
+    }
+    return 0; /* looks fine - but maybe it is not encoded */
+}
+
+#endif

=== added file 'DivCity/DivCity/vlc/plugins/vlc_variables.h'
--- DivCity/DivCity/vlc/plugins/vlc_variables.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_variables.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,759 @@
+/*****************************************************************************
+ * variables.h: variables handling
+ *****************************************************************************
+ * Copyright (C) 2002-2004 VLC authors and VideoLAN
+ * $Id: f205d4c1dd87fde7159c569b0a62d0ccdb78e016 $
+ *
+ * Authors: Samuel Hocevar <sam@zoy.org>
+ *          Gildas Bazin <gbazin@netcourrier.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_VARIABLES_H
+#define VLC_VARIABLES_H 1
+
+/**
+ * \file
+ * This file defines functions and structures for dynamic variables in vlc
+ */
+
+/**
+ * \defgroup variables Variables
+ *
+ * Functions for using the object variables in vlc.
+ *
+ * Vlc have a very powerful "object variable" infrastructure useful
+ * for many things.
+ *
+ * @{
+ */
+
+#define VLC_VAR_TYPE      0x00ff
+#define VLC_VAR_CLASS     0x00f0
+#define VLC_VAR_FLAGS     0xff00
+
+/**
+ * \defgroup var_type Variable types
+ * These are the different types a vlc variable can have.
+ * @{
+ */
+#define VLC_VAR_VOID      0x0010
+#define VLC_VAR_BOOL      0x0020
+#define VLC_VAR_INTEGER   0x0030
+#define VLC_VAR_HOTKEY    0x0031
+#define VLC_VAR_STRING    0x0040
+#define VLC_VAR_VARIABLE  0x0044
+#define VLC_VAR_FLOAT     0x0050
+#define VLC_VAR_TIME      0x0060
+#define VLC_VAR_ADDRESS   0x0070
+#define VLC_VAR_COORDS    0x00A0
+/**@}*/
+
+/** \defgroup var_flags Additive flags
+ * These flags are added to the type field of the variable. Most as a result of
+ * a var_Change() call, but some may be added at creation time
+ * @{
+ */
+#define VLC_VAR_HASCHOICE 0x0100
+#define VLC_VAR_HASMIN    0x0200
+#define VLC_VAR_HASMAX    0x0400
+#define VLC_VAR_HASSTEP   0x0800
+
+#define VLC_VAR_ISCOMMAND 0x2000
+
+/** Creation flag */
+/* If the variable is not found on the current module
+   search all parents and finally module config until found */
+#define VLC_VAR_DOINHERIT 0x8000
+/**@}*/
+
+/**
+ * \defgroup var_action Variable actions
+ * These are the different actions that can be used with var_Change().
+ * The parameters given are the meaning of the two last parameters of
+ * var_Change() when this action is being used.
+ * @{
+ */
+
+/**
+ * Set the minimum value of this variable
+ * \param p_val The new minimum value
+ * \param p_val2 Unused
+ */
+#define VLC_VAR_SETMIN              0x0010
+/**
+ * Set the maximum value of this variable
+ * \param p_val The new maximum value
+ * \param p_val2 Unused
+ */
+#define VLC_VAR_SETMAX              0x0011
+#define VLC_VAR_SETSTEP             0x0012
+
+/**
+ * Set the value of this variable without triggering any callbacks
+ * \param p_val The new value
+ * \param p_val2 Unused
+ */
+#define VLC_VAR_SETVALUE            0x0013
+
+#define VLC_VAR_SETTEXT             0x0014
+#define VLC_VAR_GETTEXT             0x0015
+
+#define VLC_VAR_GETMIN              0x0016
+#define VLC_VAR_GETMAX              0x0017
+#define VLC_VAR_GETSTEP             0x0018
+
+#define VLC_VAR_ADDCHOICE           0x0020
+#define VLC_VAR_DELCHOICE           0x0021
+#define VLC_VAR_CLEARCHOICES        0x0022
+#define VLC_VAR_SETDEFAULT          0x0023
+#define VLC_VAR_GETCHOICES          0x0024
+#define VLC_VAR_GETLIST             0x0025
+#define VLC_VAR_CHOICESCOUNT        0x0026
+
+#define VLC_VAR_SETISCOMMAND        0x0040
+/**@}*/
+
+/** \defgroup var_GetAndSet Variable actions
+ * These are the different actions that can be used with var_GetAndSet()
+ * @{
+ */
+enum {
+    VLC_VAR_BOOL_TOGGLE, /**< Invert a boolean value (param ignored) */
+    VLC_VAR_INTEGER_ADD, /**< Add parameter to an integer value */
+    VLC_VAR_INTEGER_OR,  /**< Binary OR over an integer bits field */
+    VLC_VAR_INTEGER_NAND,/**< Binary NAND over an integer bits field */
+};
+/**@}*/
+
+/*****************************************************************************
+ * Prototypes
+ *****************************************************************************/
+VLC_API int var_Create( vlc_object_t *, const char *, int );
+#define var_Create(a,b,c) var_Create( VLC_OBJECT(a), b, c )
+
+VLC_API int var_Destroy( vlc_object_t *, const char * );
+#define var_Destroy(a,b) var_Destroy( VLC_OBJECT(a), b )
+
+VLC_API int var_Change( vlc_object_t *, const char *, int, vlc_value_t *, vlc_value_t * );
+#define var_Change(a,b,c,d,e) var_Change( VLC_OBJECT(a), b, c, d, e )
+
+VLC_API int var_Type( vlc_object_t *, const char * ) VLC_USED;
+#define var_Type(a,b) var_Type( VLC_OBJECT(a), b )
+
+VLC_API int var_Set( vlc_object_t *, const char *, vlc_value_t );
+#define var_Set(a,b,c) var_Set( VLC_OBJECT(a), b, c )
+
+VLC_API int var_Get( vlc_object_t *, const char *, vlc_value_t * );
+#define var_Get(a,b,c) var_Get( VLC_OBJECT(a), b, c )
+
+VLC_API int var_SetChecked( vlc_object_t *, const char *, int, vlc_value_t );
+#define var_SetChecked(o,n,t,v) var_SetChecked(VLC_OBJECT(o),n,t,v)
+VLC_API int var_GetChecked( vlc_object_t *, const char *, int, vlc_value_t * );
+#define var_GetChecked(o,n,t,v) var_GetChecked(VLC_OBJECT(o),n,t,v)
+VLC_API int var_GetAndSet( vlc_object_t *, const char *, int, vlc_value_t * );
+
+VLC_API int var_Inherit( vlc_object_t *, const char *, int, vlc_value_t * );
+
+VLC_API int var_Command( vlc_object_t *, const char *, const char *, const char *, char ** );
+#define var_Command(a,b,c,d,e) var_Command( VLC_OBJECT( a ), b, c, d, e )
+
+VLC_API void var_FreeList( vlc_value_t *, vlc_value_t * );
+
+
+/*****************************************************************************
+ * Variable callbacks
+ *****************************************************************************
+ * int MyCallback( vlc_object_t *p_this,
+ *                 char const *psz_variable,
+ *                 vlc_value_t oldvalue,
+ *                 vlc_value_t newvalue,
+ *                 void *p_data);
+ *****************************************************************************/
+VLC_API int var_AddCallback( vlc_object_t *, const char *, vlc_callback_t, void * );
+VLC_API int var_DelCallback( vlc_object_t *, const char *, vlc_callback_t, void * );
+VLC_API int var_TriggerCallback( vlc_object_t *, const char * );
+
+#define var_AddCallback(a,b,c,d) var_AddCallback( VLC_OBJECT(a), b, c, d )
+#define var_DelCallback(a,b,c,d) var_DelCallback( VLC_OBJECT(a), b, c, d )
+#define var_TriggerCallback(a,b) var_TriggerCallback( VLC_OBJECT(a), b )
+
+/*****************************************************************************
+ * helpers functions
+ *****************************************************************************/
+
+/**
+ * Set the value of an integer variable
+ *
+ * \param p_obj The object that holds the variable
+ * \param psz_name The name of the variable
+ * \param i The new integer value of this variable
+ */
+static inline int var_SetInteger( vlc_object_t *p_obj, const char *psz_name,
+                                  int64_t i )
+{
+    vlc_value_t val;
+    val.i_int = i;
+    return var_SetChecked( p_obj, psz_name, VLC_VAR_INTEGER, val );
+}
+
+/**
+ * Set the value of an boolean variable
+ *
+ * \param p_obj The object that holds the variable
+ * \param psz_name The name of the variable
+ * \param b The new boolean value of this variable
+ */
+static inline int var_SetBool( vlc_object_t *p_obj, const char *psz_name, bool b )
+{
+    vlc_value_t val;
+    val.b_bool = b;
+    return var_SetChecked( p_obj, psz_name, VLC_VAR_BOOL, val );
+}
+
+/**
+ * Set the value of a time variable
+ *
+ * \param p_obj The object that holds the variable
+ * \param psz_name The name of the variable
+ * \param i The new time value of this variable
+ */
+static inline int var_SetTime( vlc_object_t *p_obj, const char *psz_name, int64_t i )
+{
+    vlc_value_t val;
+    val.i_time = i;
+    return var_SetChecked( p_obj, psz_name, VLC_VAR_TIME, val );
+}
+
+static inline int var_SetCoords( vlc_object_t *obj, const char *name,
+                                 int32_t x, int32_t y )
+{
+    vlc_value_t val;
+    val.coords.x = x;
+    val.coords.y = y;
+    return var_SetChecked (obj, name, VLC_VAR_COORDS, val);
+}
+#define var_SetCoords(o,n,x,y) var_SetCoords(VLC_OBJECT(o),n,x,y)
+
+/**
+ * Set the value of a float variable
+ *
+ * \param p_obj The object that holds the variable
+ * \param psz_name The name of the variable
+ * \param f The new float value of this variable
+ */
+static inline int var_SetFloat( vlc_object_t *p_obj, const char *psz_name, float f )
+{
+    vlc_value_t val;
+    val.f_float = f;
+    return var_SetChecked( p_obj, psz_name, VLC_VAR_FLOAT, val );
+}
+
+/**
+ * Set the value of a string variable
+ *
+ * \param p_obj The object that holds the variable
+ * \param psz_name The name of the variable
+ * \param psz_string The new string value of this variable
+ */
+static inline int var_SetString( vlc_object_t *p_obj, const char *psz_name, const char *psz_string )
+{
+    vlc_value_t val;
+    val.psz_string = (char *)psz_string;
+    return var_SetChecked( p_obj, psz_name, VLC_VAR_STRING, val );
+}
+
+/**
+ * Set the value of a pointer variable
+ *
+ * \param p_obj The object that holds the variable
+ * \param psz_name The name of the variable
+ * \param ptr The new pointer value of this variable
+ */
+static inline
+int var_SetAddress( vlc_object_t *p_obj, const char *psz_name, void *ptr )
+{
+    vlc_value_t val;
+    val.p_address = ptr;
+    return var_SetChecked( p_obj, psz_name, VLC_VAR_ADDRESS, val );
+}
+
+#define var_SetInteger(a,b,c)   var_SetInteger( VLC_OBJECT(a),b,c)
+#define var_SetBool(a,b,c)      var_SetBool( VLC_OBJECT(a),b,c)
+#define var_SetTime(a,b,c)      var_SetTime( VLC_OBJECT(a),b,c)
+#define var_SetFloat(a,b,c)     var_SetFloat( VLC_OBJECT(a),b,c)
+#define var_SetString(a,b,c)    var_SetString( VLC_OBJECT(a),b,c)
+#define var_SetAddress(o, n, p) var_SetAddress(VLC_OBJECT(o), n, p)
+
+
+/**
+ * Get an integer value
+*
+ * \param p_obj The object that holds the variable
+ * \param psz_name The name of the variable
+ */
+VLC_USED
+static inline int64_t var_GetInteger( vlc_object_t *p_obj, const char *psz_name )
+{
+    vlc_value_t val;
+    if( !var_GetChecked( p_obj, psz_name, VLC_VAR_INTEGER, &val ) )
+        return val.i_int;
+    else
+        return 0;
+}
+
+/**
+ * Get a boolean value
+ *
+ * \param p_obj The object that holds the variable
+ * \param psz_name The name of the variable
+ */
+VLC_USED
+static inline bool var_GetBool( vlc_object_t *p_obj, const char *psz_name )
+{
+    vlc_value_t val; val.b_bool = false;
+
+    if( !var_GetChecked( p_obj, psz_name, VLC_VAR_BOOL, &val ) )
+        return val.b_bool;
+    else
+        return false;
+}
+
+/**
+ * Get a time value
+ *
+ * \param p_obj The object that holds the variable
+ * \param psz_name The name of the variable
+ */
+VLC_USED
+static inline int64_t var_GetTime( vlc_object_t *p_obj, const char *psz_name )
+{
+    vlc_value_t val; val.i_time = 0L;
+    if( !var_GetChecked( p_obj, psz_name, VLC_VAR_TIME, &val ) )
+        return val.i_time;
+    else
+        return 0;
+}
+
+static inline void var_GetCoords( vlc_object_t *obj, const char *name,
+                                  int32_t *px, int32_t *py )
+{
+    vlc_value_t val;
+
+    if (likely(!var_GetChecked (obj, name, VLC_VAR_COORDS, &val)))
+    {
+        *px = val.coords.x;
+        *py = val.coords.y;
+    }
+    else
+        *px = *py = 0;
+}
+#define var_GetCoords(o,n,x,y) var_GetCoords(VLC_OBJECT(o),n,x,y)
+
+/**
+ * Get a float value
+ *
+ * \param p_obj The object that holds the variable
+ * \param psz_name The name of the variable
+ */
+VLC_USED
+static inline float var_GetFloat( vlc_object_t *p_obj, const char *psz_name )
+{
+    vlc_value_t val; val.f_float = 0.0;
+    if( !var_GetChecked( p_obj, psz_name, VLC_VAR_FLOAT, &val ) )
+        return val.f_float;
+    else
+        return 0.0;
+}
+
+/**
+ * Get a string value
+ *
+ * \param p_obj The object that holds the variable
+ * \param psz_name The name of the variable
+ */
+VLC_USED VLC_MALLOC
+static inline char *var_GetString( vlc_object_t *p_obj, const char *psz_name )
+{
+    vlc_value_t val; val.psz_string = NULL;
+    if( var_GetChecked( p_obj, psz_name, VLC_VAR_STRING, &val ) )
+        return NULL;
+    else
+        return val.psz_string;
+}
+
+VLC_USED VLC_MALLOC
+static inline char *var_GetNonEmptyString( vlc_object_t *p_obj, const char *psz_name )
+{
+    vlc_value_t val;
+    if( var_GetChecked( p_obj, psz_name, VLC_VAR_STRING, &val ) )
+        return NULL;
+    if( val.psz_string && *val.psz_string )
+        return val.psz_string;
+    free( val.psz_string );
+    return NULL;
+}
+
+VLC_USED
+static inline void *var_GetAddress( vlc_object_t *p_obj, const char *psz_name )
+{
+    vlc_value_t val;
+    if( var_GetChecked( p_obj, psz_name, VLC_VAR_ADDRESS, &val ) )
+        return NULL;
+    else
+        return val.p_address;
+}
+
+/**
+ * Increment an integer variable
+ * \param p_obj the object that holds the variable
+ * \param psz_name the name of the variable
+ */
+static inline int64_t var_IncInteger( vlc_object_t *p_obj, const char *psz_name )
+{
+    vlc_value_t val;
+    val.i_int = 1;
+    var_GetAndSet( p_obj, psz_name, VLC_VAR_INTEGER_ADD, &val );
+    return val.i_int;
+}
+#define var_IncInteger(a,b) var_IncInteger( VLC_OBJECT(a), b )
+
+/**
+ * Decrement an integer variable
+ * \param p_obj the object that holds the variable
+ * \param psz_name the name of the variable
+ */
+static inline int64_t var_DecInteger( vlc_object_t *p_obj, const char *psz_name )
+{
+    vlc_value_t val;
+    val.i_int = -1;
+    var_GetAndSet( p_obj, psz_name, VLC_VAR_INTEGER_ADD, &val );
+    return val.i_int;
+}
+#define var_DecInteger(a,b) var_DecInteger( VLC_OBJECT(a), b )
+
+static inline uint64_t var_OrInteger( vlc_object_t *obj, const char *name,
+                                      unsigned v )
+{
+    vlc_value_t val;
+    val.i_int = v;
+    var_GetAndSet( obj, name, VLC_VAR_INTEGER_OR, &val );
+    return val.i_int;
+}
+#define var_OrInteger(a,b,c) var_OrInteger(VLC_OBJECT(a),b,c)
+
+static inline uint64_t var_NAndInteger( vlc_object_t *obj, const char *name,
+                                        unsigned v )
+{
+    vlc_value_t val;
+    val.i_int = v;
+    var_GetAndSet( obj, name, VLC_VAR_INTEGER_NAND, &val );
+    return val.i_int;
+}
+#define var_NAndInteger(a,b,c) var_NAndInteger(VLC_OBJECT(a),b,c)
+
+/**
+ * Create a integer variable with inherit and get its value.
+ *
+ * \param p_obj The object that holds the variable
+ * \param psz_name The name of the variable
+ */
+VLC_USED
+static inline int64_t var_CreateGetInteger( vlc_object_t *p_obj, const char *psz_name )
+{
+    var_Create( p_obj, psz_name, VLC_VAR_INTEGER | VLC_VAR_DOINHERIT );
+    return var_GetInteger( p_obj, psz_name );
+}
+
+/**
+ * Create a boolean variable with inherit and get its value.
+ *
+ * \param p_obj The object that holds the variable
+ * \param psz_name The name of the variable
+ */
+VLC_USED
+static inline bool var_CreateGetBool( vlc_object_t *p_obj, const char *psz_name )
+{
+    var_Create( p_obj, psz_name, VLC_VAR_BOOL | VLC_VAR_DOINHERIT );
+    return var_GetBool( p_obj, psz_name );
+}
+
+/**
+ * Create a time variable with inherit and get its value.
+ *
+ * \param p_obj The object that holds the variable
+ * \param psz_name The name of the variable
+ */
+VLC_USED
+static inline int64_t var_CreateGetTime( vlc_object_t *p_obj, const char *psz_name )
+{
+    var_Create( p_obj, psz_name, VLC_VAR_TIME | VLC_VAR_DOINHERIT );
+    return var_GetTime( p_obj, psz_name );
+}
+
+/**
+ * Create a float variable with inherit and get its value.
+ *
+ * \param p_obj The object that holds the variable
+ * \param psz_name The name of the variable
+ */
+VLC_USED
+static inline float var_CreateGetFloat( vlc_object_t *p_obj, const char *psz_name )
+{
+    var_Create( p_obj, psz_name, VLC_VAR_FLOAT | VLC_VAR_DOINHERIT );
+    return var_GetFloat( p_obj, psz_name );
+}
+
+/**
+ * Create a string variable with inherit and get its value.
+ *
+ * \param p_obj The object that holds the variable
+ * \param psz_name The name of the variable
+ */
+VLC_USED VLC_MALLOC
+static inline char *var_CreateGetString( vlc_object_t *p_obj,
+                                           const char *psz_name )
+{
+    var_Create( p_obj, psz_name, VLC_VAR_STRING | VLC_VAR_DOINHERIT );
+    return var_GetString( p_obj, psz_name );
+}
+
+VLC_USED VLC_MALLOC
+static inline char *var_CreateGetNonEmptyString( vlc_object_t *p_obj,
+                                                   const char *psz_name )
+{
+    var_Create( p_obj, psz_name, VLC_VAR_STRING | VLC_VAR_DOINHERIT );
+    return var_GetNonEmptyString( p_obj, psz_name );
+}
+
+/**
+ * Create an address variable with inherit and get its value.
+ *
+ * \param p_obj The object that holds the variable
+ * \param psz_name The name of the variable
+ */
+VLC_USED
+static inline void *var_CreateGetAddress( vlc_object_t *p_obj,
+                                           const char *psz_name )
+{
+    var_Create( p_obj, psz_name, VLC_VAR_ADDRESS | VLC_VAR_DOINHERIT );
+    return var_GetAddress( p_obj, psz_name );
+}
+
+#define var_CreateGetInteger(a,b)   var_CreateGetInteger( VLC_OBJECT(a),b)
+#define var_CreateGetBool(a,b)   var_CreateGetBool( VLC_OBJECT(a),b)
+#define var_CreateGetTime(a,b)   var_CreateGetTime( VLC_OBJECT(a),b)
+#define var_CreateGetFloat(a,b)   var_CreateGetFloat( VLC_OBJECT(a),b)
+#define var_CreateGetString(a,b)   var_CreateGetString( VLC_OBJECT(a),b)
+#define var_CreateGetNonEmptyString(a,b)   var_CreateGetNonEmptyString( VLC_OBJECT(a),b)
+#define var_CreateGetAddress(a,b)  var_CreateGetAddress( VLC_OBJECT(a),b)
+
+/**
+ * Create a integer command variable with inherit and get its value.
+ *
+ * \param p_obj The object that holds the variable
+ * \param psz_name The name of the variable
+ */
+VLC_USED
+static inline int64_t var_CreateGetIntegerCommand( vlc_object_t *p_obj, const char *psz_name )
+{
+    var_Create( p_obj, psz_name, VLC_VAR_INTEGER | VLC_VAR_DOINHERIT
+                                   | VLC_VAR_ISCOMMAND );
+    return var_GetInteger( p_obj, psz_name );
+}
+
+/**
+ * Create a boolean command variable with inherit and get its value.
+ *
+ * \param p_obj The object that holds the variable
+ * \param psz_name The name of the variable
+ */
+VLC_USED
+static inline bool var_CreateGetBoolCommand( vlc_object_t *p_obj, const char *psz_name )
+{
+    var_Create( p_obj, psz_name, VLC_VAR_BOOL | VLC_VAR_DOINHERIT
+                                   | VLC_VAR_ISCOMMAND );
+    return var_GetBool( p_obj, psz_name );
+}
+
+/**
+ * Create a time command variable with inherit and get its value.
+ *
+ * \param p_obj The object that holds the variable
+ * \param psz_name The name of the variable
+ */
+VLC_USED
+static inline int64_t var_CreateGetTimeCommand( vlc_object_t *p_obj, const char *psz_name )
+{
+    var_Create( p_obj, psz_name, VLC_VAR_TIME | VLC_VAR_DOINHERIT
+                                   | VLC_VAR_ISCOMMAND );
+    return var_GetTime( p_obj, psz_name );
+}
+
+/**
+ * Create a float command variable with inherit and get its value.
+ *
+ * \param p_obj The object that holds the variable
+ * \param psz_name The name of the variable
+ */
+VLC_USED
+static inline float var_CreateGetFloatCommand( vlc_object_t *p_obj, const char *psz_name )
+{
+    var_Create( p_obj, psz_name, VLC_VAR_FLOAT | VLC_VAR_DOINHERIT
+                                   | VLC_VAR_ISCOMMAND );
+    return var_GetFloat( p_obj, psz_name );
+}
+
+/**
+ * Create a string command variable with inherit and get its value.
+ *
+ * \param p_obj The object that holds the variable
+ * \param psz_name The name of the variable
+ */
+VLC_USED VLC_MALLOC
+static inline char *var_CreateGetStringCommand( vlc_object_t *p_obj,
+                                           const char *psz_name )
+{
+    var_Create( p_obj, psz_name, VLC_VAR_STRING | VLC_VAR_DOINHERIT
+                                   | VLC_VAR_ISCOMMAND );
+    return var_GetString( p_obj, psz_name );
+}
+
+VLC_USED VLC_MALLOC
+static inline char *var_CreateGetNonEmptyStringCommand( vlc_object_t *p_obj,
+                                                   const char *psz_name )
+{
+    var_Create( p_obj, psz_name, VLC_VAR_STRING | VLC_VAR_DOINHERIT
+                                   | VLC_VAR_ISCOMMAND );
+    return var_GetNonEmptyString( p_obj, psz_name );
+}
+
+#define var_CreateGetIntegerCommand(a,b)   var_CreateGetIntegerCommand( VLC_OBJECT(a),b)
+#define var_CreateGetBoolCommand(a,b)   var_CreateGetBoolCommand( VLC_OBJECT(a),b)
+#define var_CreateGetTimeCommand(a,b)   var_CreateGetTimeCommand( VLC_OBJECT(a),b)
+#define var_CreateGetFloatCommand(a,b)   var_CreateGetFloatCommand( VLC_OBJECT(a),b)
+#define var_CreateGetStringCommand(a,b)   var_CreateGetStringCommand( VLC_OBJECT(a),b)
+#define var_CreateGetNonEmptyStringCommand(a,b)   var_CreateGetNonEmptyStringCommand( VLC_OBJECT(a),b)
+
+VLC_USED
+static inline int var_CountChoices( vlc_object_t *p_obj, const char *psz_name )
+{
+    vlc_value_t count;
+    if( var_Change( p_obj, psz_name, VLC_VAR_CHOICESCOUNT, &count, NULL ) )
+        return 0;
+    return count.i_int;
+}
+#define var_CountChoices(a,b) var_CountChoices( VLC_OBJECT(a),b)
+
+
+static inline bool var_ToggleBool( vlc_object_t *p_obj, const char *psz_name )
+{
+    vlc_value_t val;
+    var_GetAndSet( p_obj, psz_name, VLC_VAR_BOOL_TOGGLE, &val );
+    return val.b_bool;
+}
+#define var_ToggleBool(a,b) var_ToggleBool( VLC_OBJECT(a),b )
+
+
+VLC_USED
+static inline bool var_InheritBool( vlc_object_t *obj, const char *name )
+{
+    vlc_value_t val;
+
+    if( var_Inherit( obj, name, VLC_VAR_BOOL, &val ) )
+        val.b_bool = false;
+    return val.b_bool;
+}
+#define var_InheritBool(o, n) var_InheritBool(VLC_OBJECT(o), n)
+
+VLC_USED
+static inline int64_t var_InheritInteger( vlc_object_t *obj, const char *name )
+{
+    vlc_value_t val;
+
+    if( var_Inherit( obj, name, VLC_VAR_INTEGER, &val ) )
+        val.i_int = 0;
+    return val.i_int;
+}
+#define var_InheritInteger(o, n) var_InheritInteger(VLC_OBJECT(o), n)
+
+VLC_USED
+static inline float var_InheritFloat( vlc_object_t *obj, const char *name )
+{
+    vlc_value_t val;
+
+    if( var_Inherit( obj, name, VLC_VAR_FLOAT, &val ) )
+        val.f_float = 0.;
+    return val.f_float;
+}
+#define var_InheritFloat(o, n) var_InheritFloat(VLC_OBJECT(o), n)
+
+VLC_USED VLC_MALLOC
+static inline char *var_InheritString( vlc_object_t *obj, const char *name )
+{
+    vlc_value_t val;
+
+    if( var_Inherit( obj, name, VLC_VAR_STRING, &val ) )
+        val.psz_string = NULL;
+    else if( val.psz_string && !*val.psz_string )
+    {
+        free( val.psz_string );
+        val.psz_string = NULL;
+    }
+    return val.psz_string;
+}
+#define var_InheritString(o, n) var_InheritString(VLC_OBJECT(o), n)
+
+VLC_USED
+static inline mtime_t var_InheritTime( vlc_object_t *obj, const char *name )
+{
+    vlc_value_t val;
+
+    if( var_Inherit( obj, name, VLC_VAR_TIME, &val ) )
+        val.i_time = 0;
+    return val.i_time;
+}
+#define var_InheritTime(o, n) var_InheritTime(VLC_OBJECT(o), n)
+
+VLC_USED
+static inline void *var_InheritAddress( vlc_object_t *obj, const char *name )
+{
+    vlc_value_t val;
+
+    if( var_Inherit( obj, name, VLC_VAR_ADDRESS, &val ) )
+        val.p_address = NULL;
+    return val.p_address;
+}
+#define var_InheritAddress(o, n) var_InheritAddress(VLC_OBJECT(o), n)
+
+VLC_API int var_InheritURational( vlc_object_t *, unsigned *num, unsigned *den, const char *var );
+#define var_InheritURational(a,b,c,d) var_InheritURational(VLC_OBJECT(a), b, c, d)
+
+#define var_GetInteger(a,b)   var_GetInteger( VLC_OBJECT(a),b)
+#define var_GetBool(a,b)   var_GetBool( VLC_OBJECT(a),b)
+#define var_GetTime(a,b)   var_GetTime( VLC_OBJECT(a),b)
+#define var_GetFloat(a,b)   var_GetFloat( VLC_OBJECT(a),b)
+#define var_GetString(a,b)   var_GetString( VLC_OBJECT(a),b)
+#define var_GetNonEmptyString(a,b)   var_GetNonEmptyString( VLC_OBJECT(a),b)
+#define var_GetAddress(a,b)  var_GetAddress( VLC_OBJECT(a),b)
+
+VLC_API int var_LocationParse(vlc_object_t *, const char *mrl, const char *prefix);
+#define var_LocationParse(o, m, p) var_LocationParse(VLC_OBJECT(o), m, p)
+
+/**
+ * @}
+ */
+#endif /*  _VLC_VARIABLES_H */

=== added file 'DivCity/DivCity/vlc/plugins/vlc_video_splitter.h'
--- DivCity/DivCity/vlc/plugins/vlc_video_splitter.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_video_splitter.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,158 @@
+/*****************************************************************************
+ * vlc_video_splitter.h: "video splitter" related structures and functions
+ *****************************************************************************
+ * Copyright (C) 2009 Laurent Aimar
+ * $Id: eb2bf00f85a3ee2df1c35a90f12da4099a95a463 $
+ *
+ * Authors: Laurent Aimar <fenrir _AT_ videolan _DOT_ org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_VIDEO_SPLITTER_H
+#define VLC_VIDEO_SPLITTER_H 1
+
+#include <vlc_es.h>
+#include <vlc_picture.h>
+#include <vlc_mouse.h>
+
+/**
+ * \file
+ * This file defines the structure and types used by video splitter filters.
+ */
+
+typedef struct video_splitter_t video_splitter_t;
+typedef struct video_splitter_sys_t video_splitter_sys_t;
+typedef struct video_splitter_owner_t video_splitter_owner_t;
+
+/** Structure describing a video splitter output properties
+ */
+typedef struct
+{
+    /* Video format of the output */
+    video_format_t fmt;
+
+    /* Window hints */
+    struct
+    {
+        /* Relative position.
+         * (0,0) is equal to the default position.
+         */
+        int i_x;
+        int i_y;
+
+        /* Alignment inside the window
+         */
+        int i_align;
+    } window;
+
+    /* Video output module
+     * Use NULL for default
+     */
+    char *psz_module;
+
+} video_splitter_output_t;
+
+/** Structure describing a video splitter
+ */
+struct video_splitter_t
+{
+    VLC_COMMON_MEMBERS
+
+    /* Module properties */
+    module_t        *p_module;
+
+    /* configuration */
+    config_chain_t  *p_cfg;
+
+    /* Input format
+     * It is filled by the creator and cannot be modified.
+     */
+    video_format_t  fmt;
+
+    /* Output formats
+     *
+     * It can only be set in the open() function and must remain
+     * constant.
+     * The module is responsible for the allocation and deallocation.
+     */
+    int                     i_output;
+    video_splitter_output_t *p_output;
+
+    int             (*pf_filter)( video_splitter_t *, picture_t *pp_dst[],
+                                  picture_t *p_src );
+    int             (*pf_mouse) ( video_splitter_t *, vlc_mouse_t *,
+                                  int i_index,
+                                  const vlc_mouse_t *p_old, const vlc_mouse_t *p_new );
+
+    video_splitter_sys_t *p_sys;
+
+    /* Buffer allocation */
+    int  (*pf_picture_new) ( video_splitter_t *, picture_t *pp_picture[] );
+    void (*pf_picture_del) ( video_splitter_t *, picture_t *pp_picture[] );
+    video_splitter_owner_t *p_owner;
+};
+
+/**
+ * It will create an array of pictures suitable as output.
+ *
+ * You must either returned them through pf_filter or by calling
+ * video_splitter_DeletePicture.
+ *
+ * If VLC_SUCCESS is not returned, pp_picture values are undefined.
+ */
+static inline int video_splitter_NewPicture( video_splitter_t *p_splitter,
+                                             picture_t *pp_picture[] )
+{
+    int i_ret = p_splitter->pf_picture_new( p_splitter, pp_picture );
+    if( i_ret )
+        msg_Warn( p_splitter, "can't get output pictures" );
+    return i_ret;
+}
+
+/**
+ * It will release an array of pictures created by video_splitter_NewPicture.
+ * Provided for convenience.
+ */
+static inline void video_splitter_DeletePicture( video_splitter_t *p_splitter,
+                                                 picture_t *pp_picture[] )
+{
+    p_splitter->pf_picture_del( p_splitter, pp_picture );
+}
+
+/* */
+VLC_API video_splitter_t * video_splitter_New( vlc_object_t *, const char *psz_name, const video_format_t * );
+VLC_API void video_splitter_Delete( video_splitter_t * );
+
+static inline int video_splitter_Filter( video_splitter_t *p_splitter,
+                                         picture_t *pp_dst[], picture_t *p_src )
+{
+    return p_splitter->pf_filter( p_splitter, pp_dst, p_src );
+}
+static inline int video_splitter_Mouse( video_splitter_t *p_splitter,
+                                        vlc_mouse_t *p_mouse,
+                                        int i_index,
+                                        const vlc_mouse_t *p_old, const vlc_mouse_t *p_new )
+{
+    if( !p_splitter->pf_mouse )
+    {
+        *p_mouse = *p_new;
+        return VLC_SUCCESS;
+    }
+    return p_splitter->pf_mouse( p_splitter, p_mouse, i_index, p_old, p_new );
+}
+
+#endif /* VLC_VIDEO_SPLITTER_H */
+

=== added file 'DivCity/DivCity/vlc/plugins/vlc_vlm.h'
--- DivCity/DivCity/vlc/plugins/vlc_vlm.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_vlm.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,369 @@
+/*****************************************************************************
+ * vlc_vlm.h: VLM core structures
+ *****************************************************************************
+ * Copyright (C) 2000, 2001 VLC authors and VideoLAN
+ * $Id: 12a0eda4979b1e1bc507794d89e5794e6911e97a $
+ *
+ * Authors: Simon Latapie <garf@videolan.org>
+ *          Laurent Aimar <fenrir@videolan.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_VLM_H
+#define VLC_VLM_H 1
+
+/**
+ * \file
+ * This file defines VLM core functions and structures in vlc
+ */
+
+#include <vlc_input.h>
+
+/**
+ * \defgroup server VLM
+ * VLM is the server core in vlc that allows streaming of multiple media streams
+ * at the same time. It provides broadcast, schedule and video on demand features
+ * for streaming using several streaming and network protocols.
+ * @{
+ */
+
+/** VLM media */
+typedef struct
+{
+    int64_t     id;     /*< numeric id for vlm_media_t item */
+    bool  b_enabled;    /*< vlm_media_t is enabled */
+
+    char *psz_name;     /*< descriptive name of vlm_media_t item */
+
+    int  i_input;       /*< number of input options */
+    char **ppsz_input;  /*< array of input options */
+
+    int  i_option;      /*< number of output options */
+    char **ppsz_option; /*< array of output options */
+
+    char *psz_output;   /*< */
+
+    bool b_vod;         /*< vlm_media_t is of type VOD */
+    struct
+    {
+        bool b_loop;    /*< this vlc_media_t broadcast item should loop */
+    } broadcast;        /*< Broadcast specific information */
+    struct
+    {
+        char *psz_mux;  /*< name of muxer to use */
+    } vod;              /*< VOD specific information */
+
+} vlm_media_t;
+
+/** VLM media instance */
+typedef struct
+{
+    char *psz_name;         /*< vlm media instance descriptive name */
+
+    int64_t     i_time;     /*< vlm media instance vlm media current time */
+    int64_t     i_length;   /*< vlm media instance vlm media item length */
+    double      d_position; /*< vlm media instance position in stream */
+    bool        b_paused;   /*< vlm media instance is paused */
+    int         i_rate;     // normal is INPUT_RATE_DEFAULT
+} vlm_media_instance_t;
+
+#if 0
+typedef struct
+{
+
+} vlm_schedule_t
+#endif
+
+/** VLM events
+ * You can catch vlm event by adding a callback on the variable "intf-event"
+ * of the VLM object.
+ * This variable is an address that will hold a vlm_event_t* value.
+ */
+enum vlm_event_type_e
+{
+    /* */
+    VLM_EVENT_MEDIA_ADDED   = 0x100,
+    VLM_EVENT_MEDIA_REMOVED,
+    VLM_EVENT_MEDIA_CHANGED,
+
+    /* */
+    VLM_EVENT_MEDIA_INSTANCE_STARTED    = 0x200,
+    VLM_EVENT_MEDIA_INSTANCE_STOPPED,
+    VLM_EVENT_MEDIA_INSTANCE_STATE,
+};
+
+typedef struct
+{
+    int            i_type;            /* a vlm_event_type_e value */
+    int64_t        id;                /* Media ID */
+    const char    *psz_name;          /* Media name */
+    const char    *psz_instance_name; /* Instance name or NULL */
+    input_state_e  input_state;       /* Input instance event type */
+} vlm_event_t;
+
+/** VLM control query */
+enum vlm_query_e
+{
+    /* --- Media control */
+    /* Get all medias */
+    VLM_GET_MEDIAS,                     /* arg1=vlm_media_t ***, int *pi_media      */
+    /* Delete all medias */
+    VLM_CLEAR_MEDIAS,                   /* no arg */
+
+    /* Add a new media */
+    VLM_ADD_MEDIA,                      /* arg1=vlm_media_t* arg2=int64_t *p_id         res=can fail */
+    /* Delete an existing media */
+    VLM_DEL_MEDIA,                      /* arg1=int64_t id */
+    /* Change properties of an existing media (all fields but id and b_vod) */
+    VLM_CHANGE_MEDIA,                   /* arg1=vlm_media_t*                            res=can fail */
+    /* Get 1 media by it's ID */
+    VLM_GET_MEDIA,                      /* arg1=int64_t id arg2=vlm_media_t **  */
+    /* Get media ID from its name */
+    VLM_GET_MEDIA_ID,                   /* arg1=const char *psz_name arg2=int64_t*  */
+
+    /* Media instance control XXX VOD control are for internal use only */
+    /* Get all media instances */
+    VLM_GET_MEDIA_INSTANCES,            /* arg1=int64_t id arg2=vlm_media_instance_t *** arg3=int *pi_instance */
+    /* Delete all media instances */
+    VLM_CLEAR_MEDIA_INSTANCES,          /* arg1=int64_t id */
+    /* Control broadcast instance */
+    VLM_START_MEDIA_BROADCAST_INSTANCE, /* arg1=int64_t id, arg2=const char *psz_instance_name, int i_input_index  res=can fail */
+    /* Control VOD instance */
+    VLM_START_MEDIA_VOD_INSTANCE,       /* arg1=int64_t id, arg2=const char *psz_instance_name, int i_input_index char *psz_vod_output res=can fail */
+    /* Stop an instance */
+    VLM_STOP_MEDIA_INSTANCE,            /* arg1=int64_t id, arg2=const char *psz_instance_name      res=can fail */
+    /* Pause an instance */
+    VLM_PAUSE_MEDIA_INSTANCE,           /* arg1=int64_t id, arg2=const char *psz_instance_name      res=can fail */
+    /* Get instance position time (in microsecond) */
+    VLM_GET_MEDIA_INSTANCE_TIME,        /* arg1=int64_t id, arg2=const char *psz_instance_name arg3=int64_t *   */
+    /* Set instance position time (in microsecond) */
+    VLM_SET_MEDIA_INSTANCE_TIME,        /* arg1=int64_t id, arg2=const char *psz_instance_name arg3=int64_t     */
+    /* Get instance position ([0.0 .. 1.0]) */
+    VLM_GET_MEDIA_INSTANCE_POSITION,    /* arg1=int64_t id, arg2=const char *psz_instance_name arg3=double *   */
+    /* Set instance position ([0.0 .. 1.0]) */
+    VLM_SET_MEDIA_INSTANCE_POSITION,    /* arg1=int64_t id, arg2=const char *psz_instance_name arg3=double     */
+
+    /* Schedule control */
+    VLM_CLEAR_SCHEDULES,                /* no arg */
+    /* TODO: missing schedule control */
+
+    /* */
+};
+
+
+/* VLM specific - structures and functions */
+
+/* ok, here is the structure of a vlm_message:
+   The parent node is ( name_of_the_command , NULL ), or
+   ( name_of_the_command , message_error ) on error.
+   If a node has children, it should not have a value (=NULL).*/
+struct vlm_message_t
+{
+    char *psz_name;         /*< message name */
+    char *psz_value;        /*< message value */
+
+    int           i_child;  /*< number of child messages */
+    vlm_message_t **child;  /*< array of vlm_message_t */
+};
+
+
+#ifdef __cpluplus
+extern "C" {
+#endif
+
+VLC_API vlm_t * vlm_New( vlc_object_t * );
+#define vlm_New( a ) vlm_New( VLC_OBJECT(a) )
+VLC_API void vlm_Delete( vlm_t * );
+VLC_API int vlm_ExecuteCommand( vlm_t *, const char *, vlm_message_t ** );
+VLC_API int vlm_Control( vlm_t *p_vlm, int i_query, ... );
+
+VLC_API vlm_message_t * vlm_MessageSimpleNew( const char * );
+VLC_API vlm_message_t * vlm_MessageNew( const char *, const char *, ... ) VLC_FORMAT( 2, 3 );
+VLC_API vlm_message_t * vlm_MessageAdd( vlm_message_t *, vlm_message_t * );
+VLC_API void vlm_MessageDelete( vlm_message_t * );
+
+/* media helpers */
+
+/**
+ * Initialize a vlm_media_t instance
+ * \param p_media vlm_media_t instance to initialize
+ */
+static inline void vlm_media_Init( vlm_media_t *p_media )
+{
+    memset( p_media, 0, sizeof(vlm_media_t) );
+    p_media->id = 0;    // invalid id
+    p_media->psz_name = NULL;
+    TAB_INIT( p_media->i_input, p_media->ppsz_input );
+    TAB_INIT( p_media->i_option, p_media->ppsz_option );
+    p_media->psz_output = NULL;
+    p_media->b_vod = false;
+
+    p_media->vod.psz_mux = NULL;
+    p_media->broadcast.b_loop = false;
+}
+
+/**
+ * Copy a vlm_media_t instance into another vlm_media_t instance
+ * \param p_dst vlm_media_t instance to copy to
+ * \param p_src vlm_media_t instance to copy from
+ */
+static inline void
+#ifndef __cplusplus
+vlm_media_Copy( vlm_media_t *restrict p_dst, const vlm_media_t *restrict p_src )
+#else
+vlm_media_Copy( vlm_media_t *p_dst, const vlm_media_t *p_src )
+#endif
+{
+    int i;
+
+    memset( p_dst, 0, sizeof(vlm_media_t) );
+    p_dst->id = p_src->id;
+    p_dst->b_enabled = p_src->b_enabled;
+    if( p_src->psz_name )
+        p_dst->psz_name = strdup( p_src->psz_name );
+
+    for( i = 0; i < p_src->i_input; i++ )
+        TAB_APPEND_CAST( (char**), p_dst->i_input, p_dst->ppsz_input, strdup(p_src->ppsz_input[i]) );
+    for( i = 0; i < p_src->i_option; i++ )
+        TAB_APPEND_CAST( (char**), p_dst->i_option, p_dst->ppsz_option, strdup(p_src->ppsz_option[i]) );
+
+    if( p_src->psz_output )
+        p_dst->psz_output = strdup( p_src->psz_output );
+
+    p_dst->b_vod = p_src->b_vod;
+    if( p_src->b_vod )
+    {
+        if( p_src->vod.psz_mux )
+            p_dst->vod.psz_mux = strdup( p_src->vod.psz_mux );
+    }
+    else
+    {
+        p_dst->broadcast.b_loop = p_src->broadcast.b_loop;
+    }
+}
+
+/**
+ * Cleanup and release memory associated with this vlm_media_t instance.
+ * You still need to release p_media itself with vlm_media_Delete().
+ * \param p_media vlm_media_t to cleanup
+ */
+static inline void vlm_media_Clean( vlm_media_t *p_media )
+{
+    int i;
+    free( p_media->psz_name );
+
+    for( i = 0; i < p_media->i_input; i++ )
+        free( p_media->ppsz_input[i]);
+    TAB_CLEAN(p_media->i_input, p_media->ppsz_input );
+
+    for( i = 0; i < p_media->i_option; i++ )
+        free( p_media->ppsz_option[i]);
+    TAB_CLEAN(p_media->i_option, p_media->ppsz_option );
+
+    free( p_media->psz_output );
+    if( p_media->b_vod )
+        free( p_media->vod.psz_mux );
+}
+
+/**
+ * Allocate a new vlm_media_t instance
+ * \return vlm_media_t instance
+ */
+static inline vlm_media_t *vlm_media_New(void)
+{
+    vlm_media_t *p_media = (vlm_media_t *)malloc( sizeof(vlm_media_t) );
+    if( p_media )
+        vlm_media_Init( p_media );
+    return p_media;
+}
+
+/**
+ * Delete a vlm_media_t instance
+ * \param p_media vlm_media_t instance to delete
+ */
+static inline void vlm_media_Delete( vlm_media_t *p_media )
+{
+    vlm_media_Clean( p_media );
+    free( p_media );
+}
+
+/**
+ * Copy a vlm_media_t instance
+ * \param p_src vlm_media_t instance to copy
+ * \return vlm_media_t duplicate of p_src
+ */
+static inline vlm_media_t *vlm_media_Duplicate( vlm_media_t *p_src )
+{
+    vlm_media_t *p_dst = vlm_media_New();
+    if( p_dst )
+        vlm_media_Copy( p_dst, p_src );
+    return p_dst;
+}
+
+/* media instance helpers */
+/**
+ * Initialize vlm_media_instance_t
+ * \param p_instance vlm_media_instance_t to initialize
+ */
+static inline void vlm_media_instance_Init( vlm_media_instance_t *p_instance )
+{
+    memset( p_instance, 0, sizeof(vlm_media_instance_t) );
+    p_instance->psz_name = NULL;
+    p_instance->i_time = 0;
+    p_instance->i_length = 0;
+    p_instance->d_position = 0.0;
+    p_instance->b_paused = false;
+    p_instance->i_rate = INPUT_RATE_DEFAULT;
+}
+
+/**
+ * Cleanup vlm_media_instance_t
+ * \param p_instance vlm_media_instance_t to cleanup
+ */
+static inline void vlm_media_instance_Clean( vlm_media_instance_t *p_instance )
+{
+    free( p_instance->psz_name );
+}
+
+/**
+ * Allocate a new vlm_media_instance_t
+ * \return a new vlm_media_instance_t
+ */
+static inline vlm_media_instance_t *vlm_media_instance_New(void)
+{
+    vlm_media_instance_t *p_instance = (vlm_media_instance_t *) malloc( sizeof(vlm_media_instance_t) );
+    if( p_instance )
+        vlm_media_instance_Init( p_instance );
+    return p_instance;
+}
+
+/**
+ * Delete a vlm_media_instance_t
+ * \param p_instance vlm_media_instance_t to delete
+ */
+static inline void vlm_media_instance_Delete( vlm_media_instance_t *p_instance )
+{
+    vlm_media_instance_Clean( p_instance );
+    free( p_instance );
+}
+
+#ifdef __cpluplus
+}
+#endif
+
+/**@}*/
+
+#endif

=== added file 'DivCity/DivCity/vlc/plugins/vlc_vout.h'
--- DivCity/DivCity/vlc/plugins/vlc_vout.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_vout.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,164 @@
+/*****************************************************************************
+ * vlc_video.h: common video definitions
+ *****************************************************************************
+ * Copyright (C) 1999 - 2008 VLC authors and VideoLAN
+ * $Id: d3995508b243fe9aec8b6983b928bf12a0e2f8c3 $
+ *
+ * Authors: Vincent Seguin <seguin@via.ecp.fr>
+ *          Samuel Hocevar <sam@via.ecp.fr>
+ *          Olivier Aubert <oaubert 47 videolan d07 org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_VOUT_H_
+#define VLC_VOUT_H_ 1
+
+/**
+ * \file
+ * This file defines common video output structures and functions in vlc
+ */
+
+#include <vlc_picture.h>
+#include <vlc_filter.h>
+#include <vlc_subpicture.h>
+
+/*****************************************************************************
+ * Prototypes
+ *****************************************************************************/
+
+/**
+ * \defgroup video_output Video Output
+ * This module describes the programming interface for video output threads.
+ * It includes functions allowing to open a new thread, send pictures to a
+ * thread, and destroy a previously opened video output thread.
+ * @{
+ */
+
+/**
+ * Vout configuration
+ */
+typedef struct {
+    vout_thread_t        *vout;
+    vlc_object_t         *input;
+    bool                 change_fmt;
+    const video_format_t *fmt;
+    unsigned             dpb_size;
+} vout_configuration_t;
+
+/**
+ * Video output thread private structure
+ */
+typedef struct vout_thread_sys_t vout_thread_sys_t;
+
+/**
+ * Video output thread descriptor
+ *
+ * Any independent video output device, such as an X11 window or a GGI device,
+ * is represented by a video output thread, and described using the following
+ * structure.
+ */
+struct vout_thread_t {
+    VLC_COMMON_MEMBERS
+
+    /* Private vout_thread data */
+    vout_thread_sys_t *p;
+};
+
+/* Alignment flags */
+#define VOUT_ALIGN_LEFT         0x0001
+#define VOUT_ALIGN_RIGHT        0x0002
+#define VOUT_ALIGN_HMASK        0x0003
+#define VOUT_ALIGN_TOP          0x0004
+#define VOUT_ALIGN_BOTTOM       0x0008
+#define VOUT_ALIGN_VMASK        0x000C
+
+/*****************************************************************************
+ * Prototypes
+ *****************************************************************************/
+
+/**
+ * Returns a suitable vout or release the given one.
+ *
+ * If cfg->fmt is non NULL and valid, a vout will be returned, reusing cfg->vout
+ * is possible, otherwise it returns NULL.
+ * If cfg->vout is not used, it will be closed and released.
+ *
+ * You can release the returned value either by vout_Request or vout_Close()
+ * followed by a vlc_object_release() or shorter vout_CloseAndRelease()
+ *
+ * \param object a vlc object
+ * \param cfg the video configuration requested.
+ * \return a vout
+ */
+VLC_API vout_thread_t * vout_Request( vlc_object_t *object, const vout_configuration_t *cfg );
+#define vout_Request(a,b) vout_Request(VLC_OBJECT(a),b)
+
+/**
+ * This function will close a vout created by vout_Request.
+ * The associated vout module is closed.
+ * Note: It is not released yet, you'll have to call vlc_object_release()
+ * or use the convenient vout_CloseAndRelease().
+ *
+ * \param p_vout the vout to close
+ */
+VLC_API void vout_Close( vout_thread_t *p_vout );
+
+/**
+ * This function will close a vout created by vout_Create
+ * and then release it.
+ *
+ * \param p_vout the vout to close and release
+ */
+static inline void vout_CloseAndRelease( vout_thread_t *p_vout )
+{
+    vout_Close( p_vout );
+    vlc_object_release( p_vout );
+}
+
+/**
+ * This function will handle a snapshot request.
+ *
+ * pp_image, pp_picture and p_fmt can be NULL otherwise they will be
+ * set with returned value in case of success.
+ *
+ * pp_image will hold an encoded picture in psz_format format.
+ *
+ * i_timeout specifies the time the function will wait for a snapshot to be
+ * available.
+ *
+ */
+VLC_API int vout_GetSnapshot( vout_thread_t *p_vout,
+                              block_t **pp_image, picture_t **pp_picture,
+                              video_format_t *p_fmt,
+                              const char *psz_format, mtime_t i_timeout );
+
+/* */
+VLC_API picture_t * vout_GetPicture( vout_thread_t * );
+VLC_API void vout_PutPicture( vout_thread_t *, picture_t * );
+
+VLC_API void vout_HoldPicture( vout_thread_t *, picture_t * );
+VLC_API void vout_ReleasePicture( vout_thread_t *, picture_t * );
+
+/* */
+VLC_API void vout_PutSubpicture( vout_thread_t *, subpicture_t * );
+VLC_API int vout_RegisterSubpictureChannel( vout_thread_t * );
+VLC_API void vout_FlushSubpictureChannel( vout_thread_t *, int );
+
+VLC_API void vout_EnableFilter( vout_thread_t *, const char *,bool , bool  );
+
+/**@}*/
+
+#endif /* _VLC_VIDEO_H */

=== added file 'DivCity/DivCity/vlc/plugins/vlc_vout_display.h'
--- DivCity/DivCity/vlc/plugins/vlc_vout_display.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_vout_display.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,440 @@
+/*****************************************************************************
+ * vlc_vout_display.h: vout_display_t definitions
+ *****************************************************************************
+ * Copyright (C) 2009 Laurent Aimar
+ * $Id: d99cf7eea9c1079754a3a47ea1df8ecd8e8d6163 $
+ *
+ * Authors: Laurent Aimar <fenrir _AT_ videolan _DOT_ org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_VOUT_DISPLAY_H
+#define VLC_VOUT_DISPLAY_H 1
+
+/**
+ * \file
+ * This file defines vout display structures and functions in vlc
+ */
+
+#include <vlc_es.h>
+#include <vlc_picture.h>
+#include <vlc_picture_pool.h>
+#include <vlc_subpicture.h>
+#include <vlc_keys.h>
+#include <vlc_mouse.h>
+#include <vlc_vout_window.h>
+
+/* XXX
+ * Do NOT use video_format_t::i_aspect but i_sar_num/den everywhere. i_aspect
+ * will be removed as soon as possible.
+ *
+ */
+typedef struct vout_display_t vout_display_t;
+typedef struct vout_display_sys_t vout_display_sys_t;
+typedef struct vout_display_owner_t vout_display_owner_t;
+typedef struct vout_display_owner_sys_t vout_display_owner_sys_t;
+
+/**
+ * Possible alignments for vout_display.
+ */
+typedef enum
+{
+    VOUT_DISPLAY_ALIGN_CENTER,
+    /* */
+    VOUT_DISPLAY_ALIGN_LEFT,
+    VOUT_DISPLAY_ALIGN_RIGHT,
+    /* */
+    VOUT_DISPLAY_ALIGN_TOP,
+    VOUT_DISPLAY_ALIGN_BOTTOM,
+} vout_display_align_t;
+
+/**
+ * Window management state.
+ */
+enum {
+    VOUT_WINDOW_STATE_NORMAL=0,
+    VOUT_WINDOW_STATE_ABOVE=1,
+    VOUT_WINDOW_STATE_BELOW=2,
+    VOUT_WINDOW_STACK_MASK=3,
+};
+
+/**
+ * Initial/Current configuration for a vout_display_t
+ */
+typedef struct {
+    bool is_fullscreen;  /* Is the display fullscreen */
+
+    /* Display properties */
+    struct {
+        /* Window title (may be NULL) */
+        const char *title;
+
+        /* Display size */
+        unsigned  width;
+        unsigned  height;
+
+        /* Display SAR */
+        struct {
+            unsigned num;
+            unsigned den;
+        } sar;
+    } display;
+
+    /* Alignment of the picture inside the display */
+    struct {
+        int horizontal;
+        int vertical;
+    } align;
+
+    /* Do we fill up the display with the video */
+    bool is_display_filled;
+
+    /* Zoom to use
+     * It will be applied to the whole display if b_display_filled is set, otherwise
+     * only on the video source */
+    struct {
+        int num;
+        int den;
+    } zoom;
+
+} vout_display_cfg_t;
+
+/**
+ * Information from a vout_display_t to configure
+ * the core behaviour.
+ *
+ * By default they are all false or NULL.
+ *
+ */
+typedef struct {
+    bool is_slow;                           /* The picture memory has slow read/write */
+    bool has_double_click;                  /* Is double-click generated */
+    bool has_hide_mouse;                    /* Is mouse automatically hidden */
+    bool has_pictures_invalid;              /* Will VOUT_DISPLAY_EVENT_PICTURES_INVALID be used */
+    bool has_event_thread;                  /* Will events (key at least) be emitted using an independent thread */
+    const vlc_fourcc_t *subpicture_chromas; /* List of supported chromas for subpicture rendering. */
+} vout_display_info_t;
+
+/**
+ * Control query for vout_display_t
+ */
+enum {
+    /* Hide the mouse. It will be sent when
+     * vout_display_t::info.b_hide_mouse is false */
+    VOUT_DISPLAY_HIDE_MOUSE,
+
+    /* Ask to reset the internal buffers after a VOUT_DISPLAY_EVENT_PICTURES_INVALID
+     * request.
+     */
+    VOUT_DISPLAY_RESET_PICTURES,
+
+    /* Ask the module to acknowledge/refuse the fullscreen state change after
+     * being requested (externally or by VOUT_DISPLAY_EVENT_FULLSCREEN */
+    VOUT_DISPLAY_CHANGE_FULLSCREEN,     /* const vout_display_cfg_t *p_cfg */
+
+    /* Ask the module to acknowledge/refuse the window management state change
+     * after being requested externally or by VOUT_DISPLAY_WINDOW_STATE */
+    VOUT_DISPLAY_CHANGE_WINDOW_STATE,         /* unsigned state */
+
+    /* Ask the module to acknowledge/refuse the display size change requested
+     * (externally or by VOUT_DISPLAY_EVENT_DISPLAY_SIZE) */
+    VOUT_DISPLAY_CHANGE_DISPLAY_SIZE,   /* const vout_display_cfg_t *p_cfg, int is_forced */
+
+    /* Ask the module to acknowledge/refuse fill display state change after
+     * being requested externally */
+    VOUT_DISPLAY_CHANGE_DISPLAY_FILLED, /* const vout_display_cfg_t *p_cfg */
+
+    /* Ask the module to acknowledge/refuse zoom change after being requested
+     * externally */
+    VOUT_DISPLAY_CHANGE_ZOOM, /* const vout_display_cfg_t *p_cfg */
+
+    /* Ask the module to acknowledge/refuse source aspect ratio after being
+     * requested externally */
+    VOUT_DISPLAY_CHANGE_SOURCE_ASPECT, /* const video_format_t *p_source */
+
+    /* Ask the module to acknowledge/refuse source crop change after being
+     * requested externally.
+     * The cropping requested is stored by video_format_t::i_x/y_offset and
+     * video_format_t::i_visible_width/height */
+    VOUT_DISPLAY_CHANGE_SOURCE_CROP,   /* const video_format_t *p_source */
+
+    /* Ask an opengl interface if available. */
+    VOUT_DISPLAY_GET_OPENGL,           /* vlc_gl_t ** */
+};
+
+/**
+ * Event from vout_display_t
+ *
+ * Events modifiying the state may be sent multiple times.
+ * Only the transition will be retained and acted upon.
+ */
+enum {
+    /* TODO:
+     * ZOOM ? DISPLAY_FILLED ? ON_TOP ?
+     */
+    /* */
+    VOUT_DISPLAY_EVENT_PICTURES_INVALID,    /* The buffer are now invalid and need to be changed */
+
+    VOUT_DISPLAY_EVENT_FULLSCREEN,
+    VOUT_DISPLAY_EVENT_WINDOW_STATE,
+
+    VOUT_DISPLAY_EVENT_DISPLAY_SIZE,        /* The display size need to change : int i_width, int i_height, bool is_fullscreen */
+
+    /* */
+    VOUT_DISPLAY_EVENT_CLOSE,
+    VOUT_DISPLAY_EVENT_KEY,
+
+    /* Full mouse state.
+     * You can use it OR use the other mouse events. The core will do
+     * the conversion.
+     */
+    VOUT_DISPLAY_EVENT_MOUSE_STATE,
+
+    /* Mouse event */
+    VOUT_DISPLAY_EVENT_MOUSE_MOVED,
+    VOUT_DISPLAY_EVENT_MOUSE_PRESSED,
+    VOUT_DISPLAY_EVENT_MOUSE_RELEASED,
+    VOUT_DISPLAY_EVENT_MOUSE_DOUBLE_CLICK,
+};
+
+/**
+ * Vout owner structures
+ */
+struct vout_display_owner_t {
+    /* Private place holder for the vout_display_t creator
+     */
+    vout_display_owner_sys_t *sys;
+
+    /* Event coming from the module
+     *
+     * This function is set prior to the module instantiation and must not
+     * be overwritten nor used directly (use the vout_display_SendEvent*
+     * wrapper.
+     *
+     * You can send it at any time i.e. from any vout_display_t functions or
+     * from another thread.
+     * Be careful, it does not ensure correct serialization if it is used
+     * from multiple threads.
+     */
+    void            (*event)(vout_display_t *, int, va_list);
+
+    /* Window management
+     *
+     * These functions are set prior to the module instantiation and must not
+     * be overwritten nor used directly (use the vout_display_*Window
+     * wrapper */
+    vout_window_t *(*window_new)(vout_display_t *, const vout_window_cfg_t *);
+    void           (*window_del)(vout_display_t *, vout_window_t *);
+};
+
+struct vout_display_t {
+    VLC_COMMON_MEMBERS
+
+    /* Module */
+    module_t *module;
+
+    /* Initial and current configuration.
+     * You cannot modify it directly, you must use the appropriate events.
+     *
+     * It reflects the current values, i.e. after the event has been accepted
+     * and applied/configured if needed.
+     */
+    const vout_display_cfg_t *cfg;
+
+    /* video source format.
+     *
+     * Cropping is not requested while in the open function.
+     * You cannot change it.
+     */
+    video_format_t source;
+
+    /* picture_t format.
+     *
+     * You can only change it inside the module open function to
+     * match what you want, and when a VOUT_DISPLAY_RESET_PICTURES control
+     * request is made and succeeds.
+     *
+     * By default, it is equal to ::source except for the aspect ratio
+     * which is undefined(0) and is ignored.
+     */
+    video_format_t fmt;
+
+    /* Information
+     *
+     * You can only set them in the open function.
+     */
+    vout_display_info_t info;
+
+    /* Return a pointer over the current picture_pool_t* (mandatory).
+     *
+     * For performance reasons, it is best to provide at least count
+     * pictures but it is not mandatory.
+     * You can return NULL when you cannot/do not want to allocate
+     * pictures.
+     * The vout display module keeps the ownership of the pool and can
+     * destroy it only when closing or on invalid pictures control.
+     */
+    picture_pool_t *(*pool)(vout_display_t *, unsigned count);
+
+    /* Prepare a picture and an optional subpicture for display (optional).
+     *
+     * It is called before the next pf_display call to provide as much
+     * time as possible to prepare the given picture and the subpicture
+     * for display.
+     * You are guaranted that pf_display will always be called and using
+     * the exact same picture_t and subpicture_t.
+     * You cannot change the pixel content of the picture_t or of the
+     * subpicture_t.
+     */
+    void       (*prepare)(vout_display_t *, picture_t *, subpicture_t *);
+
+    /* Display a picture and an optional subpicture (mandatory).
+     *
+     * The picture and the optional subpicture must be displayed as soon as
+     * possible.
+     * You cannot change the pixel content of the picture_t or of the
+     * subpicture_t.
+     *
+     * This function gives away the ownership of the picture and of the
+     * subpicture, so you must release them as soon as possible.
+     */
+    void       (*display)(vout_display_t *, picture_t *, subpicture_t *);
+
+    /* Control on the module (mandatory) */
+    int        (*control)(vout_display_t *, int, va_list);
+
+    /* Manage pending event (optional) */
+    void       (*manage)(vout_display_t *);
+
+    /* Private place holder for the vout_display_t module (optional)
+     *
+     * A module is free to use it as it wishes.
+     */
+    vout_display_sys_t *sys;
+
+    /* Reserved for the vout_display_t owner.
+     *
+     * It must not be overwritten nor used directly by a module.
+     */
+    vout_display_owner_t owner;
+};
+
+static inline void vout_display_SendEvent(vout_display_t *vd, int query, ...)
+{
+    va_list args;
+    va_start(args, query);
+    vd->owner.event(vd, query, args);
+    va_end(args);
+}
+
+static inline void vout_display_SendEventDisplaySize(vout_display_t *vd, int width, int height, bool is_fullscreen)
+{
+    vout_display_SendEvent(vd, VOUT_DISPLAY_EVENT_DISPLAY_SIZE, width, height, is_fullscreen);
+}
+static inline void vout_display_SendEventPicturesInvalid(vout_display_t *vd)
+{
+    vout_display_SendEvent(vd, VOUT_DISPLAY_EVENT_PICTURES_INVALID);
+}
+static inline void vout_display_SendEventClose(vout_display_t *vd)
+{
+    vout_display_SendEvent(vd, VOUT_DISPLAY_EVENT_CLOSE);
+}
+static inline void vout_display_SendEventKey(vout_display_t *vd, int key)
+{
+    vout_display_SendEvent(vd, VOUT_DISPLAY_EVENT_KEY, key);
+}
+static inline void vout_display_SendEventFullscreen(vout_display_t *vd, bool is_fullscreen)
+{
+    vout_display_SendEvent(vd, VOUT_DISPLAY_EVENT_FULLSCREEN, is_fullscreen);
+}
+static inline void vout_display_SendWindowState(vout_display_t *vd, unsigned state)
+{
+    vout_display_SendEvent(vd, VOUT_DISPLAY_EVENT_WINDOW_STATE, state);
+}
+/* The mouse position (State and Moved event) must be expressed against vout_display_t::source unit */
+static inline void vout_display_SendEventMouseState(vout_display_t *vd, int x, int y, int button_mask)
+{
+    vout_display_SendEvent(vd, VOUT_DISPLAY_EVENT_MOUSE_STATE, x, y, button_mask);
+}
+static inline void vout_display_SendEventMouseMoved(vout_display_t *vd, int x, int y)
+{
+    vout_display_SendEvent(vd, VOUT_DISPLAY_EVENT_MOUSE_MOVED, x, y);
+}
+static inline void vout_display_SendEventMousePressed(vout_display_t *vd, int button)
+{
+    vout_display_SendEvent(vd, VOUT_DISPLAY_EVENT_MOUSE_PRESSED, button);
+}
+static inline void vout_display_SendEventMouseReleased(vout_display_t *vd, int button)
+{
+    vout_display_SendEvent(vd, VOUT_DISPLAY_EVENT_MOUSE_RELEASED, button);
+}
+static inline void vout_display_SendEventMouseDoubleClick(vout_display_t *vd)
+{
+    vout_display_SendEvent(vd, VOUT_DISPLAY_EVENT_MOUSE_DOUBLE_CLICK);
+}
+
+/**
+ * Asks for a new window with the given configuration as hint.
+ *
+ * b_standalone/i_x/i_y may be overwritten by the core
+ */
+static inline vout_window_t *vout_display_NewWindow(vout_display_t *vd, const vout_window_cfg_t *cfg)
+{
+    return vd->owner.window_new(vd, cfg);
+}
+/**
+ * Deletes a window created by vout_display_NewWindow if window is non NULL
+ * or any unused windows otherwise.
+ */
+static inline void vout_display_DeleteWindow(vout_display_t *vd,
+                                             vout_window_t *window)
+{
+    vd->owner.window_del(vd, window);
+}
+
+/**
+ * Computes the default display size given the source and
+ * the display configuration.
+ *
+ * This asssumes that the picture is already cropped.
+ */
+VLC_API void vout_display_GetDefaultDisplaySize(unsigned *width, unsigned *height, const video_format_t *source, const vout_display_cfg_t *);
+
+
+/**
+ * Structure used to store the result of a vout_display_PlacePicture.
+ */
+typedef struct {
+    int x;
+    int y;
+    unsigned width;
+    unsigned height;
+} vout_display_place_t;
+
+/**
+ * Computes how to place a picture inside the display to respect
+ * the given parameters.
+ * This assumes that cropping is done by an external mean.
+ *
+ * \param p_place Place inside the window (window pixel unit)
+ * \param p_source Video source format
+ * \param p_cfg Display configuration
+ * \param b_clip If true, prevent the video to go outside the display (break zoom).
+ */
+VLC_API void vout_display_PlacePicture(vout_display_place_t *place, const video_format_t *source, const vout_display_cfg_t *cfg, bool do_clipping);
+
+#endif /* VLC_VOUT_DISPLAY_H */
+

=== added file 'DivCity/DivCity/vlc/plugins/vlc_vout_osd.h'
--- DivCity/DivCity/vlc/plugins/vlc_vout_osd.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_vout_osd.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,98 @@
+/*****************************************************************************
+ * vlc_vout_osd.h: vout OSD
+ *****************************************************************************
+ * Copyright (C) 1999-2010 VLC authors and VideoLAN
+ * Copyright (C) 2004-2005 M2X
+ * $Id: 74d79379258cf0af1cdafcd45946c7b4cf23b01f $
+ *
+ * Authors: Jean-Paul Saman <jpsaman #_at_# m2x dot nl>
+ *          Gildas Bazin <gbazin@videolan.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_VOUT_OSD_H
+#define VLC_VOUT_OSD_H 1
+
+#include <vlc_spu.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * OSD menu position and picture type defines
+ */
+enum
+{
+    /* Icons */
+    OSD_PLAY_ICON = 1,
+    OSD_PAUSE_ICON,
+    OSD_SPEAKER_ICON,
+    OSD_MUTE_ICON,
+    /* Sliders */
+    OSD_HOR_SLIDER,
+    OSD_VERT_SLIDER,
+};
+
+/**********************************************************************
+ * Vout text and widget overlays
+ **********************************************************************/
+VLC_API int vout_OSDEpg( vout_thread_t *, input_item_t * );
+
+/**
+ * \brief Write an informative message if the OSD option is enabled.
+ * \param vout The vout on which the message will be displayed
+ * \param channel Subpicture channel
+ * \param position Position of the text
+ * \param duration Duration of the text being displayed
+ * \param text Text to be displayed
+ */
+VLC_API void vout_OSDText( vout_thread_t *vout, int channel, int position, mtime_t duration, const char *text );
+
+/**
+ * \brief Write an informative message at the default location,
+ *        for the default duration and only if the OSD option is enabled.
+ * \param vout The vout on which the message will be displayed
+ * \param channel Subpicture channel
+ * \param format printf style formatting
+ *
+ * Provided for convenience.
+ */
+VLC_API void vout_OSDMessage( vout_thread_t *, int, const char *, ... ) VLC_FORMAT( 3, 4 );
+
+/**
+ * Display a slider on the video output.
+ * \param p_this    The object that called the function.
+ * \param i_channel Subpicture channel
+ * \param i_postion Current position in the slider
+ * \param i_type    Types are: OSD_HOR_SLIDER and OSD_VERT_SLIDER.
+ */
+VLC_API void vout_OSDSlider( vout_thread_t *, int, int , short );
+
+/**
+ * Display an Icon on the video output.
+ * \param p_this    The object that called the function.
+ * \param i_channel Subpicture channel
+ * \param i_type    Types are: OSD_PLAY_ICON, OSD_PAUSE_ICON, OSD_SPEAKER_ICON, OSD_MUTE_ICON
+ */
+VLC_API void vout_OSDIcon( vout_thread_t *, int, short );
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* VLC_VOUT_OSD_H */
+

=== added file 'DivCity/DivCity/vlc/plugins/vlc_vout_window.h'
--- DivCity/DivCity/vlc/plugins/vlc_vout_window.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_vout_window.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,168 @@
+/*****************************************************************************
+ * vlc_vout_window.h: vout_window_t definitions
+ *****************************************************************************
+ * Copyright (C) 2008 RÃ©mi Denis-Courmont
+ * Copyright (C) 2009 Laurent Aimar
+ * $Id: ea5e82188fd5f5153ba7860d9e70e932c307c861 $
+ *
+ * Authors: Laurent Aimar <fenrir _AT_ videolan _DOT_ org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_VOUT_WINDOW_H
+#define VLC_VOUT_WINDOW_H 1
+
+/**
+ * \file
+ * This file defines vout windows structures and functions in vlc
+ */
+
+#include <vlc_common.h>
+
+/* */
+typedef struct vout_window_t vout_window_t;
+typedef struct vout_window_sys_t vout_window_sys_t;
+
+
+/**
+ * Window handle type
+ */
+enum {
+    VOUT_WINDOW_TYPE_XID,
+    VOUT_WINDOW_TYPE_HWND,
+    VOUT_WINDOW_TYPE_NSOBJECT,
+};
+
+#if defined (WIN32) || defined (__OS2__)
+# define VOUT_WINDOW_TYPE_NATIVE VOUT_WINDOW_TYPE_HWND
+#elif defined (__unix__)
+# define VOUT_WINDOW_TYPE_NATIVE VOUT_WINDOW_TYPE_XID
+#endif
+
+/**
+ * Control query for vout_window_t
+ */
+enum {
+    VOUT_WINDOW_SET_STATE, /* unsigned state */
+    VOUT_WINDOW_SET_SIZE,   /* unsigned i_width, unsigned i_height */
+    VOUT_WINDOW_SET_FULLSCREEN, /* int b_fullscreen */
+};
+
+typedef struct {
+    /* If true, a standalone window is requested */
+    bool is_standalone;
+
+    /* Window handle type */
+    int type;
+
+    /* Window position hint */
+    int x;
+    int y;
+
+    /* Windows size hint */
+    unsigned width;
+    unsigned height;
+
+} vout_window_cfg_t;
+
+/**
+ * FIXME do we need an event system in the window too ?
+ * or the window user will take care of it ?
+ */
+struct vout_window_t {
+    VLC_COMMON_MEMBERS
+
+    /* window handle (mandatory)
+     *
+     * It must be filled in the open function.
+     */
+    union {
+        void     *hwnd;     /* Win32 window handle */
+        uint32_t xid;       /* X11 windows ID */
+        void     *nsobject; /* Mac OSX view object */
+    } handle;
+
+    /* display server (mandatory) */
+    union {
+        char     *x11; /* X11 display (NULL = use default) */
+    } display;
+
+    /* Control on the module (mandatory)
+     *
+     * Do not use it directly; use vout_window_Control instead.
+     */
+    int (*control)(vout_window_t *, int query, va_list);
+
+    /* Private place holder for the vout_window_t module (optional)
+     *
+     * A module is free to use it as it wishes.
+     */
+    vout_window_sys_t *sys;
+};
+
+/**
+ * Creates a new window.
+ *
+ * @param module plugin name (usually "$window")
+ * @note If you are inside a "vout display", you must use
+ / vout_display_NewWindow() and vout_display_DeleteWindow() instead.
+ * This enables recycling windows.
+ */
+VLC_API vout_window_t * vout_window_New(vlc_object_t *, const char *module, const vout_window_cfg_t *);
+
+/**
+ * Deletes a window created by vout_window_New().
+ *
+ * @note See vout_window_New() about window recycling.
+ */
+VLC_API void vout_window_Delete(vout_window_t *);
+
+
+/**
+ * Reconfigures a window.
+ *
+ * @note The vout_window_* wrappers should be used instead of this function.
+ *
+ * @warning The caller must own the window, as vout_window_t is not thread safe.
+ */
+VLC_API int vout_window_Control(vout_window_t *, int query, ...);
+
+/**
+ * Configures the window manager state for this window.
+ */
+static inline int vout_window_SetState(vout_window_t *window, unsigned state)
+{
+    return vout_window_Control(window, VOUT_WINDOW_SET_STATE, state);
+}
+
+/**
+ * Configures the window display (i.e. inner/useful) size.
+ */
+static inline int vout_window_SetSize(vout_window_t *window,
+                                      unsigned width, unsigned height)
+{
+    return vout_window_Control(window, VOUT_WINDOW_SET_SIZE, width, height);
+}
+
+/**
+ * Sets fullscreen mode.
+ */
+static inline int vout_window_SetFullScreen(vout_window_t *window, bool full)
+{
+    return vout_window_Control(window, VOUT_WINDOW_SET_FULLSCREEN, full);
+}
+
+#endif /* VLC_VOUT_WINDOW_H */

=== added file 'DivCity/DivCity/vlc/plugins/vlc_xlib.h'
--- DivCity/DivCity/vlc/plugins/vlc_xlib.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_xlib.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,57 @@
+/*****************************************************************************
+ * vlc_xlib.h: initialization of Xlib
+ *****************************************************************************
+ * Copyright (C) 2010 RÃ©mi Denis-Courmont
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_XLIB_H
+# define VLC_XLIB_H 1
+
+# include <stdio.h>
+# include <stdlib.h>
+# include <X11/Xlib.h>
+# include <X11/Xlibint.h>
+
+static inline bool vlc_xlib_init (vlc_object_t *obj)
+{
+    if (!var_InheritBool (obj, "xlib"))
+        return false;
+
+    bool ok = false;
+
+    /* XInitThreads() can be called multiple times,
+     * but it is not reentrant, so we need this global lock. */
+    vlc_global_lock (VLC_XLIB_MUTEX);
+
+    if (_Xglobal_lock == NULL && unlikely(_XErrorFunction != NULL))
+        /* (_Xglobal_lock == NULL) => Xlib threads not initialized */
+        /* (_XErrorFunction != NULL) => Xlib already in use */
+        fprintf (stderr, "%s:%u:%s: Xlib not initialized for threads.\n"
+                 "This process is probably using LibVLC incorrectly.\n"
+                 "Pass \"--no-xlib\" to libvlc_new() to fix this.\n",
+                 __FILE__, __LINE__, __func__);
+    else if (XInitThreads ())
+        ok = true;
+
+    vlc_global_unlock (VLC_XLIB_MUTEX);
+
+    if (!ok)
+        msg_Err (obj, "Xlib not initialized for threads");
+    return ok;
+}
+
+#endif

=== added file 'DivCity/DivCity/vlc/plugins/vlc_xml.h'
--- DivCity/DivCity/vlc/plugins/vlc_xml.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/plugins/vlc_xml.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,120 @@
+/*****************************************************************************
+ * xml.h: XML abstraction layer
+ *****************************************************************************
+ * Copyright (C) 2004-2010 VLC authors and VideoLAN
+ *
+ * Author: Gildas Bazin <gbazin@videolan.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_XML_H
+#define VLC_XML_H
+
+/**
+* \file
+* This file defines functions and structures to handle xml tags in vlc
+*
+*/
+
+# ifdef __cplusplus
+extern "C" {
+# endif
+
+struct xml_t
+{
+    VLC_COMMON_MEMBERS
+
+    /* Module properties */
+    module_t  *p_module;
+    xml_sys_t *p_sys;
+
+    void (*pf_catalog_load) ( xml_t *, const char * );
+    void (*pf_catalog_add) ( xml_t *, const char *, const char *,
+                            const char * );
+};
+
+VLC_API xml_t * xml_Create( vlc_object_t * ) VLC_USED;
+#define xml_Create( a ) xml_Create( VLC_OBJECT(a) )
+VLC_API void xml_Delete( xml_t * );
+
+static inline void xml_CatalogLoad( xml_t *xml, const char *catalog )
+{
+    xml->pf_catalog_load( xml, catalog );
+}
+
+static inline void xml_CatalogAdd( xml_t *xml, const char *type,
+                                   const char *orig, const char *value )
+{
+    xml->pf_catalog_add( xml, type, orig, value );
+}
+
+
+struct xml_reader_t
+{
+    VLC_COMMON_MEMBERS
+
+    xml_reader_sys_t *p_sys;
+    stream_t *p_stream;
+    module_t *p_module;
+
+    int (*pf_next_node) ( xml_reader_t *, const char ** );
+    const char *(*pf_next_attr) ( xml_reader_t *, const char ** );
+
+    int (*pf_use_dtd) ( xml_reader_t * );
+    int (*pf_is_empty) ( xml_reader_t * );
+};
+
+VLC_API xml_reader_t * xml_ReaderCreate(vlc_object_t *, stream_t *) VLC_USED;
+#define xml_ReaderCreate( a, s ) xml_ReaderCreate(VLC_OBJECT(a), s)
+VLC_API void xml_ReaderDelete(xml_reader_t *);
+VLC_API xml_reader_t * xml_ReaderReset(xml_reader_t *, stream_t *) VLC_USED;
+
+static inline int xml_ReaderNextNode( xml_reader_t *reader, const char **pval )
+{
+    return reader->pf_next_node( reader, pval );
+}
+
+static inline const char *xml_ReaderNextAttr( xml_reader_t *reader,
+                                              const char **pval )
+{
+  return reader->pf_next_attr( reader, pval );
+}
+
+static inline int xml_ReaderUseDTD( xml_reader_t *reader )
+{
+  return reader->pf_use_dtd( reader );
+}
+
+static inline int xml_ReaderIsEmptyElement( xml_reader_t *reader )
+{
+    if(reader->pf_is_empty == NULL)
+        return -2;
+
+    return reader->pf_is_empty( reader );
+}
+
+enum {
+    XML_READER_NONE=0,
+    XML_READER_STARTELEM,
+    XML_READER_ENDELEM,
+    XML_READER_TEXT,
+};
+
+# ifdef __cplusplus
+}
+# endif
+
+#endif

=== added file 'DivCity/DivCity/vlc/vlc.h'
--- DivCity/DivCity/vlc/vlc.h	1970-01-01 00:00:00 +0000
+++ DivCity/DivCity/vlc/vlc.h	2012-10-15 20:27:46 +0000
@@ -0,0 +1,56 @@
+/*****************************************************************************
+ * vlc.h: global header for libvlc
+ *****************************************************************************
+ * Copyright (C) 1998-2008 VLC authors and VideoLAN
+ * $Id: 8f39094bd4b15c99288cecd001f76fcc10565daa $
+ *
+ * Authors: Vincent Seguin <seguin@via.ecp.fr>
+ *          Samuel Hocevar <sam@zoy.org>
+ *          Gildas Bazin <gbazin@netcourrier.com>
+ *          Derk-Jan Hartman <hartman at videolan dot org>
+ *          Pierre d'Herbemont <pdherbemont@videolan.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef VLC_VLC_H
+#define VLC_VLC_H 1
+
+/**
+ * \file
+ * This file defines libvlc new external API
+ */
+
+# ifdef __cplusplus
+extern "C" {
+# endif
+
+#include <vlc/libvlc_structures.h>
+#include <vlc/libvlc.h>
+#include <vlc/libvlc_media.h>
+#include <vlc/libvlc_media_player.h>
+#include <vlc/libvlc_media_list.h>
+#include <vlc/libvlc_media_list_player.h>
+#include <vlc/libvlc_media_library.h>
+#include <vlc/libvlc_media_discoverer.h>
+#include <vlc/libvlc_events.h>
+#include <vlc/libvlc_vlm.h>
+#include <vlc/deprecated.h>
+
+# ifdef __cplusplus
+}
+# endif
+
+#endif /* _VLC_VLC_H */

=== added directory 'DivCity/Release'
=== added file 'DivCity/Release/DivCity.exe'
Binary files DivCity/Release/DivCity.exe	1970-01-01 00:00:00 +0000 and DivCity/Release/DivCity.exe	2012-12-04 20:09:12 +0000 differ
=== added file 'DivCity/Release/DivCity.pdb'
Binary files DivCity/Release/DivCity.pdb	1970-01-01 00:00:00 +0000 and DivCity/Release/DivCity.pdb	2012-12-04 19:33:13 +0000 differ
=== added directory 'DivCity/Release/audio'
=== added file 'DivCity/Release/audio/Everyday.mp3'
Binary files DivCity/Release/audio/Everyday.mp3	1970-01-01 00:00:00 +0000 and DivCity/Release/audio/Everyday.mp3	2012-12-04 18:20:09 +0000 differ
=== added file 'DivCity/Release/audio/Music.xspf'
--- DivCity/Release/audio/Music.xspf	1970-01-01 00:00:00 +0000
+++ DivCity/Release/audio/Music.xspf	2012-12-04 18:20:09 +0000
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist xmlns="http://xspf.org/ns/0/" xmlns:vlc="http://www.videolan.org/vlc/playlist/ns/0/" version="1">
+	<title>Lista de reproduccion</title>
+	<trackList>
+		<track>
+			<location>file:///usr/share/multiverse-city/audio/TheGiantTrees.mp3</location>
+			<duration>384395</duration>
+			<extension application="http://www.videolan.org/vlc/playlist/0">
+				<vlc:id>1</vlc:id>
+			</extension>
+		</track>
+		<track>
+			<location>file:///usr/share/multiverse-city/audio/Everyday.mp3</location>
+			<duration>345133</duration>
+			<extension application="http://www.videolan.org/vlc/playlist/0">
+				<vlc:id>0</vlc:id>
+			</extension>
+		</track>
+	</trackList>
+	<extension application="http://www.videolan.org/vlc/playlist/0">
+			<vlc:item tid="0"/>
+			<vlc:item tid="1"/>
+	</extension>
+</playlist>

=== added file 'DivCity/Release/audio/TheGiantTrees.mp3'
Binary files DivCity/Release/audio/TheGiantTrees.mp3	1970-01-01 00:00:00 +0000 and DivCity/Release/audio/TheGiantTrees.mp3	2012-12-04 18:20:09 +0000 differ
=== added file 'DivCity/Release/libvlc.dll'
Binary files DivCity/Release/libvlc.dll	1970-01-01 00:00:00 +0000 and DivCity/Release/libvlc.dll	2012-10-15 20:27:56 +0000 differ
=== added file 'DivCity/Release/libvlccore.dll'
Binary files DivCity/Release/libvlccore.dll	1970-01-01 00:00:00 +0000 and DivCity/Release/libvlccore.dll	2012-10-15 20:28:38 +0000 differ
=== added file 'DivCity/Release/mctcube.dll'
Binary files DivCity/Release/mctcube.dll	1970-01-01 00:00:00 +0000 and DivCity/Release/mctcube.dll	2012-12-04 20:09:04 +0000 differ
=== added file 'DivCity/Release/mctcube.exp'
Binary files DivCity/Release/mctcube.exp	1970-01-01 00:00:00 +0000 and DivCity/Release/mctcube.exp	2012-12-04 20:08:52 +0000 differ
=== added file 'DivCity/Release/mctcube.lib'
Binary files DivCity/Release/mctcube.lib	1970-01-01 00:00:00 +0000 and DivCity/Release/mctcube.lib	2012-12-04 20:08:52 +0000 differ
=== added file 'DivCity/Release/mctcube.pdb'
Binary files DivCity/Release/mctcube.pdb	1970-01-01 00:00:00 +0000 and DivCity/Release/mctcube.pdb	2012-12-04 20:08:58 +0000 differ
=== added directory 'DivCity/Release/media'
=== added file 'DivCity/Release/media/alertbox.png'
Binary files DivCity/Release/media/alertbox.png	1970-01-01 00:00:00 +0000 and DivCity/Release/media/alertbox.png	2012-12-04 18:20:09 +0000 differ
=== added file 'DivCity/Release/media/amarilla.png'
Binary files DivCity/Release/media/amarilla.png	1970-01-01 00:00:00 +0000 and DivCity/Release/media/amarilla.png	2012-12-04 18:20:09 +0000 differ
=== added file 'DivCity/Release/media/clean.png'
Binary files DivCity/Release/media/clean.png	1970-01-01 00:00:00 +0000 and DivCity/Release/media/clean.png	2012-12-04 18:20:09 +0000 differ
=== added file 'DivCity/Release/media/industria.png'
Binary files DivCity/Release/media/industria.png	1970-01-01 00:00:00 +0000 and DivCity/Release/media/industria.png	2012-12-04 18:20:09 +0000 differ
=== added file 'DivCity/Release/media/oficina.png'
Binary files DivCity/Release/media/oficina.png	1970-01-01 00:00:00 +0000 and DivCity/Release/media/oficina.png	2012-12-04 18:20:09 +0000 differ
=== added file 'DivCity/Release/media/pointer.png'
Binary files DivCity/Release/media/pointer.png	1970-01-01 00:00:00 +0000 and DivCity/Release/media/pointer.png	2012-12-04 18:20:09 +0000 differ
=== added file 'DivCity/Release/media/rejilla.png'
Binary files DivCity/Release/media/rejilla.png	1970-01-01 00:00:00 +0000 and DivCity/Release/media/rejilla.png	2012-12-04 18:20:09 +0000 differ
=== added file 'DivCity/Release/media/residencia_moderna.png'
Binary files DivCity/Release/media/residencia_moderna.png	1970-01-01 00:00:00 +0000 and DivCity/Release/media/residencia_moderna.png	2012-12-04 18:20:09 +0000 differ
=== added file 'DivCity/Release/media/road.png'
Binary files DivCity/Release/media/road.png	1970-01-01 00:00:00 +0000 and DivCity/Release/media/road.png	2012-12-04 18:20:09 +0000 differ
=== added file 'DivCity/Release/media/splash.png'
Binary files DivCity/Release/media/splash.png	1970-01-01 00:00:00 +0000 and DivCity/Release/media/splash.png	2012-12-04 18:20:09 +0000 differ
=== added file 'DivCity/Release/media/template.png'
Binary files DivCity/Release/media/template.png	1970-01-01 00:00:00 +0000 and DivCity/Release/media/template.png	2012-12-04 18:20:09 +0000 differ
=== added file 'DivCity/Release/media/test.png'
Binary files DivCity/Release/media/test.png	1970-01-01 00:00:00 +0000 and DivCity/Release/media/test.png	2012-12-04 18:20:09 +0000 differ
=== added file 'DivCity/Release/media/toolbox.png'
Binary files DivCity/Release/media/toolbox.png	1970-01-01 00:00:00 +0000 and DivCity/Release/media/toolbox.png	2012-12-04 18:20:09 +0000 differ
=== added file 'DivCity/Release/media/valla.png'
Binary files DivCity/Release/media/valla.png	1970-01-01 00:00:00 +0000 and DivCity/Release/media/valla.png	2012-12-04 18:20:09 +0000 differ
=== added directory 'DivCity/ipch'
=== added directory 'DivCity/ipch/divcity-cb186661'
=== added file 'DivCity/ipch/divcity-cb186661/divcity-51fedbe2.ipch'
Binary files DivCity/ipch/divcity-cb186661/divcity-51fedbe2.ipch	1970-01-01 00:00:00 +0000 and DivCity/ipch/divcity-cb186661/divcity-51fedbe2.ipch	2012-12-04 18:57:26 +0000 differ
=== added file 'DivCity/ipch/divcity-cb186661/divcity-c3b8bfe8.ipch'
Binary files DivCity/ipch/divcity-cb186661/divcity-c3b8bfe8.ipch	1970-01-01 00:00:00 +0000 and DivCity/ipch/divcity-cb186661/divcity-c3b8bfe8.ipch	2012-12-04 18:23:54 +0000 differ
=== added directory 'DivCity/ipch/mctcube-2fa4e8af'
=== added directory 'DivCity/mctcube'
=== added file 'DivCity/mctcube/ReadMe.txt'
--- DivCity/mctcube/ReadMe.txt	1970-01-01 00:00:00 +0000
+++ DivCity/mctcube/ReadMe.txt	2012-12-04 18:40:22 +0000
@@ -0,0 +1,46 @@
+ï»¿========================================================================
+    BIBLIOTECA DE VÃNCULOS DINÃMICOS: mctcube 
+                                      InformaciÃ³n general del proyecto
+========================================================================
+
+AppWizard ha creado este archivo DLL mctcube.
+
+Este archivo incluye un resumen acerca del contenido de los archivos que 
+constituyen su aplicaciÃ³n mctcube.
+
+
+mctcube.vcxproj
+    Ã‰ste es el archivo de proyecto principal para los proyectos de VC++ 
+    generados mediante un Asistente para aplicaciones.
+    Contiene informaciÃ³n acerca de la versiÃ³n de Visual C++ con la que 
+    se generÃ³ el archivo, asÃ­ como informaciÃ³n acerca de las plataformas, 
+    configuraciones y caracterÃ­sticas del proyecto seleccionadas en el 
+    asistente para aplicaciones.
+
+mctcube.vcxproj.filters
+    Ã‰ste es el archivo de filtros para los proyectos de VC++ generados 
+    mediante un asistente para aplicaciones. 
+    Contiene informaciÃ³n acerca de la asociaciÃ³n entre los archivos de 
+    un proyecto y los filtros. Esta asociaciÃ³n se usa en el IDE para mostrar 
+    la agrupaciÃ³n de archivos con extensiones similares bajo un nodo 
+    especÃ­fico (por ejemplo, los archivos ".cpp" se asocian con el filtro
+    "Archivos de cÃ³digo fuente").
+
+mctcube.cpp
+    Ã‰ste es el archivo de cÃ³digo fuente DLL principal.
+
+/////////////////////////////////////////////////////////////////////////////
+Otros archivos estÃ¡ndar:
+
+StdAfx.h, StdAfx.cpp
+    Estos archivos se utilizan para crear un archivo de encabezado precompilado 
+    (PCH) denominado mctcube.pch y un archivo de tipos 
+    precompilado denominado StdAfx.obj.
+
+/////////////////////////////////////////////////////////////////////////////
+Otras notas:
+
+El asistente para aplicaciones utiliza comentarios "TODO:" para indicar las 
+partes del cÃ³digo fuente que tendrÃ¡ que agregar o personalizar.
+
+/////////////////////////////////////////////////////////////////////////////

=== added directory 'DivCity/mctcube/Release'
=== added file 'DivCity/mctcube/Release/CL.read.1.tlog'
Binary files DivCity/mctcube/Release/CL.read.1.tlog	1970-01-01 00:00:00 +0000 and DivCity/mctcube/Release/CL.read.1.tlog	2012-12-04 20:08:48 +0000 differ
=== added file 'DivCity/mctcube/Release/CL.write.1.tlog'
Binary files DivCity/mctcube/Release/CL.write.1.tlog	1970-01-01 00:00:00 +0000 and DivCity/mctcube/Release/CL.write.1.tlog	2012-12-04 20:08:48 +0000 differ
=== added file 'DivCity/mctcube/Release/cl.command.1.tlog'
Binary files DivCity/mctcube/Release/cl.command.1.tlog	1970-01-01 00:00:00 +0000 and DivCity/mctcube/Release/cl.command.1.tlog	2012-12-04 20:08:48 +0000 differ
=== added file 'DivCity/mctcube/Release/dllmain.obj'
Binary files DivCity/mctcube/Release/dllmain.obj	1970-01-01 00:00:00 +0000 and DivCity/mctcube/Release/dllmain.obj	2012-12-04 18:55:44 +0000 differ
=== added file 'DivCity/mctcube/Release/link.command.1.tlog'
Binary files DivCity/mctcube/Release/link.command.1.tlog	1970-01-01 00:00:00 +0000 and DivCity/mctcube/Release/link.command.1.tlog	2012-12-04 20:09:00 +0000 differ
=== added file 'DivCity/mctcube/Release/link.read.1.tlog'
Binary files DivCity/mctcube/Release/link.read.1.tlog	1970-01-01 00:00:00 +0000 and DivCity/mctcube/Release/link.read.1.tlog	2012-12-04 20:09:00 +0000 differ
=== added file 'DivCity/mctcube/Release/link.write.1.tlog'
Binary files DivCity/mctcube/Release/link.write.1.tlog	1970-01-01 00:00:00 +0000 and DivCity/mctcube/Release/link.write.1.tlog	2012-12-04 20:09:00 +0000 differ
=== added file 'DivCity/mctcube/Release/main.obj'
Binary files DivCity/mctcube/Release/main.obj	1970-01-01 00:00:00 +0000 and DivCity/mctcube/Release/main.obj	2012-12-04 20:08:48 +0000 differ
=== added file 'DivCity/mctcube/Release/mctcube.dll.intermediate.manifest'
--- DivCity/mctcube/Release/mctcube.dll.intermediate.manifest	1970-01-01 00:00:00 +0000
+++ DivCity/mctcube/Release/mctcube.dll.intermediate.manifest	2012-12-04 20:08:56 +0000
@@ -0,0 +1,15 @@
+<?xml version='1.0' encoding='UTF-8' standalone='yes'?>
+<assembly xmlns='urn:schemas-microsoft-com:asm.v1' manifestVersion='1.0'>
+  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v3">
+    <security>
+      <requestedPrivileges>
+        <requestedExecutionLevel level='asInvoker' uiAccess='false' />
+      </requestedPrivileges>
+    </security>
+  </trustInfo>
+  <dependency>
+    <dependentAssembly>
+      <assemblyIdentity type='win32'              name='Microsoft.Windows.Common-Controls'        version='6.0.0.0'                               processorArchitecture='x86'                   publicKeyToken='6595b64144ccf1df'               language='*' />
+    </dependentAssembly>
+  </dependency>
+</assembly>

=== added file 'DivCity/mctcube/Release/mctcube.lastbuildstate'
--- DivCity/mctcube/Release/mctcube.lastbuildstate	1970-01-01 00:00:00 +0000
+++ DivCity/mctcube/Release/mctcube.lastbuildstate	2012-12-04 20:09:05 +0000
@@ -0,0 +1,2 @@
+#v4.0:v100
+Release|Win32|C:\Divel\multiverse-city\DivCity\|

=== added file 'DivCity/mctcube/Release/mctcube.log'
--- DivCity/mctcube/Release/mctcube.log	1970-01-01 00:00:00 +0000
+++ DivCity/mctcube/Release/mctcube.log	2012-12-04 20:09:05 +0000
@@ -0,0 +1,127 @@
+ï»¿CompilaciÃ³n iniciada a las 04/12/2012 21:08:39.
+     1>Proyecto "C:\Divel\multiverse-city\DivCity\mctcube\mctcube.vcxproj" en el nodo 2 (build destinos).
+     1>InitializeBuildStatus:
+         Se crearÃ¡ "Release\mctcube.unsuccessfulbuild" porque se especificÃ³ "AlwaysCreate".
+       ClCompile:
+         c:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\bin\CL.exe /c /I"C:\wxWidgets-2.9.3\include" /I"C:\wxWidgets-2.9.3\include\msvc" /I"C:\Divel\multiverse-city\DivCity\DivCity" /Zi /nologo /W3 /WX- /O2 /Oi /Oy- /GL /D WIN32 /D NDEBUG /D _WINDOWS /D _USRDLL /D MCTCUBE_EXPORTS /D _WINDLL /D _UNICODE /D UNICODE /Gm- /EHsc /MD /GS /Gy /fp:precise /Zc:wchar_t /Zc:forScope /Fo"Release\\" /Fd"Release\vc100.pdb" /Gd /TP /analyze- /errorReport:prompt ..\..\libmctcube\main.cpp
+         main.cpp
+     1>C:\wxWidgets-2.9.3\include\wx/wxcrt.h(210): warning C4996: 'strcpy': This function or variable may be unsafe. Consider using strcpy_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
+                 c:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\string.h(105) : vea la declaraciÃ³n de 'strcpy'
+     1>C:\wxWidgets-2.9.3\include\wx/wxcrt.h(212): warning C4996: 'wcscpy': This function or variable may be unsafe. Consider using wcscpy_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
+                 c:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\string.h(283) : vea la declaraciÃ³n de 'wcscpy'
+     1>C:\wxWidgets-2.9.3\include\wx/wxcrt.h(214): warning C4996: 'strcpy': This function or variable may be unsafe. Consider using strcpy_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
+                 c:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\string.h(105) : vea la declaraciÃ³n de 'strcpy'
+     1>C:\wxWidgets-2.9.3\include\wx/wxcrt.h(216): warning C4996: 'strcpy': This function or variable may be unsafe. Consider using strcpy_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
+                 c:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\string.h(105) : vea la declaraciÃ³n de 'strcpy'
+     1>C:\wxWidgets-2.9.3\include\wx/wxcrt.h(218): warning C4996: 'strcpy': This function or variable may be unsafe. Consider using strcpy_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
+                 c:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\string.h(105) : vea la declaraciÃ³n de 'strcpy'
+     1>C:\wxWidgets-2.9.3\include\wx/wxcrt.h(220): warning C4996: 'wcscpy': This function or variable may be unsafe. Consider using wcscpy_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
+                 c:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\string.h(283) : vea la declaraciÃ³n de 'wcscpy'
+     1>C:\wxWidgets-2.9.3\include\wx/wxcrt.h(222): warning C4996: 'wcscpy': This function or variable may be unsafe. Consider using wcscpy_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
+                 c:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\string.h(283) : vea la declaraciÃ³n de 'wcscpy'
+     1>C:\wxWidgets-2.9.3\include\wx/wxcrt.h(224): warning C4996: 'wcscpy': This function or variable may be unsafe. Consider using wcscpy_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
+                 c:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\string.h(283) : vea la declaraciÃ³n de 'wcscpy'
+     1>C:\wxWidgets-2.9.3\include\wx/wxcrt.h(226): warning C4996: 'strcpy': This function or variable may be unsafe. Consider using strcpy_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
+                 c:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\string.h(105) : vea la declaraciÃ³n de 'strcpy'
+     1>C:\wxWidgets-2.9.3\include\wx/wxcrt.h(228): warning C4996: 'wcscpy': This function or variable may be unsafe. Consider using wcscpy_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
+                 c:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\string.h(283) : vea la declaraciÃ³n de 'wcscpy'
+     1>C:\wxWidgets-2.9.3\include\wx/wxcrt.h(231): warning C4996: 'strncpy': This function or variable may be unsafe. Consider using strncpy_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
+                 c:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\string.h(188) : vea la declaraciÃ³n de 'strncpy'
+     1>C:\wxWidgets-2.9.3\include\wx/wxcrt.h(233): warning C4996: 'wcsncpy': This function or variable may be unsafe. Consider using wcsncpy_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
+                 c:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\string.h(306) : vea la declaraciÃ³n de 'wcsncpy'
+     1>C:\wxWidgets-2.9.3\include\wx/wxcrt.h(235): warning C4996: 'strncpy': This function or variable may be unsafe. Consider using strncpy_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
+                 c:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\string.h(188) : vea la declaraciÃ³n de 'strncpy'
+     1>C:\wxWidgets-2.9.3\include\wx/wxcrt.h(237): warning C4996: 'strncpy': This function or variable may be unsafe. Consider using strncpy_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
+                 c:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\string.h(188) : vea la declaraciÃ³n de 'strncpy'
+     1>C:\wxWidgets-2.9.3\include\wx/wxcrt.h(239): warning C4996: 'strncpy': This function or variable may be unsafe. Consider using strncpy_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
+                 c:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\string.h(188) : vea la declaraciÃ³n de 'strncpy'
+     1>C:\wxWidgets-2.9.3\include\wx/wxcrt.h(241): warning C4996: 'wcsncpy': This function or variable may be unsafe. Consider using wcsncpy_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
+                 c:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\string.h(306) : vea la declaraciÃ³n de 'wcsncpy'
+     1>C:\wxWidgets-2.9.3\include\wx/wxcrt.h(243): warning C4996: 'wcsncpy': This function or variable may be unsafe. Consider using wcsncpy_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
+                 c:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\string.h(306) : vea la declaraciÃ³n de 'wcsncpy'
+     1>C:\wxWidgets-2.9.3\include\wx/wxcrt.h(245): warning C4996: 'wcsncpy': This function or variable may be unsafe. Consider using wcsncpy_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
+                 c:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\string.h(306) : vea la declaraciÃ³n de 'wcsncpy'
+     1>C:\wxWidgets-2.9.3\include\wx/wxcrt.h(247): warning C4996: 'strncpy': This function or variable may be unsafe. Consider using strncpy_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
+                 c:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\string.h(188) : vea la declaraciÃ³n de 'strncpy'
+     1>C:\wxWidgets-2.9.3\include\wx/wxcrt.h(249): warning C4996: 'wcsncpy': This function or variable may be unsafe. Consider using wcsncpy_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
+                 c:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\string.h(306) : vea la declaraciÃ³n de 'wcsncpy'
+     1>C:\wxWidgets-2.9.3\include\wx/wxcrt.h(261): warning C4996: 'strncpy': This function or variable may be unsafe. Consider using strncpy_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
+                 c:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\string.h(188) : vea la declaraciÃ³n de 'strncpy'
+     1>C:\wxWidgets-2.9.3\include\wx/wxcrt.h(274): warning C4996: 'wcsncpy': This function or variable may be unsafe. Consider using wcsncpy_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
+                 c:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\string.h(306) : vea la declaraciÃ³n de 'wcsncpy'
+     1>C:\wxWidgets-2.9.3\include\wx/wxcrt.h(282): warning C4996: 'strcat': This function or variable may be unsafe. Consider using strcat_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
+                 c:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\string.h(110) : vea la declaraciÃ³n de 'strcat'
+     1>C:\wxWidgets-2.9.3\include\wx/wxcrt.h(284): warning C4996: 'wcscat': This function or variable may be unsafe. Consider using wcscat_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
+                 c:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\string.h(276) : vea la declaraciÃ³n de 'wcscat'
+     1>C:\wxWidgets-2.9.3\include\wx/wxcrt.h(286): warning C4996: 'strcat': This function or variable may be unsafe. Consider using strcat_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
+                 c:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\string.h(110) : vea la declaraciÃ³n de 'strcat'
+     1>C:\wxWidgets-2.9.3\include\wx/wxcrt.h(288): warning C4996: 'strcat': This function or variable may be unsafe. Consider using strcat_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
+                 c:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\string.h(110) : vea la declaraciÃ³n de 'strcat'
+     1>C:\wxWidgets-2.9.3\include\wx/wxcrt.h(290): warning C4996: 'strcat': This function or variable may be unsafe. Consider using strcat_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
+                 c:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\string.h(110) : vea la declaraciÃ³n de 'strcat'
+     1>C:\wxWidgets-2.9.3\include\wx/wxcrt.h(292): warning C4996: 'wcscat': This function or variable may be unsafe. Consider using wcscat_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
+                 c:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\string.h(276) : vea la declaraciÃ³n de 'wcscat'
+     1>C:\wxWidgets-2.9.3\include\wx/wxcrt.h(294): warning C4996: 'wcscat': This function or variable may be unsafe. Consider using wcscat_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
+                 c:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\string.h(276) : vea la declaraciÃ³n de 'wcscat'
+     1>C:\wxWidgets-2.9.3\include\wx/wxcrt.h(296): warning C4996: 'wcscat': This function or variable may be unsafe. Consider using wcscat_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
+                 c:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\string.h(276) : vea la declaraciÃ³n de 'wcscat'
+     1>C:\wxWidgets-2.9.3\include\wx/wxcrt.h(298): warning C4996: 'strcat': This function or variable may be unsafe. Consider using strcat_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
+                 c:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\string.h(110) : vea la declaraciÃ³n de 'strcat'
+     1>C:\wxWidgets-2.9.3\include\wx/wxcrt.h(300): warning C4996: 'wcscat': This function or variable may be unsafe. Consider using wcscat_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
+                 c:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\string.h(276) : vea la declaraciÃ³n de 'wcscat'
+     1>C:\wxWidgets-2.9.3\include\wx/wxcrt.h(303): warning C4996: 'strncat': This function or variable may be unsafe. Consider using strncat_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
+                 c:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\string.h(175) : vea la declaraciÃ³n de 'strncat'
+     1>C:\wxWidgets-2.9.3\include\wx/wxcrt.h(305): warning C4996: 'wcsncat': This function or variable may be unsafe. Consider using wcsncat_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
+                 c:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\string.h(299) : vea la declaraciÃ³n de 'wcsncat'
+     1>C:\wxWidgets-2.9.3\include\wx/wxcrt.h(307): warning C4996: 'strncat': This function or variable may be unsafe. Consider using strncat_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
+                 c:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\string.h(175) : vea la declaraciÃ³n de 'strncat'
+     1>C:\wxWidgets-2.9.3\include\wx/wxcrt.h(309): warning C4996: 'strncat': This function or variable may be unsafe. Consider using strncat_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
+                 c:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\string.h(175) : vea la declaraciÃ³n de 'strncat'
+     1>C:\wxWidgets-2.9.3\include\wx/wxcrt.h(311): warning C4996: 'strncat': This function or variable may be unsafe. Consider using strncat_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
+                 c:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\string.h(175) : vea la declaraciÃ³n de 'strncat'
+     1>C:\wxWidgets-2.9.3\include\wx/wxcrt.h(313): warning C4996: 'wcsncat': This function or variable may be unsafe. Consider using wcsncat_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
+                 c:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\string.h(299) : vea la declaraciÃ³n de 'wcsncat'
+     1>C:\wxWidgets-2.9.3\include\wx/wxcrt.h(315): warning C4996: 'wcsncat': This function or variable may be unsafe. Consider using wcsncat_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
+                 c:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\string.h(299) : vea la declaraciÃ³n de 'wcsncat'
+     1>C:\wxWidgets-2.9.3\include\wx/wxcrt.h(317): warning C4996: 'wcsncat': This function or variable may be unsafe. Consider using wcsncat_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
+                 c:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\string.h(299) : vea la declaraciÃ³n de 'wcsncat'
+     1>C:\wxWidgets-2.9.3\include\wx/wxcrt.h(319): warning C4996: 'strncat': This function or variable may be unsafe. Consider using strncat_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
+                 c:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\string.h(175) : vea la declaraciÃ³n de 'strncat'
+     1>C:\wxWidgets-2.9.3\include\wx/wxcrt.h(321): warning C4996: 'wcsncat': This function or variable may be unsafe. Consider using wcsncat_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
+                 c:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\string.h(299) : vea la declaraciÃ³n de 'wcsncat'
+     1>C:\wxWidgets-2.9.3\include\wx/wxcrt.h(755): warning C4996: '_wfopen': This function or variable may be unsafe. Consider using _wfopen_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
+                 c:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\stdio.h(601) : vea la declaraciÃ³n de '_wfopen'
+     1>C:\wxWidgets-2.9.3\include\wx/wxcrt.h(757): warning C4996: '_wfreopen': This function or variable may be unsafe. Consider using _wfreopen_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
+                 c:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\stdio.h(603) : vea la declaraciÃ³n de '_wfreopen'
+     1>C:\wxWidgets-2.9.3\include\wx/wxcrt.h(924): warning C4996: 'getenv': This function or variable may be unsafe. Consider using _dupenv_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
+                 c:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\stdlib.h(433) : vea la declaraciÃ³n de 'getenv'
+     1>C:\wxWidgets-2.9.3\include\wx/wxcrt.h(925): warning C4996: '_wgetenv': This function or variable may be unsafe. Consider using _wdupenv_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
+                 c:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\stdlib.h(658) : vea la declaraciÃ³n de '_wgetenv'
+     1>C:\wxWidgets-2.9.3\include\wx/wxcrt.h(926): warning C4996: 'getenv': This function or variable may be unsafe. Consider using _dupenv_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
+                 c:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\stdlib.h(433) : vea la declaraciÃ³n de 'getenv'
+     1>C:\wxWidgets-2.9.3\include\wx/wxcrt.h(927): warning C4996: 'getenv': This function or variable may be unsafe. Consider using _dupenv_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
+                 c:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\stdlib.h(433) : vea la declaraciÃ³n de 'getenv'
+     1>C:\wxWidgets-2.9.3\include\wx/wxcrt.h(928): warning C4996: 'getenv': This function or variable may be unsafe. Consider using _dupenv_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
+                 c:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\stdlib.h(433) : vea la declaraciÃ³n de 'getenv'
+     1>C:\wxWidgets-2.9.3\include\wx/wxcrt.h(929): warning C4996: '_wgetenv': This function or variable may be unsafe. Consider using _wdupenv_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
+                 c:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\stdlib.h(658) : vea la declaraciÃ³n de '_wgetenv'
+     1>C:\wxWidgets-2.9.3\include\wx/filefn.h(577): warning C4996: '_wopen': This function or variable may be unsafe. Consider using _wsopen_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
+                 c:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\wchar.h(334) : vea la declaraciÃ³n de '_wopen'
+         Todas las salidas estÃ¡n actualizadas.
+       Link:
+         c:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\bin\link.exe /ERRORREPORT:PROMPT /OUT:"C:\Divel\multiverse-city\DivCity\Release\mctcube.dll" /VERSION:"1.0" /INCREMENTAL:NO /NOLOGO /LIBPATH:"C:\Divel\multiverse-city\DivCity\DivCity" /LIBPATH:"C:\wxWidgets-2.9.3\lib\vc_lib" wxmsw29u_core.lib wxbase29u.lib comctl32.lib rpcrt4.lib winmm.lib advapi32.lib wsock32.lib wxpng.lib wxzlib.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /MANIFEST /ManifestFile:"Release\mctcube.dll.intermediate.manifest" /MANIFESTUAC:"level='asInvoker' uiAccess='false'" /DEBUG /PDB:"C:\Divel\multiverse-city\DivCity\Release\mctcube.pdb" /SUBSYSTEM:WINDOWS /OPT:REF /OPT:ICF /LTCG /TLBID:1 /DYNAMICBASE /NXCOMPAT /IMPLIB:"C:\Divel\multiverse-city\DivCity\Release\mctcube.lib" /MACHINE:X86 /DLL Release\main.obj
+         Release\dllmain.obj
+            Creando biblioteca C:\Divel\multiverse-city\DivCity\Release\mctcube.lib y objeto C:\Divel\multiverse-city\DivCity\Release\mctcube.exp
+         Generando cÃ³digo
+         GeneraciÃ³n de cÃ³digo finalizada
+         mctcube.vcxproj -> C:\Divel\multiverse-city\DivCity\Release\mctcube.dll
+       Manifest:
+         c:\Program Files (x86)\Microsoft SDKs\Windows\v7.0A\bin\mt.exe /nologo /verbose /outputresource:"C:\Divel\multiverse-city\DivCity\Release\mctcube.dll;#2" /manifest Release\mctcube.dll.intermediate.manifest
+       FinalizeBuildStatus:
+         Se eliminarÃ¡ el archivo "Release\mctcube.unsuccessfulbuild".
+         Aplicando tarea Touch a "Release\mctcube.lastbuildstate".
+     1>CompilaciÃ³n del proyecto terminada "C:\Divel\multiverse-city\DivCity\mctcube\mctcube.vcxproj" (build destinos).
+
+CompilaciÃ³n correcta.
+
+Tiempo transcurrido 00:00:25.92

=== added file 'DivCity/mctcube/Release/mctcube.write.1.tlog'
--- DivCity/mctcube/Release/mctcube.write.1.tlog	1970-01-01 00:00:00 +0000
+++ DivCity/mctcube/Release/mctcube.write.1.tlog	2012-12-04 20:09:00 +0000
@@ -0,0 +1,30 @@
+^C:\Divel\multiverse-city\DivCity\mctcube\mctcube.vcxproj
+C:\Divel\multiverse-city\DivCity\Release\mctcube.lib
+C:\Divel\multiverse-city\DivCity\Release\mctcube.lib
+C:\Divel\multiverse-city\DivCity\Release\mctcube.exp
+C:\Divel\multiverse-city\DivCity\Release\mctcube.exp
+^C:\Divel\multiverse-city\DivCity\mctcube\mctcube.vcxproj
+C:\Divel\multiverse-city\DivCity\Release\mctcube.lib
+C:\Divel\multiverse-city\DivCity\Release\mctcube.lib
+C:\Divel\multiverse-city\DivCity\Release\mctcube.exp
+C:\Divel\multiverse-city\DivCity\Release\mctcube.exp
+^C:\Divel\multiverse-city\DivCity\mctcube\mctcube.vcxproj
+C:\Divel\multiverse-city\DivCity\Release\mctcube.lib
+C:\Divel\multiverse-city\DivCity\Release\mctcube.lib
+C:\Divel\multiverse-city\DivCity\Release\mctcube.exp
+C:\Divel\multiverse-city\DivCity\Release\mctcube.exp
+^C:\Divel\multiverse-city\DivCity\mctcube\mctcube.vcxproj
+C:\Divel\multiverse-city\DivCity\Release\mctcube.lib
+C:\Divel\multiverse-city\DivCity\Release\mctcube.lib
+C:\Divel\multiverse-city\DivCity\Release\mctcube.exp
+C:\Divel\multiverse-city\DivCity\Release\mctcube.exp
+^C:\Divel\multiverse-city\DivCity\mctcube\mctcube.vcxproj
+C:\Divel\multiverse-city\DivCity\Release\mctcube.lib
+C:\Divel\multiverse-city\DivCity\Release\mctcube.lib
+C:\Divel\multiverse-city\DivCity\Release\mctcube.exp
+C:\Divel\multiverse-city\DivCity\Release\mctcube.exp
+^C:\Divel\multiverse-city\DivCity\mctcube\mctcube.vcxproj
+C:\Divel\multiverse-city\DivCity\Release\mctcube.lib
+C:\Divel\multiverse-city\DivCity\Release\mctcube.lib
+C:\Divel\multiverse-city\DivCity\Release\mctcube.exp
+C:\Divel\multiverse-city\DivCity\Release\mctcube.exp

=== added file 'DivCity/mctcube/Release/mt.command.1.tlog'
Binary files DivCity/mctcube/Release/mt.command.1.tlog	1970-01-01 00:00:00 +0000 and DivCity/mctcube/Release/mt.command.1.tlog	2012-12-04 20:09:04 +0000 differ
=== added file 'DivCity/mctcube/Release/mt.read.1.tlog'
Binary files DivCity/mctcube/Release/mt.read.1.tlog	1970-01-01 00:00:00 +0000 and DivCity/mctcube/Release/mt.read.1.tlog	2012-12-04 20:09:04 +0000 differ
=== added file 'DivCity/mctcube/Release/mt.write.1.tlog'
Binary files DivCity/mctcube/Release/mt.write.1.tlog	1970-01-01 00:00:00 +0000 and DivCity/mctcube/Release/mt.write.1.tlog	2012-12-04 20:09:04 +0000 differ
=== added file 'DivCity/mctcube/Release/vc100.pdb'
Binary files DivCity/mctcube/Release/vc100.pdb	1970-01-01 00:00:00 +0000 and DivCity/mctcube/Release/vc100.pdb	2012-12-04 20:08:48 +0000 differ
=== added file 'DivCity/mctcube/dllmain.cpp'
--- DivCity/mctcube/dllmain.cpp	1970-01-01 00:00:00 +0000
+++ DivCity/mctcube/dllmain.cpp	2012-12-04 18:55:18 +0000
@@ -0,0 +1,19 @@
+// dllmain.cpp : Define el punto de entrada de la aplicación DLL.
+#include <Windows.h>
+
+BOOL APIENTRY DllMain( HMODULE hModule,
+                       DWORD  ul_reason_for_call,
+                       LPVOID lpReserved
+					 )
+{
+	switch (ul_reason_for_call)
+	{
+	case DLL_PROCESS_ATTACH:
+	case DLL_THREAD_ATTACH:
+	case DLL_THREAD_DETACH:
+	case DLL_PROCESS_DETACH:
+		break;
+	}
+	return TRUE;
+}
+

=== added file 'DivCity/mctcube/mctcube.vcxproj'
--- DivCity/mctcube/mctcube.vcxproj	1970-01-01 00:00:00 +0000
+++ DivCity/mctcube/mctcube.vcxproj	2012-12-04 19:07:04 +0000
@@ -0,0 +1,98 @@
+ï»¿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{B5227EA9-EED1-4781-9541-E3E06B376563}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>mctcube</RootNamespace>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <LinkIncremental>true</LinkIncremental>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <LinkIncremental>false</LinkIncremental>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <PrecompiledHeader>Use</PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;MCTCUBE_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;MCTCUBE_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <AdditionalIncludeDirectories>C:\wxWidgets-2.9.3\include;C:\wxWidgets-2.9.3\include\msvc;C:\Divel\multiverse-city\DivCity\DivCity;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>wxmsw29u_core.lib;wxbase29u.lib;comctl32.lib;rpcrt4.lib;winmm.lib;advapi32.lib;wsock32.lib;wxpng.lib;wxzlib.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>C:\Divel\multiverse-city\DivCity\DivCity;C:\wxWidgets-2.9.3\lib\vc_lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <Version>1.0</Version>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <None Include="ReadMe.txt" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="..\..\libmctcube\main.cpp" />
+    <ClCompile Include="dllmain.cpp">
+      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</CompileAsManaged>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+      </PrecompiledHeader>
+      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</CompileAsManaged>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+      </PrecompiledHeader>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="..\..\libmctcube\libmctcube.h" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file

=== added file 'DivCity/mctcube/mctcube.vcxproj.filters'
--- DivCity/mctcube/mctcube.vcxproj.filters	1970-01-01 00:00:00 +0000
+++ DivCity/mctcube/mctcube.vcxproj.filters	2012-12-04 18:44:51 +0000
@@ -0,0 +1,33 @@
+ï»¿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Archivos de cÃ³digo fuente">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Archivos de encabezado">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Archivos de recursos">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <None Include="ReadMe.txt" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="dllmain.cpp">
+      <Filter>Archivos de cÃ³digo fuente</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\libmctcube\main.cpp">
+      <Filter>Archivos de cÃ³digo fuente</Filter>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="..\..\libmctcube\libmctcube.h">
+      <Filter>Archivos de encabezado</Filter>
+    </ClInclude>
+  </ItemGroup>
+</Project>
\ No newline at end of file

=== added file 'DivCity/mctcube/mctcube.vcxproj.user'
--- DivCity/mctcube/mctcube.vcxproj.user	1970-01-01 00:00:00 +0000
+++ DivCity/mctcube/mctcube.vcxproj.user	2012-12-04 18:40:21 +0000
@@ -0,0 +1,3 @@
+ï»¿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+</Project>
\ No newline at end of file

=== modified file 'MCT/Libs.h'
--- MCT/Libs.h	2012-11-10 13:26:34 +0000
+++ MCT/Libs.h	2012-12-04 19:45:54 +0000
@@ -1,4 +1,4 @@
-#ifndef LIBS_H_INCLUDED
+#ifndef LIBS_H_INCLUDED
 #define LIBS_H_INCLUDED
 //Standar
 #include <cstdio>
@@ -10,8 +10,14 @@
 #include <map>
 
 //Linux
+#ifdef linux
 #include <unistd.h>
 #include <pthread.h>
+#endif
+//Windows
+#ifdef WIN32
+#include <Windows.h>
+#endif
 //wxWidgets
 #include <wx/wx.h>
 #include <wx/aboutdlg.h>
@@ -26,13 +32,19 @@
 #include <wx/zipstrm.h>
 #include <wx/wfstream.h>
 #include <wx/txtstrm.h>
-#include <wx/filesys.h>
+#include <wx/filesys.h>
 //Locales
 #include "main.h"
+#include "Path.h"
 #include "VarGlobal.h"
 #include "MCTFrame.h"
 #include "../libmctcube/libmctcube.h"
-//Otros
-#include <vlc/vlc.h>
-
-#endif // LIBS_H_INCLUDED
+//libVLC
+#ifdef WIN32
+#include <vlc/vlc.h>
+#endif
+#ifdef linux
+#include <vlc/vlc.h>
+#endif
+
+#endif // LIBS_H_INCLUDED

=== modified file 'MCT/MCTFrame.cpp'
--- MCT/MCTFrame.cpp	2012-11-10 16:13:44 +0000
+++ MCT/MCTFrame.cpp	2012-12-04 19:48:09 +0000
@@ -1,67 +1,67 @@
-/***************************************************************
- * Name:      Multiverse_CityMain.cpp
- * Purpose:   Code for Application Frame
- * Author:    Adrian Arroyo Calle (adrian.arroyocalle@gmail.com)
- * Created:   2012-10-01
- * Copyright: Adrian Arroyo Calle (sites.google.com/site/divelmedia)
- * License:
- **************************************************************/
-
-#ifdef WX_PRECOMP
-#include "wx_pch.h"
-#endif
-
-#ifdef __BORLANDC__
-#pragma hdrstop
-#endif //__BORLANDC__
-
+/***************************************************************
+ * Name:      Multiverse_CityMain.cpp
+ * Purpose:   Code for Application Frame
+ * Author:    Adrian Arroyo Calle (adrian.arroyocalle@gmail.com)
+ * Created:   2012-10-01
+ * Copyright: Adrian Arroyo Calle (sites.google.com/site/divelmedia)
+ * License: LGPL License
+ **************************************************************/
+
+#ifdef WX_PRECOMP
+#include "wx_pch.h"
+#endif
+
+#ifdef __BORLANDC__
+#pragma hdrstop
+#endif //__BORLANDC__
+
 #include "MCTFrame.h"
-#include "Libs.h"
-
-//helper functions
-enum wxbuildinfoformat {
-    short_f, long_f };
-
-wxString wxbuildinfo(wxbuildinfoformat format)
-{
-    wxString wxbuild(wxVERSION_STRING);
-
-    if (format == long_f )
-    {
-#if defined(__WXMSW__)
-        wxbuild << _T("-Windows");
-#elif defined(__WXMAC__)
-        wxbuild << _T("-Mac");
-#elif defined(__UNIX__)
-        wxbuild << _T("-Linux");
-#endif
-
-#if wxUSE_UNICODE
-        wxbuild << _T("-Unicode build");
-#else
-        wxbuild << _T("-ANSI build");
-#endif // wxUSE_UNICODE
-    }
-
-    return wxbuild;
+#include "Libs.h"
+
+//helper functions
+enum wxbuildinfoformat {
+    short_f, long_f };
+
+wxString wxbuildinfo(wxbuildinfoformat format)
+{
+    wxString wxbuild(wxVERSION_STRING);
+
+    if (format == long_f )
+    {
+#if defined(__WXMSW__)
+        wxbuild << _T("-Windows");
+#elif defined(__WXMAC__)
+        wxbuild << _T("-Mac");
+#elif defined(__UNIX__)
+        wxbuild << _T("-Linux");
+#endif
+
+#if wxUSE_UNICODE
+        wxbuild << _T("-Unicode build");
+#else
+        wxbuild << _T("-ANSI build");
+#endif // wxUSE_UNICODE
+    }
+
+    return wxbuild;
 }
 
 #include "Libs.h"
-#include "MCTFrame.h"
-
-BEGIN_EVENT_TABLE(MCTFrame, wxFrame)
-    //EVT_CLOSE(MCTFrame::OnClose)
-    //EVT_MENU(idMenuQuit, MCTFrame::OnQuit)
+#include "MCTFrame.h"
+
+BEGIN_EVENT_TABLE(MCTFrame, wxFrame)
+    //EVT_CLOSE(MCTFrame::OnClose)
+    //EVT_MENU(idMenuQuit, MCTFrame::OnQuit)
     //EVT_MENU(idMenuAbout, MCTFrame::OnAbout)
     /*EVT_PAINT(MCTFrame::Paint)
     EVT_MOTION(MCTFrame::Motion)
     EVT_KEY_DOWN(MCTFrame::Tecla)
     EVT_CHAR(MCTFrame::Tecla)
-    EVT_CHAR_HOOK(MCTFrame::Tecla)*/
-END_EVENT_TABLE()
-
-MCTFrame::MCTFrame(wxFrame *frame, const wxString& title)
-    : wxFrame(frame, -1, title)
+    EVT_CHAR_HOOK(MCTFrame::Tecla)*/
+END_EVENT_TABLE()
+
+MCTFrame::MCTFrame(wxFrame *frame, const wxString& title)
+    : wxFrame(frame, -1, title)
 {
     //Leer imagen
 
@@ -69,7 +69,7 @@
 	//Iniciar App
     wxInitAllImageHandlers();
     wxBitmap bitmap;
-  if (bitmap.LoadFile(_("/usr/share/multiverse-city/media/splash.png"), wxBITMAP_TYPE_PNG))
+  if (bitmap.LoadFile(_(SPLASH), wxBITMAP_TYPE_PNG))
   {
       wxSplashScreen* splash = new wxSplashScreen(bitmap,
           wxSPLASH_CENTRE_ON_SCREEN|wxSPLASH_TIMEOUT,
@@ -93,19 +93,19 @@
 
 
   /*
-
-#if wxUSE_MENUS
-    // create a menu bar
-    wxMenuBar* mbar = new wxMenuBar();
-    wxMenu* fileMenu = new wxMenu(_T(""));
-    fileMenu->Append(idMenuQuit, _("&Quit\tAlt-F4"), _("Exit of Multiverse City"));
-    mbar->Append(fileMenu, _("&File"));
-
-    wxMenu* helpMenu = new wxMenu(_T(""));
-    helpMenu->Append(idMenuAbout, _("&About\tF1"), _("About the author"));
-    mbar->Append(helpMenu, _("&Help"));
-
-    SetMenuBar(mbar);
+
+#if wxUSE_MENUS
+    // create a menu bar
+    wxMenuBar* mbar = new wxMenuBar();
+    wxMenu* fileMenu = new wxMenu(_T(""));
+    fileMenu->Append(idMenuQuit, _("&Quit\tAlt-F4"), _("Exit of Multiverse City"));
+    mbar->Append(fileMenu, _("&File"));
+
+    wxMenu* helpMenu = new wxMenu(_T(""));
+    helpMenu->Append(idMenuAbout, _("&About\tF1"), _("About the author"));
+    mbar->Append(helpMenu, _("&Help"));
+
+    SetMenuBar(mbar);
 #endif // wxUSE_MENUS
     SetSize(300,400);
 
@@ -113,15 +113,15 @@
     wxButton* cargar=new wxButton(panel,ID_CARGAR,_("Load a city and Play"),wxPoint(100,100));
     wxButton* nuevo=new wxButton(panel,ID_NUEVO,_("Play new city"),wxPoint(100,200));
     Connect( ID_CARGAR,wxEVT_COMMAND_BUTTON_CLICKED,wxCommandEventHandler(Multiverse_CityFrame::Cargar) );
-    Connect( ID_NUEVO,wxEVT_COMMAND_BUTTON_CLICKED,wxCommandEventHandler(Multiverse_CityFrame::Nuevo) );
-
-#if wxUSE_STATUSBAR
-    // create a status bar with some information about the used wxWidgets version
-    CreateStatusBar(2);
-    SetStatusText(_("Multiverse City 1.0"),0);
-    SetStatusText(_("Try also Azpazeta and Monopoly"), 1);
-#endif // wxUSE_STATUSBAR*/
-
+    Connect( ID_NUEVO,wxEVT_COMMAND_BUTTON_CLICKED,wxCommandEventHandler(Multiverse_CityFrame::Nuevo) );
+
+#if wxUSE_STATUSBAR
+    // create a status bar with some information about the used wxWidgets version
+    CreateStatusBar(2);
+    SetStatusText(_("Multiverse City 1.0"),0);
+    SetStatusText(_("Try also Azpazeta and Monopoly"), 1);
+#endif // wxUSE_STATUSBAR*/
+
 }
 MCTFrame::~MCTFrame(){
 
@@ -199,7 +199,7 @@
     //Cuadros secundarios
     ax=0;
     ay=0;
-    wxBitmap toolbox(_("/usr/share/multiverse-city/media/toolbox.png"),wxBITMAP_TYPE_PNG);
+    wxBitmap toolbox(_(TOOLBOX),wxBITMAP_TYPE_PNG);
     dc.DrawBitmap(toolbox,wxPoint(1,1));
     dc.SetTextBackground(_("WHITE"));
     dc.SetTextForeground(_("WHITE"));
@@ -298,7 +298,7 @@
 
             wxClientDC dc(this);
             Renderizar(dc);
-            wxBitmap dibujo(_("/usr/share/multiverse-city/media/pointer.png"),wxBITMAP_TYPE_PNG);
+            wxBitmap dibujo(_(POINTER),wxBITMAP_TYPE_PNG);
             dc.DrawBitmap(dibujo,wxPoint(bitmapactual[numero]->x,bitmapactual[numero]->y));
             }
 
@@ -589,7 +589,7 @@
     //Cuadros secundarios
     ax=0;
     ay=0;
-    wxBitmap toolbox(_("/usr/share/multiverse-city/media/toolbox.png"),wxBITMAP_TYPE_PNG);
+    wxBitmap toolbox(_(TOOLBOX),wxBITMAP_TYPE_PNG);
     dc.DrawBitmap(toolbox,wxPoint(1,1));
 
     screen=MAIN;

=== modified file 'MCT/MCTFrame.h'
--- MCT/MCTFrame.h	2012-11-10 13:26:34 +0000
+++ MCT/MCTFrame.h	2012-12-04 18:44:51 +0000
@@ -1,5 +1,5 @@
-#ifndef MCTFRAME_H_INCLUDED
-#define MCTFRAME_H_INCLUDED
+#ifndef MCTFRAME_H_INCLUDED
+#define MCTFRAME_H_INCLUDED
 #include "Libs.h"
 
 class MCTFrame;
@@ -35,30 +35,30 @@
 };
 
 
-class MCTFrame: public wxFrame
-{
-    public:
-        MCTFrame(wxFrame *frame, const wxString& title);
-        ~MCTFrame();
-    private:
-        enum
-        {
-            idMenuQuit = 1000,
+class MCTFrame: public wxFrame
+{
+    public:
+        MCTFrame(wxFrame *frame, const wxString& title);
+        ~MCTFrame();
+    private:
+        enum
+        {
+            idMenuQuit = 1000,
             idMenuAbout,
             ID_CARGAR,
-            ID_NUEVO
-        };
-        void OnClose(wxCloseEvent& event);
-        void OnQuit(wxCommandEvent& event);
+            ID_NUEVO
+        };
+        void OnClose(wxCloseEvent& event);
+        void OnQuit(wxCommandEvent& event);
         void OnAbout(wxCommandEvent& event);
         void Cargar(wxCommandEvent& event);
         void Nuevo(wxCommandEvent& event);
         bool ComprobarArchivos();
-
+
         DECLARE_EVENT_TABLE()
-
+
 };
-
-
-
+
+
+
 #endif

=== added file 'MCT/Path.h'
--- MCT/Path.h	1970-01-01 00:00:00 +0000
+++ MCT/Path.h	2012-12-04 20:00:27 +0000
@@ -0,0 +1,24 @@
+#ifndef PATH_H
+#define PATH_H
+
+#ifdef WIN32
+
+#define TOOLBOX "media/toolbox.png"
+#define POINTER "media/pointer.png"
+#define SPLASH "media/splash.png"
+#define ALERTBOX "media/alertbox.png"
+#define ROAD_PATH "media/road.png"
+#define INDUSTRIA_PATH "media/industria.png"
+#define RESIDENCIA_MODERNA_PATH "media/residencia_moderna.png"
+#define AMARILLA_PATH "media/amarilla.png"
+#define OFICINA_PATH "media/oficina.png"
+#define CLEAN_PATH "media/template.png"
+#define VALLA_PATH "media/valla.png"
+
+
+
+#endif
+
+
+
+#endif
\ No newline at end of file

=== modified file 'MCT/main.cpp'
--- MCT/main.cpp	2012-11-10 09:27:59 +0000
+++ MCT/main.cpp	2012-12-04 19:39:55 +0000
@@ -1,43 +1,43 @@
-/***************************************************************
- * Name:      main.cpp
- * Purpose:   Code for Application Class
- * Author:    Adrian Arroyo Calle (adrian.arroyocalle@gmail.com)
- * Created:   2012-10-01
- * Copyright: Adrian Arroyo Calle (sites.google.com/site/divelmedia)
- * License: GPLv3
- **************************************************************/
-
-#ifdef WX_PRECOMP
-#include "wx_pch.h"
-#endif
-
-#ifdef __BORLANDC__
-#pragma hdrstop
-#endif //__BORLANDC__
+/***************************************************************
+ * Name:      main.cpp
+ * Purpose:   Code for Application Class
+ * Author:    Adrian Arroyo Calle (adrian.arroyocalle@gmail.com)
+ * Created:   2012-10-01
+ * Copyright: Adrian Arroyo Calle (sites.google.com/site/divelmedia)
+ * License: GPLv3
+ **************************************************************/
+
+#ifdef WX_PRECOMP
+#include "wx_pch.h"
+#endif
+
+#ifdef __BORLANDC__
+#pragma hdrstop
+#endif //__BORLANDC__
 
 #include "Libs.h"
 
-
-
-IMPLEMENT_APP(MCTApp);
-
-bool MCTApp::OnInit()
+
+
+IMPLEMENT_APP(MCTApp);
+
+bool MCTApp::OnInit()
 {
     SetAppName(wxT("Multiverse City"));
 	SetVendorName(wxT("AdriÃ¡n Arroyo Calle for Divel"));
 	if(wxApp::argc>=2)
 	{
 
-	}
-    MCTFrame* frame = new MCTFrame(0L, _("Multiverse City"));
-
-    frame->Show();
+	}
+    MCTFrame* frame = new MCTFrame(0L, _("Multiverse City"));
+
+    frame->Show();
     #ifdef PTHREAD
         pthread_t mythread;
-        pthread_create(&mythread, NULL, Music, NULL);
+        pthread_create(&mythread, NULL, Music, NULL);
     #endif PTHREAD
-
-    return true;
+
+    return true;
 }
 void MCTApp::OnInitCmdLine(wxCmdLineParser& parser)
 {
@@ -62,6 +62,7 @@
 
     return true;
 }
+#ifndef WIN32
 void* Music(void* var){
 
 
@@ -128,3 +129,44 @@
 
 }
 
+#else
+DWORD Music(LPVOID var)
+{
+	libvlc_instance_t *vlc;
+	libvlc_media_list_t *ml;
+    libvlc_media_list_player_t *mlp;
+    libvlc_media_player_t *mp;
+    libvlc_media_t *md1, *md2;
+
+    vlc = libvlc_new (0, NULL);
+	if(vlc==NULL){
+
+		wxMessageBox(_("libVLC ha fallado. No tendrÃ¡s sonido"),_("DivError"),wxICON_ERROR|wxOK);
+	}
+    ml = libvlc_media_list_new(vlc);
+
+    md1 = libvlc_media_new_path(vlc, "./audio/TheGiantTrees.mp3");
+    md2 = libvlc_media_new_path(vlc, "./audio/Everyday.mp3");
+
+    libvlc_media_list_add_media(ml, md1);
+    libvlc_media_list_add_media(ml, md2);
+
+    libvlc_media_release(md1);
+    libvlc_media_release(md2);
+
+    mlp = libvlc_media_list_player_new(vlc);
+
+    mp = libvlc_media_player_new(vlc);
+
+
+    libvlc_media_list_player_set_media_list(mlp, ml);
+
+    libvlc_media_list_player_play(mlp);
+
+	return 0;
+
+}
+
+
+
+#endif
\ No newline at end of file

=== modified file 'MCT/main.h'
--- MCT/main.h	2012-11-10 04:26:57 +0000
+++ MCT/main.h	2012-12-04 18:29:51 +0000
@@ -1,16 +1,16 @@
-#ifndef MAIN_H_INCLUDED
-#define MAIN_H_INCLUDED
-
+#ifndef MAIN_H_INCLUDED
+#define MAIN_H_INCLUDED
+
 #include <wx/app.h>
-#include "Libs.h"
-
-class MCTApp : public wxApp
-{
-    public:
+#include "Libs.h"
+
+class MCTApp : public wxApp
+{
+    public:
         virtual bool OnInit();
         virtual void OnInitCmdLine(wxCmdLineParser& parser);
         virtual bool OnCmdLineParsed(wxCmdLineParser& parser);
-
+
 };
 static const wxCmdLineEntryDesc g_cmdLineDesc [] =
 {
@@ -19,6 +19,10 @@
 
      { wxCMD_LINE_NONE }
 };
-void* Music(void* var);
-
-#endif // MAIN_H_INCLUDED
+#ifndef WIN32
+void* Music(void* var);
+#else
+DWORD Music(LPVOID var);
+#endif
+
+#endif // MAIN_H_INCLUDED

=== modified file 'libmctcube/libmctcube.h'
--- libmctcube/libmctcube.h	2012-11-10 16:13:44 +0000
+++ libmctcube/libmctcube.h	2012-12-04 19:11:10 +0000
@@ -1,5 +1,13 @@
-#ifndef LIBMCTCUBE_H_INCLUDED
-#define LIBMCTCUBE_H_INCLUDED
+#ifndef LIBMCTCUBE_H_INCLUDED
+#define LIBMCTCUBE_H_INCLUDED
+
+#ifdef WIN32
+#	ifdef MCTCUBE_EXPORTS
+#		define MCTCUBE_API __declspec(dllexport)
+#	else
+#		define MCTCUBE_API __declspec(dllimport)
+#	endif
+#endif
 
 #include "../MCT/Libs.h"
 typedef enum{
@@ -16,31 +24,31 @@
 
 
 
-
-typedef class Casilla{
+
+class MCTCUBE_API Casilla{
 
 
 
 
 public:
-Casilla(MCTCasilla id);
-wxBitmap GetBitmap();
-int x; //Coordenada X
-int y; //Coordenada Y
-wxBitmap actual;
-void SetBitmap(wxBitmap nuevo);
-void SetCasilla(MCTCasilla id);
-MCTCasilla GetCasilla();
+	Casilla(MCTCasilla id);
+	wxBitmap	GetBitmap();
+	int			x;		//Coordenada X
+	int			y;		//Coordenada Y
+	wxBitmap	actual;
+	void		SetBitmap(wxBitmap nuevo);
+	void		SetCasilla(MCTCasilla id);
+	MCTCasilla	GetCasilla();
 private:
-MCTCasilla lacasilla;
-
-
-
-
-
-}Casilla;
-
-class AlertBox{
+	MCTCasilla	lacasilla;
+
+
+
+
+
+};
+
+class MCTCUBE_API AlertBox{
 
 public:
 AlertBox(wxString title,wxString message);
@@ -50,6 +58,6 @@
 
 
 };
-
-
-#endif // LIBMCTCUBE_H_INCLUDED
+
+
+#endif // LIBMCTCUBE_H_INCLUDED

=== modified file 'libmctcube/main.cpp'
--- libmctcube/main.cpp	2012-11-10 16:13:44 +0000
+++ libmctcube/main.cpp	2012-12-04 20:08:35 +0000
@@ -11,15 +11,15 @@
 #include "libmctcube.h"
 
 Casilla::Casilla(MCTCasilla id){
-
+	wxInitAllImageHandlers();
 switch(id){
-    case CLEAN:{actual=wxBitmap(_("/usr/share/multiverse-city/media/template.png"),wxBITMAP_TYPE_PNG);}break;
-    case VALLA:{actual=wxBitmap(_("/usr/share/multiverse-city/media/valla.png"),wxBITMAP_TYPE_PNG);}break;
-    case OFICINA:{actual=wxBitmap(_("/usr/share/multiverse-city/media/oficina.png"),wxBITMAP_TYPE_PNG);}break;
-    case RES1:{actual=wxBitmap(_("/usr/share/multiverse-city/media/amarilla.png"),wxBITMAP_TYPE_PNG);}break;
-    case RES2:{actual=wxBitmap(_("/usr/share/multiverse-city/media/residencia_moderna.png"),wxBITMAP_TYPE_PNG);}break;
-    case INDUSTRIA:{actual=wxBitmap(_("/usr/share/multiverse-city/media/industria.png"),wxBITMAP_TYPE_PNG);}break;
-    case ROAD:{actual=wxBitmap(_("/usr/share/multiverse-city/media/road.png"),wxBITMAP_TYPE_PNG);}break;
+case CLEAN:{actual=wxBitmap(_(CLEAN_PATH),wxBITMAP_TYPE_PNG);}break;
+    case VALLA:{actual=wxBitmap(_(VALLA_PATH),wxBITMAP_TYPE_PNG);}break;
+    case OFICINA:{actual=wxBitmap(_(OFICINA_PATH),wxBITMAP_TYPE_PNG);}break;
+    case RES1:{actual=wxBitmap(_(AMARILLA_PATH),wxBITMAP_TYPE_PNG);}break;
+    case RES2:{actual=wxBitmap(_(RESIDENCIA_MODERNA_PATH),wxBITMAP_TYPE_PNG);}break;
+    case INDUSTRIA:{actual=wxBitmap(_(INDUSTRIA_PATH),wxBITMAP_TYPE_PNG);}break;
+    case ROAD:{actual=wxBitmap(_(ROAD_PATH),wxBITMAP_TYPE_PNG);}break;
     default:{}
 
 
@@ -49,14 +49,15 @@
 }
 void Casilla::SetCasilla(MCTCasilla id)
 {
+	wxInitAllImageHandlers();
     switch(id){
-    case CLEAN:{actual=wxBitmap(_("/usr/share/multiverse-city/media/template.png"),wxBITMAP_TYPE_PNG);}break;
-    case VALLA:{actual=wxBitmap(_("/usr/share/multiverse-city/media/valla.png"),wxBITMAP_TYPE_PNG);}break;
-    case OFICINA:{actual=wxBitmap(_("/usr/share/multiverse-city/media/oficina.png"),wxBITMAP_TYPE_PNG);}break;
-    case RES1:{actual=wxBitmap(_("/usr/share/multiverse-city/media/amarilla.png"),wxBITMAP_TYPE_PNG);}break;
-    case RES2:{actual=wxBitmap(_("/usr/share/multiverse-city/media/residencia_moderna.png"),wxBITMAP_TYPE_PNG);}break;
-    case INDUSTRIA:{actual=wxBitmap(_("/usr/share/multiverse-city/media/industria.png"),wxBITMAP_TYPE_PNG);}break;
-    case ROAD:{actual=wxBitmap(_("/usr/share/multiverse-city/media/road.png"),wxBITMAP_TYPE_PNG);}break;
+    case CLEAN:{actual=wxBitmap(_(CLEAN_PATH),wxBITMAP_TYPE_PNG);}break;
+    case VALLA:{actual=wxBitmap(_(VALLA_PATH),wxBITMAP_TYPE_PNG);}break;
+    case OFICINA:{actual=wxBitmap(_(OFICINA_PATH),wxBITMAP_TYPE_PNG);}break;
+    case RES1:{actual=wxBitmap(_(AMARILLA_PATH),wxBITMAP_TYPE_PNG);}break;
+    case RES2:{actual=wxBitmap(_(RESIDENCIA_MODERNA_PATH),wxBITMAP_TYPE_PNG);}break;
+    case INDUSTRIA:{actual=wxBitmap(_(INDUSTRIA_PATH),wxBITMAP_TYPE_PNG);}break;
+    case ROAD:{actual=wxBitmap(_(ROAD_PATH),wxBITMAP_TYPE_PNG);}break;
     default:{}
 
 
@@ -83,7 +84,8 @@
 }
 void AlertBox::Show(wxWindow* window)
 {
-     wxBitmap alertbox(_("/usr/share/multiverse-city/media/alertbox.png"),wxBITMAP_TYPE_PNG);
+	wxInitAllImageHandlers();
+     wxBitmap alertbox(_(ALERTBOX),wxBITMAP_TYPE_PNG);
         wxClientDC dc(window);
         dc.DrawBitmap(alertbox,wxPoint(500,300));
         dc.DrawText(mytitle,wxPoint(500+38,300+22));

